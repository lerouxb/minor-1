
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/minor-1.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
../../../../crt1/gcrt1.S:61
       0:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__ctors_end>
../../../../crt1/gcrt1.S:67
       4:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:68
       8:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:69
       c:	0c 94 bd 06 	jmp	0xd7a	; 0xd7a <__vector_3>
../../../../crt1/gcrt1.S:70
      10:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:71
      14:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:72
      18:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:73
      1c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:74
      20:	0c 94 e9 06 	jmp	0xdd2	; 0xdd2 <__vector_8>
../../../../crt1/gcrt1.S:75
      24:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:76
      28:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:77
      2c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:78
      30:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:79
      34:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:80
      38:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:81
      3c:	0c 94 0c 05 	jmp	0xa18	; 0xa18 <__vector_15>
../../../../crt1/gcrt1.S:82
      40:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:83
      44:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:84
      48:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:85
      4c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:86
      50:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:87
      54:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:88
      58:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:89
      5c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:90
      60:	0c 94 62 05 	jmp	0xac4	; 0xac4 <__vector_24>
../../../../crt1/gcrt1.S:91
      64:	0c 94 05 06 	jmp	0xc0a	; 0xc0a <__vector_25>
../../../../crt1/gcrt1.S:92
      68:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:93
      6c:	0c 94 de 04 	jmp	0x9bc	; 0x9bc <__vector_27>
../../../../crt1/gcrt1.S:94
      70:	0c 94 b8 04 	jmp	0x970	; 0x970 <__vector_28>
../../../../crt1/gcrt1.S:95
      74:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:96
      78:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>

0000007c <__ctors_start>:
__trampolines_start():
      7c:	d4 07       	cpc	r29, r20

0000007e <__ctors_end>:
__dtors_end():
../../../../crt1/gcrt1.S:230
      7e:	11 24       	eor	r1, r1
../../../../crt1/gcrt1.S:231
      80:	1f be       	out	0x3f, r1	; 63
../../../../crt1/gcrt1.S:232
      82:	cf ef       	ldi	r28, 0xFF	; 255
../../../../crt1/gcrt1.S:234
      84:	cd bf       	out	0x3d, r28	; 61
../../../../crt1/gcrt1.S:236
      86:	df e3       	ldi	r29, 0x3F	; 63
../../../../crt1/gcrt1.S:237
      88:	de bf       	out	0x3e, r29	; 62

0000008a <__do_clear_bss>:
__do_clear_bss():
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
      8a:	2a e3       	ldi	r18, 0x3A	; 58
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
      8c:	aa e2       	ldi	r26, 0x2A	; 42
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
      8e:	b8 e3       	ldi	r27, 0x38	; 56
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
      94:	a5 36       	cpi	r26, 0x65	; 101
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
      96:	b2 07       	cpc	r27, r18
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>

0000009a <__do_copy_data>:
__do_copy_data():
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2409
      9a:	18 e3       	ldi	r17, 0x38	; 56
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2410
      9c:	a0 e0       	ldi	r26, 0x00	; 0
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2411
      9e:	b8 e3       	ldi	r27, 0x38	; 56
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2412
      a0:	e6 eb       	ldi	r30, 0xB6	; 182
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2413
      a2:	fe e1       	ldi	r31, 0x1E	; 30
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2414
      a4:	02 c0       	rjmp	.+4      	; 0xaa <__do_copy_data+0x10>
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2417
      a6:	05 90       	lpm	r0, Z+
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2422
      a8:	0d 92       	st	X+, r0
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2424
      aa:	aa 32       	cpi	r26, 0x2A	; 42
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2425
      ac:	b1 07       	cpc	r27, r17
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2426
      ae:	d9 f7       	brne	.-10     	; 0xa6 <__do_copy_data+0xc>

000000b0 <__do_global_ctors>:
__do_global_ctors():
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
      b0:	10 e0       	ldi	r17, 0x00	; 0
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
      b2:	cf e3       	ldi	r28, 0x3F	; 63
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
      b4:	d0 e0       	ldi	r29, 0x00	; 0
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
      b6:	04 c0       	rjmp	.+8      	; 0xc0 <__do_global_ctors+0x10>
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
      b8:	21 97       	sbiw	r28, 0x01	; 1
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
      ba:	fe 01       	movw	r30, r28
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
      bc:	0e 94 f8 0d 	call	0x1bf0	; 0x1bf0 <__tablejump2__>
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
      c0:	ce 33       	cpi	r28, 0x3E	; 62
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
      c2:	d1 07       	cpc	r29, r17
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
      c4:	c9 f7       	brne	.-14     	; 0xb8 <__do_global_ctors+0x8>
../../../../crt1/gcrt1.S:314
      c6:	0e 94 22 08 	call	0x1044	; 0x1044 <main>
../../../../crt1/gcrt1.S:315
      ca:	0c 94 16 0e 	jmp	0x1c2c	; 0x1c2c <_exit>

000000ce <__bad_interrupt>:
__vector_22():
../../../../crt1/gcrt1.S:209
      ce:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d2 <CmdBuffer<32u>::getBuffer()>:
_ZN9CmdBufferILj32EE9getBufferEv():
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdBuffer.hpp:151
    virtual void clear() { memset(m_buffer, 0x00, BUFFERSIZE + 1); }

    /**
     * @interface CmdBufferObject
     */
    virtual uint8_t *getBuffer() { return m_buffer; }
      d2:	07 96       	adiw	r24, 0x07	; 7
      d4:	08 95       	ret

000000d6 <CmdBuffer<32u>::getBufferSize()>:
_ZN9CmdBufferILj32EE13getBufferSizeEv():
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdBuffer.hpp:156

    /**
     * @interface CmdBufferObject
     */
    virtual size_t getBufferSize() { return BUFFERSIZE; }
      d6:	80 e2       	ldi	r24, 0x20	; 32
      d8:	90 e0       	ldi	r25, 0x00	; 0
      da:	08 95       	ret

000000dc <Print::write(unsigned char const*, unsigned int)>:
_ZN5Print5writeEPKhj():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:29
#include "Print.h"

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size) {
      dc:	af 92       	push	r10
      de:	bf 92       	push	r11
      e0:	cf 92       	push	r12
      e2:	df 92       	push	r13
      e4:	ef 92       	push	r14
      e6:	ff 92       	push	r15
      e8:	0f 93       	push	r16
      ea:	1f 93       	push	r17
      ec:	cf 93       	push	r28
      ee:	df 93       	push	r29
      f0:	6c 01       	movw	r12, r24
      f2:	7b 01       	movw	r14, r22
      f4:	8b 01       	movw	r16, r22
      f6:	04 0f       	add	r16, r20
      f8:	15 1f       	adc	r17, r21
      fa:	eb 01       	movw	r28, r22
      fc:	5e 01       	movw	r10, r28
      fe:	ae 18       	sub	r10, r14
     100:	bf 08       	sbc	r11, r15
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:31
  size_t n = 0;
  while (size--) {
     102:	c0 17       	cp	r28, r16
     104:	d1 07       	cpc	r29, r17
     106:	59 f0       	breq	.+22     	; 0x11e <__EEPROM_REGION_LENGTH__+0x1e>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:32
    if (write(*buffer++)) {
     108:	69 91       	ld	r22, Y+
     10a:	d6 01       	movw	r26, r12
     10c:	ed 91       	ld	r30, X+
     10e:	fc 91       	ld	r31, X
     110:	01 90       	ld	r0, Z+
     112:	f0 81       	ld	r31, Z
     114:	e0 2d       	mov	r30, r0
     116:	c6 01       	movw	r24, r12
     118:	09 95       	icall
     11a:	89 2b       	or	r24, r25
     11c:	79 f7       	brne	.-34     	; 0xfc <Print::write(unsigned char const*, unsigned int)+0x20>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:39
    } else {
      break;
    }
  }
  return n;
}
     11e:	c5 01       	movw	r24, r10
     120:	df 91       	pop	r29
     122:	cf 91       	pop	r28
     124:	1f 91       	pop	r17
     126:	0f 91       	pop	r16
     128:	ff 90       	pop	r15
     12a:	ef 90       	pop	r14
     12c:	df 90       	pop	r13
     12e:	cf 90       	pop	r12
     130:	bf 90       	pop	r11
     132:	af 90       	pop	r10
     134:	08 95       	ret

00000136 <UartClass::availableForWrite()>:
_ZN9UartClass17availableForWriteEv():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:323
int UartClass::availableForWrite(void) {
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
     136:	fc 01       	movw	r30, r24
     138:	50 8d       	ldd	r21, Z+24	; 0x18
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:324
    tail = _tx_buffer_tail;
     13a:	41 8d       	ldd	r20, Z+25	; 0x19
     13c:	25 2f       	mov	r18, r21
     13e:	30 e0       	ldi	r19, 0x00	; 0
     140:	84 2f       	mov	r24, r20
     142:	90 e0       	ldi	r25, 0x00	; 0
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:327
  }
  if (head >= tail) {
    return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
     144:	82 1b       	sub	r24, r18
     146:	93 0b       	sbc	r25, r19
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:326

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
    tail = _tx_buffer_tail;
  }
  if (head >= tail) {
     148:	54 17       	cp	r21, r20
     14a:	10 f0       	brcs	.+4      	; 0x150 <UartClass::availableForWrite()+0x1a>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:327
    return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
     14c:	cf 96       	adiw	r24, 0x3f	; 63
     14e:	08 95       	ret
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:329
  }
  return tail - head - 1;
     150:	01 97       	sbiw	r24, 0x01	; 1
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:330
}
     152:	08 95       	ret

00000154 <UartClass::read()>:
_ZN9UartClass4readEv():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:307
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}

int UartClass::read(void) {
     154:	fc 01       	movw	r30, r24
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:309
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
     156:	96 89       	ldd	r25, Z+22	; 0x16
     158:	87 89       	ldd	r24, Z+23	; 0x17
     15a:	98 17       	cp	r25, r24
     15c:	61 f0       	breq	.+24     	; 0x176 <UartClass::read()+0x22>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:312
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
     15e:	a7 89       	ldd	r26, Z+23	; 0x17
     160:	ae 0f       	add	r26, r30
     162:	bf 2f       	mov	r27, r31
     164:	b1 1d       	adc	r27, r1
     166:	5b 96       	adiw	r26, 0x1b	; 27
     168:	8c 91       	ld	r24, X
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:313
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) & (SERIAL_RX_BUFFER_SIZE-1); // % SERIAL_RX_BUFFER_SIZE;
     16a:	97 89       	ldd	r25, Z+23	; 0x17
     16c:	9f 5f       	subi	r25, 0xFF	; 255
     16e:	9f 73       	andi	r25, 0x3F	; 63
     170:	97 8b       	std	Z+23, r25	; 0x17
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:314
    return c;
     172:	90 e0       	ldi	r25, 0x00	; 0
     174:	08 95       	ret
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:310
}

int UartClass::read(void) {
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
     176:	8f ef       	ldi	r24, 0xFF	; 255
     178:	9f ef       	ldi	r25, 0xFF	; 255
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:316
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) & (SERIAL_RX_BUFFER_SIZE-1); // % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
     17a:	08 95       	ret

0000017c <UartClass::peek()>:
_ZN9UartClass4peekEv():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:299

int UartClass::available(void) {
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE-1); //% SERIAL_RX_BUFFER_SIZE;
}

int UartClass::peek(void) {
     17c:	fc 01       	movw	r30, r24
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:300
  if (_rx_buffer_head == _rx_buffer_tail) {
     17e:	96 89       	ldd	r25, Z+22	; 0x16
     180:	87 89       	ldd	r24, Z+23	; 0x17
     182:	98 17       	cp	r25, r24
     184:	31 f0       	breq	.+12     	; 0x192 <UartClass::peek()+0x16>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:303
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
     186:	87 89       	ldd	r24, Z+23	; 0x17
     188:	e8 0f       	add	r30, r24
     18a:	f1 1d       	adc	r31, r1
     18c:	83 8d       	ldd	r24, Z+27	; 0x1b
     18e:	90 e0       	ldi	r25, 0x00	; 0
     190:	08 95       	ret
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:301
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE-1); //% SERIAL_RX_BUFFER_SIZE;
}

int UartClass::peek(void) {
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
     192:	8f ef       	ldi	r24, 0xFF	; 255
     194:	9f ef       	ldi	r25, 0xFF	; 255
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:305
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
     196:	08 95       	ret

00000198 <UartClass::available()>:
_ZN9UartClass9availableEv():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:295

  // Note: Does not change output pins
  _written = false;
}

int UartClass::available(void) {
     198:	fc 01       	movw	r30, r24
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:296
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE-1); //% SERIAL_RX_BUFFER_SIZE;
     19a:	96 89       	ldd	r25, Z+22	; 0x16
     19c:	27 89       	ldd	r18, Z+23	; 0x17
     19e:	89 2f       	mov	r24, r25
     1a0:	90 e0       	ldi	r25, 0x00	; 0
     1a2:	80 5c       	subi	r24, 0xC0	; 192
     1a4:	9f 4f       	sbci	r25, 0xFF	; 255
     1a6:	82 1b       	sub	r24, r18
     1a8:	91 09       	sbc	r25, r1
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:297
}
     1aa:	8f 73       	andi	r24, 0x3F	; 63
     1ac:	99 27       	eor	r25, r25
     1ae:	08 95       	ret

000001b0 <UartClass::end()>:
_ZN9UartClass3endEv():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:279

  // Restore SREG content
  SREG = oldSREG;
}

void UartClass::end() {
     1b0:	cf 93       	push	r28
     1b2:	df 93       	push	r29
     1b4:	ec 01       	movw	r28, r24
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:281
  // wait for transmission of outgoing data
  flush();
     1b6:	e8 81       	ld	r30, Y
     1b8:	f9 81       	ldd	r31, Y+1	; 0x01
     1ba:	02 84       	ldd	r0, Z+10	; 0x0a
     1bc:	f3 85       	ldd	r31, Z+11	; 0x0b
     1be:	e0 2d       	mov	r30, r0
     1c0:	09 95       	icall
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:285

  // Disable receiver and transmitter as well as the RX complete and
  // data register empty interrupts.
  (*_hwserial_module).CTRLB &= ~(USART_RXEN_bm | USART_TXEN_bm);
     1c2:	ec 85       	ldd	r30, Y+12	; 0x0c
     1c4:	fd 85       	ldd	r31, Y+13	; 0x0d
     1c6:	86 81       	ldd	r24, Z+6	; 0x06
     1c8:	8f 73       	andi	r24, 0x3F	; 63
     1ca:	86 83       	std	Z+6, r24	; 0x06
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:286
  (*_hwserial_module).CTRLA &= ~(USART_RXCIE_bm | USART_DREIE_bm);
     1cc:	ec 85       	ldd	r30, Y+12	; 0x0c
     1ce:	fd 85       	ldd	r31, Y+13	; 0x0d
     1d0:	85 81       	ldd	r24, Z+5	; 0x05
     1d2:	8f 75       	andi	r24, 0x5F	; 95
     1d4:	85 83       	std	Z+5, r24	; 0x05
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:289

  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
     1d6:	8f 89       	ldd	r24, Y+23	; 0x17
     1d8:	8e 8b       	std	Y+22, r24	; 0x16
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:292

  // Note: Does not change output pins
  _written = false;
     1da:	1d 8a       	std	Y+21, r1	; 0x15
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:293
}
     1dc:	df 91       	pop	r29
     1de:	cf 91       	pop	r28
     1e0:	08 95       	ret

000001e2 <UartClass::_tx_data_empty_irq()>:
_ZN9UartClass18_tx_data_empty_irqEv():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:96
  #define TX_BUFFER_ATOMIC
#endif

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void UartClass::_tx_data_empty_irq(void) {
     1e2:	cf 93       	push	r28
     1e4:	df 93       	push	r29
     1e6:	fc 01       	movw	r30, r24
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:98
  // Check if tx buffer already empty.
  if (_tx_buffer_head == _tx_buffer_tail) {
     1e8:	90 8d       	ldd	r25, Z+24	; 0x18
     1ea:	81 8d       	ldd	r24, Z+25	; 0x19
     1ec:	c4 85       	ldd	r28, Z+12	; 0x0c
     1ee:	d5 85       	ldd	r29, Z+13	; 0x0d
     1f0:	98 13       	cpse	r25, r24
     1f2:	06 c0       	rjmp	.+12     	; 0x200 <UartClass::_tx_data_empty_irq()+0x1e>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:100
    // Buffer empty, so disable "data register empty" interrupt
    (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
     1f4:	8d 81       	ldd	r24, Y+5	; 0x05
     1f6:	8f 7d       	andi	r24, 0xDF	; 223
     1f8:	8d 83       	std	Y+5, r24	; 0x05
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:120

  if (_tx_buffer_head == _tx_buffer_tail) {
    // Buffer empty, so disable "data register empty" interrupt
    (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
  }
}
     1fa:	df 91       	pop	r29
     1fc:	cf 91       	pop	r28
     1fe:	08 95       	ret
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:106
    return;
  }

  // There must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
     200:	a1 8d       	ldd	r26, Z+25	; 0x19
     202:	ae 0f       	add	r26, r30
     204:	bf 2f       	mov	r27, r31
     206:	b1 1d       	adc	r27, r1
     208:	a5 5a       	subi	r26, 0xA5	; 165
     20a:	bf 4f       	sbci	r27, 0xFF	; 255
     20c:	9c 91       	ld	r25, X
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:107
  _tx_buffer_tail = (_tx_buffer_tail + 1) & (SERIAL_TX_BUFFER_SIZE-1); //% SERIAL_TX_BUFFER_SIZE;
     20e:	81 8d       	ldd	r24, Z+25	; 0x19
     210:	8f 5f       	subi	r24, 0xFF	; 255
     212:	8f 73       	andi	r24, 0x3F	; 63
     214:	81 8f       	std	Z+25, r24	; 0x19
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:112

  // clear the TXCIF flag -- "can be cleared by writing a one to its bit
  // location". This makes sure flush() won't return until the bytes
  // actually got written
  (*_hwserial_module).STATUS = USART_TXCIF_bm;
     216:	80 e4       	ldi	r24, 0x40	; 64
     218:	8c 83       	std	Y+4, r24	; 0x04
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:114

  (*_hwserial_module).TXDATAL = c;
     21a:	a4 85       	ldd	r26, Z+12	; 0x0c
     21c:	b5 85       	ldd	r27, Z+13	; 0x0d
     21e:	12 96       	adiw	r26, 0x02	; 2
     220:	9c 93       	st	X, r25
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:116

  if (_tx_buffer_head == _tx_buffer_tail) {
     222:	90 8d       	ldd	r25, Z+24	; 0x18
     224:	81 8d       	ldd	r24, Z+25	; 0x19
     226:	98 13       	cpse	r25, r24
     228:	e8 cf       	rjmp	.-48     	; 0x1fa <UartClass::_tx_data_empty_irq()+0x18>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:118
    // Buffer empty, so disable "data register empty" interrupt
    (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
     22a:	04 84       	ldd	r0, Z+12	; 0x0c
     22c:	f5 85       	ldd	r31, Z+13	; 0x0d
     22e:	e0 2d       	mov	r30, r0
     230:	85 81       	ldd	r24, Z+5	; 0x05
     232:	8f 7d       	andi	r24, 0xDF	; 223
     234:	85 83       	std	Z+5, r24	; 0x05
     236:	e1 cf       	rjmp	.-62     	; 0x1fa <UartClass::_tx_data_empty_irq()+0x18>

00000238 <UartClass::_poll_tx_data_empty()>:
_ZN9UartClass19_poll_tx_data_emptyEv():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:123
  }
}

// To invoke data empty "interrupt" via a call, use this method
void UartClass::_poll_tx_data_empty(void) {
     238:	dc 01       	movw	r26, r24
     23a:	1c 96       	adiw	r26, 0x0c	; 12
     23c:	ed 91       	ld	r30, X+
     23e:	fc 91       	ld	r31, X
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:124
  if ((!(SREG & CPU_I_bm)) || (!((*_hwserial_module).CTRLA & USART_DREIE_bm)) || CPUINT.STATUS) {
     240:	0f b6       	in	r0, 0x3f	; 63
     242:	07 fe       	sbrs	r0, 7
     244:	07 c0       	rjmp	.+14     	; 0x254 <UartClass::_poll_tx_data_empty()+0x1c>
     246:	25 81       	ldd	r18, Z+5	; 0x05
     248:	25 ff       	sbrs	r18, 5
     24a:	04 c0       	rjmp	.+8      	; 0x254 <UartClass::_poll_tx_data_empty()+0x1c>
     24c:	20 91 11 01 	lds	r18, 0x0111	; 0x800111 <vtable for CmdBuffer<32u>+0x7f6333>
     250:	22 23       	and	r18, r18
     252:	21 f0       	breq	.+8      	; 0x25c <UartClass::_poll_tx_data_empty()+0x24>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:137
    // so we'll have to poll the "data register empty" flag ourselves.
    // If it is set, pretend an interrupt has happened and call the handler
    // to free up space for us.

    // Invoke interrupt handler only if conditions data register is empty
    if ((*_hwserial_module).STATUS & USART_DREIF_bm) {
     254:	24 81       	ldd	r18, Z+4	; 0x04
     256:	25 fd       	sbrc	r18, 5
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:138
      _tx_data_empty_irq();
     258:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <UartClass::_tx_data_empty_irq()>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:142
    }
  }
  // In case interrupts are enabled, the interrupt routine will be invoked by itself
}
     25c:	08 95       	ret

0000025e <UartClass::write(unsigned char)>:
_ZN9UartClass5writeEh():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:361
  }
  // When we get here, nothing is queued anymore (DREIE is disabled) and
  // the hardware finished transmission (TXCIF is set).
}

size_t UartClass::write(uint8_t c) {
     25e:	0f 93       	push	r16
     260:	1f 93       	push	r17
     262:	cf 93       	push	r28
     264:	df 93       	push	r29
     266:	ec 01       	movw	r28, r24
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:362
  _written = true;
     268:	81 e0       	ldi	r24, 0x01	; 1
     26a:	8d 8b       	std	Y+21, r24	; 0x15
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:368

  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective data rate at high (>
  // 500kbit/s) bit rates, where interrupt overhead becomes a slowdown.
  if ((_tx_buffer_head == _tx_buffer_tail) && ((*_hwserial_module).STATUS & USART_DREIF_bm)) {
     26c:	98 8d       	ldd	r25, Y+24	; 0x18
     26e:	89 8d       	ldd	r24, Y+25	; 0x19
     270:	98 13       	cpse	r25, r24
     272:	16 c0       	rjmp	.+44     	; 0x2a0 <UartClass::write(unsigned char)+0x42>
     274:	ec 85       	ldd	r30, Y+12	; 0x0c
     276:	fd 85       	ldd	r31, Y+13	; 0x0d
     278:	84 81       	ldd	r24, Z+4	; 0x04
     27a:	85 ff       	sbrs	r24, 5
     27c:	11 c0       	rjmp	.+34     	; 0x2a0 <UartClass::write(unsigned char)+0x42>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:369
    (*_hwserial_module).TXDATAL = c;
     27e:	62 83       	std	Z+2, r22	; 0x02
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:370
    (*_hwserial_module).STATUS = USART_TXCIF_bm;
     280:	ec 85       	ldd	r30, Y+12	; 0x0c
     282:	fd 85       	ldd	r31, Y+13	; 0x0d
     284:	80 e4       	ldi	r24, 0x40	; 64
     286:	84 83       	std	Z+4, r24	; 0x04
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:374

    // Make sure data register empty interrupt is disabled to avoid
    // that the interrupt handler is called in this situation
    (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
     288:	ec 85       	ldd	r30, Y+12	; 0x0c
     28a:	fd 85       	ldd	r31, Y+13	; 0x0d
     28c:	85 81       	ldd	r24, Z+5	; 0x05
     28e:	8f 7d       	andi	r24, 0xDF	; 223
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:391

  _tx_buffer[_tx_buffer_head] = c;
  _tx_buffer_head = i;

  // Enable data "register empty interrupt"
  (*_hwserial_module).CTRLA |= USART_DREIE_bm;
     290:	85 83       	std	Z+5, r24	; 0x05
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:394

  return 1;
}
     292:	81 e0       	ldi	r24, 0x01	; 1
     294:	90 e0       	ldi	r25, 0x00	; 0
     296:	df 91       	pop	r29
     298:	cf 91       	pop	r28
     29a:	1f 91       	pop	r17
     29c:	0f 91       	pop	r16
     29e:	08 95       	ret
     2a0:	06 2f       	mov	r16, r22
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:379
    (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);

    return 1;
  }

  tx_buffer_index_t i = (_tx_buffer_head + 1) & (SERIAL_TX_BUFFER_SIZE-1); // % SERIAL_TX_BUFFER_SIZE;
     2a2:	18 8d       	ldd	r17, Y+24	; 0x18
     2a4:	1f 5f       	subi	r17, 0xFF	; 255
     2a6:	1f 73       	andi	r17, 0x3F	; 63
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:383

  //If the output buffer is full, there's nothing for it other than to
  //wait for the interrupt handler to empty it a bit (or emulate interrupts)
  while (i == _tx_buffer_tail) {
     2a8:	89 8d       	ldd	r24, Y+25	; 0x19
     2aa:	81 13       	cpse	r24, r17
     2ac:	04 c0       	rjmp	.+8      	; 0x2b6 <UartClass::write(unsigned char)+0x58>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:384
    _poll_tx_data_empty();
     2ae:	ce 01       	movw	r24, r28
     2b0:	0e 94 1c 01 	call	0x238	; 0x238 <UartClass::_poll_tx_data_empty()>
     2b4:	f9 cf       	rjmp	.-14     	; 0x2a8 <UartClass::write(unsigned char)+0x4a>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:387
  }

  _tx_buffer[_tx_buffer_head] = c;
     2b6:	e8 8d       	ldd	r30, Y+24	; 0x18
     2b8:	ec 0f       	add	r30, r28
     2ba:	fd 2f       	mov	r31, r29
     2bc:	f1 1d       	adc	r31, r1
     2be:	e5 5a       	subi	r30, 0xA5	; 165
     2c0:	ff 4f       	sbci	r31, 0xFF	; 255
     2c2:	00 83       	st	Z, r16
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:388
  _tx_buffer_head = i;
     2c4:	18 8f       	std	Y+24, r17	; 0x18
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:391

  // Enable data "register empty interrupt"
  (*_hwserial_module).CTRLA |= USART_DREIE_bm;
     2c6:	ec 85       	ldd	r30, Y+12	; 0x0c
     2c8:	fd 85       	ldd	r31, Y+13	; 0x0d
     2ca:	85 81       	ldd	r24, Z+5	; 0x05
     2cc:	80 62       	ori	r24, 0x20	; 32
     2ce:	e0 cf       	rjmp	.-64     	; 0x290 <UartClass::write(unsigned char)+0x32>

000002d0 <Print::print(char) [clone .constprop.43]>:
_ZN5Print5printEc.constprop.43():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:71
size_t Print::print(const char str[]) {
  return write(str);
}

size_t Print::print(char c) {
  return write(c);
     2d0:	68 2f       	mov	r22, r24
     2d2:	8b e8       	ldi	r24, 0x8B	; 139
     2d4:	99 e3       	ldi	r25, 0x39	; 57
     2d6:	0c 94 2f 01 	jmp	0x25e	; 0x25e <UartClass::write(unsigned char)>

000002da <UartClass::flush()>:
_ZN9UartClass5flushEv():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:332
    return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  }
  return tail - head - 1;
}

void UartClass::flush() {
     2da:	cf 93       	push	r28
     2dc:	df 93       	push	r29
     2de:	ec 01       	movw	r28, r24
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:336
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXCIF (transmit
  // complete) bit to 1 during initialization
  if (!_written) {
     2e0:	8d 89       	ldd	r24, Y+21	; 0x15
     2e2:	88 23       	and	r24, r24
     2e4:	61 f0       	breq	.+24     	; 0x2fe <UartClass::flush()+0x24>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:351
  // it's appropriate to use for applications where it has only very small benefits, and significant risk of surprising the user and causing
  // breakage of code that would otherwise work. Finally, the previous implementation didn't check if it was called from the current lvl1 ISR
  // and in that case flush(), and write() with full buffer would just straight up hang...

  // Spin until the data-register-empty-interrupt is disabled and TX complete interrupt flag is raised
  while (((*_hwserial_module).CTRLA & USART_DREIE_bm) || (!((*_hwserial_module).STATUS & USART_TXCIF_bm))) {
     2e6:	ec 85       	ldd	r30, Y+12	; 0x0c
     2e8:	fd 85       	ldd	r31, Y+13	; 0x0d
     2ea:	85 81       	ldd	r24, Z+5	; 0x05
     2ec:	85 fd       	sbrc	r24, 5
     2ee:	03 c0       	rjmp	.+6      	; 0x2f6 <UartClass::flush()+0x1c>
     2f0:	84 81       	ldd	r24, Z+4	; 0x04
     2f2:	86 fd       	sbrc	r24, 6
     2f4:	04 c0       	rjmp	.+8      	; 0x2fe <UartClass::flush()+0x24>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:355

    // If interrupts are globally disabled or the and DR empty interrupt is disabled,
    // poll the "data register empty" interrupt flag to prevent deadlock
    _poll_tx_data_empty();
     2f6:	ce 01       	movw	r24, r28
     2f8:	0e 94 1c 01 	call	0x238	; 0x238 <UartClass::_poll_tx_data_empty()>
     2fc:	f4 cf       	rjmp	.-24     	; 0x2e6 <UartClass::flush()+0xc>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:359
  }
  // When we get here, nothing is queued anymore (DREIE is disabled) and
  // the hardware finished transmission (TXCIF is set).
}
     2fe:	df 91       	pop	r29
     300:	cf 91       	pop	r28
     302:	08 95       	ret

00000304 <UartClass::operator bool()>:
_ZN9UartClasscvbEv():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.h:223
      return write((uint8_t)n);
    }
    using Print::write; // pull in write(str) and write(buf, size) from Print
    explicit operator bool() {
      return true;
    }
     304:	81 e0       	ldi	r24, 0x01	; 1
     306:	08 95       	ret

00000308 <millis>:
millis():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:184
  //return timer_overflow_count; //for debugging timekeeping issues where these variables are out of scope from the sketch
  unsigned long m;

  // disable interrupts while we read timer0_millis or we might get an
  // inconsistent value (e.g. in the middle of a write to timer0_millis)
  uint8_t status = SREG;
     308:	2f b7       	in	r18, 0x3f	; 63
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:185
  cli();
     30a:	f8 94       	cli
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:197
  m = (m << 16);
  m += RTC.CNT;
  //now correct for there being 1000ms to the second instead of 1024
  m = m - (m >> 6) - (m >> 7);
  #else
  m = timer_millis;
     30c:	60 91 42 38 	lds	r22, 0x3842	; 0x803842 <timer_millis>
     310:	70 91 43 38 	lds	r23, 0x3843	; 0x803843 <timer_millis+0x1>
     314:	80 91 44 38 	lds	r24, 0x3844	; 0x803844 <timer_millis+0x2>
     318:	90 91 45 38 	lds	r25, 0x3845	; 0x803845 <timer_millis+0x3>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:198
  SREG = status;
     31c:	2f bf       	out	0x3f, r18	; 63
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:201
  #endif
  return m;
}
     31e:	08 95       	ret

00000320 <TWI_SlaveTransactionFinished>:
TWI_SlaveTransactionFinished():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:808
    Prepares module for new transaction.

    \param result  The result of the operation.
*/
void TWI_SlaveTransactionFinished(uint8_t result) {
  TWI0.SCTRLA |= (TWI_APIEN_bm | TWI_PIEN_bm);
     320:	e0 e1       	ldi	r30, 0x10	; 16
     322:	f8 e0       	ldi	r31, 0x08	; 8
     324:	91 85       	ldd	r25, Z+9	; 0x09
     326:	90 66       	ori	r25, 0x60	; 96
     328:	91 87       	std	Z+9, r25	; 0x09
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:809
  twi_mode = TWI_MODE_SLAVE;
     32a:	92 e0       	ldi	r25, 0x02	; 2
     32c:	90 93 4a 38 	sts	0x384A, r25	; 0x80384a <twi_mode>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:810
  slave_result = result;
     330:	80 93 30 38 	sts	0x3830, r24	; 0x803830 <slave_result>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:811
  slave_trans_status = TWIM_STATUS_READY;
     334:	10 92 2f 38 	sts	0x382F, r1	; 0x80382f <slave_trans_status>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:812
}
     338:	08 95       	ret

0000033a <TWI_SlaveAddressMatchHandler>:
TWI_SlaveAddressMatchHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:653
    This is the slave address match handler that takes care of responding to
    being addressed by a master

*/
void TWI_SlaveAddressMatchHandler() {
  slave_trans_status = TWIS_STATUS_BUSY;
     33a:	81 e0       	ldi	r24, 0x01	; 1
     33c:	80 93 2f 38 	sts	0x382F, r24	; 0x80382f <slave_trans_status>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:654
  slave_result = TWIS_RESULT_UNKNOWN;
     340:	10 92 30 38 	sts	0x3830, r1	; 0x803830 <slave_result>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:657

  /* If Master Read/Slave Write */
  if (TWI0.SSTATUS & TWI_DIR_bm) {
     344:	90 91 1b 08 	lds	r25, 0x081B	; 0x80081b <vtable for CmdBuffer<32u>+0x7f6a3d>
     348:	91 ff       	sbrs	r25, 1
     34a:	0e c0       	rjmp	.+28     	; 0x368 <TWI_SlaveAddressMatchHandler+0x2e>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:658
    slave_bytesWritten = 0;
     34c:	10 92 3a 38 	sts	0x383A, r1	; 0x80383a <slave_bytesWritten>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:660
    /* Call user function  */
    slave_bytesToWrite = TWI_onSlaveTransmit();
     350:	f0 e0       	ldi	r31, 0x00	; 0
     352:	e0 e0       	ldi	r30, 0x00	; 0
     354:	09 95       	icall
     356:	80 93 39 38 	sts	0x3839, r24	; 0x803839 <slave_bytesToWrite>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:661
    twi_mode = TWI_MODE_SLAVE_TRANSMIT;
     35a:	85 e0       	ldi	r24, 0x05	; 5
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:667
  }
  /* If Master Write/Slave Read */
  else {
    slave_bytesRead = 0;
    slave_callUserReceive = 1;
    twi_mode = TWI_MODE_SLAVE_RECEIVE;
     35c:	80 93 4a 38 	sts	0x384A, r24	; 0x80384a <twi_mode>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:671
  }

  /* Send ACK, wait for data interrupt */
  TWI0.SCTRLB = TWI_SCMD_RESPONSE_gc;
     360:	83 e0       	ldi	r24, 0x03	; 3
     362:	80 93 1a 08 	sts	0x081A, r24	; 0x80081a <vtable for CmdBuffer<32u>+0x7f6a3c>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:674

  /* Data interrupt to follow... */
}
     366:	08 95       	ret
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:665
    slave_bytesToWrite = TWI_onSlaveTransmit();
    twi_mode = TWI_MODE_SLAVE_TRANSMIT;
  }
  /* If Master Write/Slave Read */
  else {
    slave_bytesRead = 0;
     368:	10 92 3b 38 	sts	0x383B, r1	; 0x80383b <slave_bytesRead>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:666
    slave_callUserReceive = 1;
     36c:	80 93 38 38 	sts	0x3838, r24	; 0x803838 <slave_callUserReceive>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:667
    twi_mode = TWI_MODE_SLAVE_RECEIVE;
     370:	86 e0       	ldi	r24, 0x06	; 6
     372:	f4 cf       	rjmp	.-24     	; 0x35c <TWI_SlaveAddressMatchHandler+0x22>

00000374 <TWI_MasterWriteRead>:
TWI_MasterWriteRead():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:324
*/
uint8_t TWI_MasterWriteRead(uint8_t slave_address,
                            uint8_t *write_data,
                            uint8_t bytes_to_write,
                            uint8_t bytes_to_read,
                            uint8_t send_stop) {
     374:	0f 93       	push	r16
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:325
  if (twi_mode != TWI_MODE_MASTER) {
     376:	90 91 4a 38 	lds	r25, 0x384A	; 0x80384a <twi_mode>
     37a:	91 30       	cpi	r25, 0x01	; 1
     37c:	09 f0       	breq	.+2      	; 0x380 <TWI_MasterWriteRead+0xc>
     37e:	51 c0       	rjmp	.+162    	; 0x422 <__LOCK_REGION_LENGTH__+0x22>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:330
    return false;
  }

  /*Initiate transaction if bus is ready. */
  if (master_trans_status == TWIM_STATUS_READY) {
     380:	30 91 47 38 	lds	r19, 0x3847	; 0x803847 <master_trans_status>
     384:	31 11       	cpse	r19, r1
     386:	53 c0       	rjmp	.+166    	; 0x42e <__LOCK_REGION_LENGTH__+0x2e>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:332

    master_trans_status = TWIM_STATUS_BUSY;
     388:	90 93 47 38 	sts	0x3847, r25	; 0x803847 <master_trans_status>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:333
    master_result = TWIM_RESULT_UNKNOWN;
     38c:	10 92 46 38 	sts	0x3846, r1	; 0x803846 <master_result>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:335

    master_writeData = write_data;
     390:	60 93 32 38 	sts	0x3832, r22	; 0x803832 <master_writeData>
     394:	70 93 33 38 	sts	0x3833, r23	; 0x803833 <master_writeData+0x1>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:337

    master_bytesToWrite = bytes_to_write;
     398:	40 93 34 38 	sts	0x3834, r20	; 0x803834 <master_bytesToWrite>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:338
    master_bytesToRead = bytes_to_read;
     39c:	20 93 36 38 	sts	0x3836, r18	; 0x803836 <master_bytesToRead>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:339
    master_bytesWritten = 0;
     3a0:	10 92 48 38 	sts	0x3848, r1	; 0x803848 <master_bytesWritten>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:340
    master_bytesRead = 0;
     3a4:	10 92 49 38 	sts	0x3849, r1	; 0x803849 <master_bytesRead>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:341
    master_sendStop = send_stop;
     3a8:	00 93 35 38 	sts	0x3835, r16	; 0x803835 <master_sendStop>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:342
    master_slaveAddress = slave_address << 1;
     3ac:	88 0f       	add	r24, r24
     3ae:	80 93 31 38 	sts	0x3831, r24	; 0x803831 <master_slaveAddress>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:365
      uint8_t readAddress = ADD_READ_BIT(master_slaveAddress);
      TWI0.MADDR = readAddress;
    }

    else if (master_bytesToWrite == 0 && master_bytesToRead == 0) {
      twi_mode = TWI_MODE_MASTER_TRANSMIT;
     3b2:	93 e0       	ldi	r25, 0x03	; 3
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:359

    /* If read command, send the START condition + Address +
       'R/_W = 1'
    */
    else if (master_bytesToRead > 0) {
      twi_mode = TWI_MODE_MASTER_RECEIVE;
     3b4:	24 e0       	ldi	r18, 0x04	; 4
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:349
  trigger_action:

    /* If write command, send the START condition + Address +
       'R/_W = 0'
    */
    if (master_bytesToWrite > 0) {
     3b6:	80 91 34 38 	lds	r24, 0x3834	; 0x803834 <master_bytesToWrite>
     3ba:	88 23       	and	r24, r24
     3bc:	31 f0       	breq	.+12     	; 0x3ca <TWI_MasterWriteRead+0x56>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:365
      uint8_t readAddress = ADD_READ_BIT(master_slaveAddress);
      TWI0.MADDR = readAddress;
    }

    else if (master_bytesToWrite == 0 && master_bytesToRead == 0) {
      twi_mode = TWI_MODE_MASTER_TRANSMIT;
     3be:	90 93 4a 38 	sts	0x384A, r25	; 0x80384a <twi_mode>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:366
      uint8_t writeAddress = ADD_WRITE_BIT(master_slaveAddress);
     3c2:	80 91 31 38 	lds	r24, 0x3831	; 0x803831 <master_slaveAddress>
     3c6:	8e 7f       	andi	r24, 0xFE	; 254
     3c8:	09 c0       	rjmp	.+18     	; 0x3dc <TWI_MasterWriteRead+0x68>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:358
    }

    /* If read command, send the START condition + Address +
       'R/_W = 1'
    */
    else if (master_bytesToRead > 0) {
     3ca:	80 91 36 38 	lds	r24, 0x3836	; 0x803836 <master_bytesToRead>
     3ce:	88 23       	and	r24, r24
     3d0:	41 f0       	breq	.+16     	; 0x3e2 <TWI_MasterWriteRead+0x6e>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:359
      twi_mode = TWI_MODE_MASTER_RECEIVE;
     3d2:	20 93 4a 38 	sts	0x384A, r18	; 0x80384a <twi_mode>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:360
      uint8_t readAddress = ADD_READ_BIT(master_slaveAddress);
     3d6:	80 91 31 38 	lds	r24, 0x3831	; 0x803831 <master_slaveAddress>
     3da:	81 60       	ori	r24, 0x01	; 1
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:367
    }

    else if (master_bytesToWrite == 0 && master_bytesToRead == 0) {
      twi_mode = TWI_MODE_MASTER_TRANSMIT;
      uint8_t writeAddress = ADD_WRITE_BIT(master_slaveAddress);
      TWI0.MADDR = writeAddress;
     3dc:	80 93 17 08 	sts	0x0817, r24	; 0x800817 <vtable for CmdBuffer<32u>+0x7f6a39>
     3e0:	08 c0       	rjmp	.+16     	; 0x3f2 <TWI_MasterWriteRead+0x7e>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:364
      twi_mode = TWI_MODE_MASTER_RECEIVE;
      uint8_t readAddress = ADD_READ_BIT(master_slaveAddress);
      TWI0.MADDR = readAddress;
    }

    else if (master_bytesToWrite == 0 && master_bytesToRead == 0) {
     3e2:	80 91 34 38 	lds	r24, 0x3834	; 0x803834 <master_bytesToWrite>
     3e6:	81 11       	cpse	r24, r1
     3e8:	04 c0       	rjmp	.+8      	; 0x3f2 <TWI_MasterWriteRead+0x7e>
     3ea:	80 91 36 38 	lds	r24, 0x3836	; 0x803836 <master_bytesToRead>
     3ee:	88 23       	and	r24, r24
     3f0:	31 f3       	breq	.-52     	; 0x3be <TWI_MasterWriteRead+0x4a>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:371
      uint8_t writeAddress = ADD_WRITE_BIT(master_slaveAddress);
      TWI0.MADDR = writeAddress;
    }

    /* Arduino requires blocking function */
    while (master_result == TWIM_RESULT_UNKNOWN) {}
     3f2:	80 91 46 38 	lds	r24, 0x3846	; 0x803846 <master_result>
     3f6:	88 23       	and	r24, r24
     3f8:	e1 f3       	breq	.-8      	; 0x3f2 <TWI_MasterWriteRead+0x7e>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:374

    // in case of arbitration lost, retry sending
    if (master_result == TWIM_RESULT_ARBITRATION_LOST) {
     3fa:	80 91 46 38 	lds	r24, 0x3846	; 0x803846 <master_result>
     3fe:	83 30       	cpi	r24, 0x03	; 3
     400:	d1 f2       	breq	.-76     	; 0x3b6 <TWI_MasterWriteRead+0x42>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:379
      goto trigger_action;
    }

    uint8_t ret = 0;
    if (master_bytesToRead > 0) {
     402:	80 91 36 38 	lds	r24, 0x3836	; 0x803836 <master_bytesToRead>
     406:	88 23       	and	r24, r24
     408:	21 f0       	breq	.+8      	; 0x412 <__LOCK_REGION_LENGTH__+0x12>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:381
      // return bytes really read
      ret = master_bytesRead;
     40a:	80 91 49 38 	lds	r24, 0x3849	; 0x803849 <master_bytesRead>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:404

    return ret;
  } else {
    return 1;
  }
}
     40e:	0f 91       	pop	r16
     410:	08 95       	ret
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:384
    if (master_bytesToRead > 0) {
      // return bytes really read
      ret = master_bytesRead;
    } else {
      // return 0 if success, >0 otherwise (follow classic AVR conventions)
      switch (master_result) {
     412:	80 91 46 38 	lds	r24, 0x3846	; 0x803846 <master_result>
     416:	82 30       	cpi	r24, 0x02	; 2
     418:	51 f0       	breq	.+20     	; 0x42e <__LOCK_REGION_LENGTH__+0x2e>
     41a:	85 30       	cpi	r24, 0x05	; 5
     41c:	21 f0       	breq	.+8      	; 0x426 <__LOCK_REGION_LENGTH__+0x26>
     41e:	81 30       	cpi	r24, 0x01	; 1
     420:	21 f4       	brne	.+8      	; 0x42a <__LOCK_REGION_LENGTH__+0x2a>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:386
        case TWIM_RESULT_OK:
          ret = 0;
     422:	80 e0       	ldi	r24, 0x00	; 0
     424:	f4 cf       	rjmp	.-24     	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:392
          break;
        case TWIM_RESULT_BUFFER_OVERFLOW:
          ret = 1;
          break;
        case TWIM_RESULT_NACK_RECEIVED:
          ret = 3;
     426:	83 e0       	ldi	r24, 0x03	; 3
     428:	f2 cf       	rjmp	.-28     	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:395
          break;
        default:
          ret = 4;
     42a:	84 e0       	ldi	r24, 0x04	; 4
     42c:	f0 cf       	rjmp	.-32     	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:402
      }
    }

    return ret;
  } else {
    return 1;
     42e:	81 e0       	ldi	r24, 0x01	; 1
     430:	ee cf       	rjmp	.-36     	; 0x40e <__LOCK_REGION_LENGTH__+0xe>

00000432 <TwoWire::endTransmission(bool) [clone .constprop.47]>:
_ZN7TwoWire15endTransmissionEb.constprop.47():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:279
//  the bus tenure has been properly ended with a STOP. It
//  is very possible to leave the bus in a hung state if
//  no call to endTransmission(true) is made. Some I2C
//  devices will behave oddly if they do not see a STOP.
//
uint8_t TwoWire::endTransmission(bool sendStop) {
     432:	0f 93       	push	r16
TWI_MasterWrite():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:271
*/
uint8_t TWI_MasterWrite(uint8_t slave_address,
                        uint8_t *write_data,
                        uint8_t bytes_to_write,
                        uint8_t send_stop) {
  return TWI_MasterWriteRead(slave_address,
     434:	00 e0       	ldi	r16, 0x00	; 0
     436:	20 e0       	ldi	r18, 0x00	; 0
     438:	40 91 8a 39 	lds	r20, 0x398A	; 0x80398a <TwoWire::txBufferLength>
     43c:	69 e6       	ldi	r22, 0x69	; 105
     43e:	79 e3       	ldi	r23, 0x39	; 57
     440:	80 91 89 39 	lds	r24, 0x3989	; 0x803989 <TwoWire::txAddress>
     444:	0e 94 ba 01 	call	0x374	; 0x374 <TWI_MasterWriteRead>
_ZN7TwoWire15endTransmissionEb.constprop.47():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:284
  // transmit buffer (blocking)
  uint8_t status = TWI_MasterWrite(txAddress, txBuffer, txBufferLength, sendStop);

  // reset tx buffer iterator vars
  txBufferIndex = 0;
     448:	10 92 68 39 	sts	0x3968, r1	; 0x803968 <TwoWire::txBufferIndex>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:285
  txBufferLength = 0;
     44c:	10 92 8a 39 	sts	0x398A, r1	; 0x80398a <TwoWire::txBufferLength>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:291

  // indicate that we are done transmitting
  transmitting = 0;

  return status;
}
     450:	0f 91       	pop	r16
     452:	08 95       	ret

00000454 <TwoWire::flush()>:
_ZN7TwoWire5flushEv():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:385
  //  rxBufferIndex = 0;
  //  rxBufferLength = 0;
  //
  //  /* Turn off and on TWI module */
  //  TWI_Flush();
}
     454:	08 95       	ret

00000456 <TwoWire::peek()>:
_ZN7TwoWire4peekEv():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:361
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::peek(void) {
  int value = -1;

  if (rxBufferIndex < rxBufferLength) {
     456:	e0 91 4e 38 	lds	r30, 0x384E	; 0x80384e <TwoWire::rxBufferIndex>
     45a:	80 91 4d 38 	lds	r24, 0x384D	; 0x80384d <TwoWire::rxBufferLength>
     45e:	e8 17       	cp	r30, r24
     460:	30 f4       	brcc	.+12     	; 0x46e <TwoWire::peek()+0x18>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:362
    value = rxBuffer[rxBufferIndex];
     462:	f0 e0       	ldi	r31, 0x00	; 0
     464:	e1 5b       	subi	r30, 0xB1	; 177
     466:	f7 4c       	sbci	r31, 0xC7	; 199
     468:	80 81       	ld	r24, Z
     46a:	90 e0       	ldi	r25, 0x00	; 0
     46c:	08 95       	ret
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:359

// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::peek(void) {
  int value = -1;
     46e:	8f ef       	ldi	r24, 0xFF	; 255
     470:	9f ef       	ldi	r25, 0xFF	; 255
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:366
  if (rxBufferIndex < rxBufferLength) {
    value = rxBuffer[rxBufferIndex];
  }

  return value;
}
     472:	08 95       	ret

00000474 <TwoWire::read()>:
_ZN7TwoWire4readEv():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:347
// or after requestFrom(address, numBytes)
int TwoWire::read(void) {
  int value = -1;

  // get each successive byte on each call
  if (rxBufferIndex < rxBufferLength) {
     474:	90 91 4e 38 	lds	r25, 0x384E	; 0x80384e <TwoWire::rxBufferIndex>
     478:	80 91 4d 38 	lds	r24, 0x384D	; 0x80384d <TwoWire::rxBufferLength>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:344

// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void) {
  int value = -1;
     47c:	2f ef       	ldi	r18, 0xFF	; 255
     47e:	3f ef       	ldi	r19, 0xFF	; 255
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:347

  // get each successive byte on each call
  if (rxBufferIndex < rxBufferLength) {
     480:	98 17       	cp	r25, r24
     482:	48 f4       	brcc	.+18     	; 0x496 <TwoWire::read()+0x22>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:348
    value = rxBuffer[rxBufferIndex];
     484:	e9 2f       	mov	r30, r25
     486:	f0 e0       	ldi	r31, 0x00	; 0
     488:	e1 5b       	subi	r30, 0xB1	; 177
     48a:	f7 4c       	sbci	r31, 0xC7	; 199
     48c:	20 81       	ld	r18, Z
     48e:	30 e0       	ldi	r19, 0x00	; 0
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:349
    rxBufferIndex++;
     490:	9f 5f       	subi	r25, 0xFF	; 255
     492:	90 93 4e 38 	sts	0x384E, r25	; 0x80384e <TwoWire::rxBufferIndex>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:353
  }

  return value;
}
     496:	c9 01       	movw	r24, r18
     498:	08 95       	ret

0000049a <TwoWire::available()>:
_ZN7TwoWire9availableEv():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:337

// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void) {
  return rxBufferLength - rxBufferIndex;
     49a:	80 91 4d 38 	lds	r24, 0x384D	; 0x80384d <TwoWire::rxBufferLength>
     49e:	90 91 4e 38 	lds	r25, 0x384E	; 0x80384e <TwoWire::rxBufferIndex>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:338
}
     4a2:	89 1b       	sub	r24, r25
     4a4:	99 0b       	sbc	r25, r25
     4a6:	08 95       	ret

000004a8 <TwoWire::write(unsigned char const*, unsigned int)>:
_ZN7TwoWire5writeEPKhj():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:323
}

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity) {
     4a8:	cf 92       	push	r12
     4aa:	df 92       	push	r13
     4ac:	ef 92       	push	r14
     4ae:	ff 92       	push	r15
     4b0:	0f 93       	push	r16
     4b2:	1f 93       	push	r17
     4b4:	cf 93       	push	r28
     4b6:	df 93       	push	r29
     4b8:	7c 01       	movw	r14, r24
     4ba:	8a 01       	movw	r16, r20
     4bc:	eb 01       	movw	r28, r22
     4be:	6b 01       	movw	r12, r22
     4c0:	c4 0e       	add	r12, r20
     4c2:	d5 1e       	adc	r13, r21
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:325

  for (size_t i = 0; i < quantity; i++) {
     4c4:	cc 15       	cp	r28, r12
     4c6:	dd 05       	cpc	r29, r13
     4c8:	51 f0       	breq	.+20     	; 0x4de <TwoWire::write(unsigned char const*, unsigned int)+0x36>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:326
    write(*(data + i));
     4ca:	69 91       	ld	r22, Y+
     4cc:	d7 01       	movw	r26, r14
     4ce:	ed 91       	ld	r30, X+
     4d0:	fc 91       	ld	r31, X
     4d2:	01 90       	ld	r0, Z+
     4d4:	f0 81       	ld	r31, Z
     4d6:	e0 2d       	mov	r30, r0
     4d8:	c7 01       	movw	r24, r14
     4da:	09 95       	icall
     4dc:	f3 cf       	rjmp	.-26     	; 0x4c4 <TwoWire::write(unsigned char const*, unsigned int)+0x1c>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:330
  }

  return quantity;
}
     4de:	c8 01       	movw	r24, r16
     4e0:	df 91       	pop	r29
     4e2:	cf 91       	pop	r28
     4e4:	1f 91       	pop	r17
     4e6:	0f 91       	pop	r16
     4e8:	ff 90       	pop	r15
     4ea:	ef 90       	pop	r14
     4ec:	df 90       	pop	r13
     4ee:	cf 90       	pop	r12
     4f0:	08 95       	ret

000004f2 <TwoWire::write(unsigned char)>:
_ZN7TwoWire5writeEh():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:305
// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data) {
  /* Check if buffer is full */
  if (txBufferLength >= BUFFER_LENGTH) {
     4f2:	20 91 8a 39 	lds	r18, 0x398A	; 0x80398a <TwoWire::txBufferLength>
     4f6:	20 32       	cpi	r18, 0x20	; 32
     4f8:	40 f0       	brcs	.+16     	; 0x50a <TwoWire::write(unsigned char)+0x18>
_ZN5Print13setWriteErrorEi():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.h:39
    int write_error;
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) {
      write_error = err;
     4fa:	21 e0       	ldi	r18, 0x01	; 1
     4fc:	30 e0       	ldi	r19, 0x00	; 0
     4fe:	fc 01       	movw	r30, r24
     500:	22 83       	std	Z+2, r18	; 0x02
     502:	33 83       	std	Z+3, r19	; 0x03
_ZN7TwoWire5writeEh():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:307
    setWriteError();
    return 0;
     504:	90 e0       	ldi	r25, 0x00	; 0
     506:	80 e0       	ldi	r24, 0x00	; 0
     508:	08 95       	ret
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:311
  }

  /* Put byte in txBuffer */
  txBuffer[txBufferIndex] = data;
     50a:	80 91 68 39 	lds	r24, 0x3968	; 0x803968 <TwoWire::txBufferIndex>
     50e:	e8 2f       	mov	r30, r24
     510:	f0 e0       	ldi	r31, 0x00	; 0
     512:	e7 59       	subi	r30, 0x97	; 151
     514:	f6 4c       	sbci	r31, 0xC6	; 198
     516:	60 83       	st	Z, r22
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:312
  txBufferIndex++;
     518:	8f 5f       	subi	r24, 0xFF	; 255
     51a:	80 93 68 39 	sts	0x3968, r24	; 0x803968 <TwoWire::txBufferIndex>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:315

  /* Update buffer length */
  txBufferLength = txBufferIndex;
     51e:	80 93 8a 39 	sts	0x398A, r24	; 0x80398a <TwoWire::txBufferLength>
     522:	81 e0       	ldi	r24, 0x01	; 1
     524:	90 e0       	ldi	r25, 0x00	; 0
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:318

  return 1;
}
     526:	08 95       	ret

00000528 <TwoWire::write(int) [clone .constprop.58]>:
_ZN7TwoWire5writeEi.constprop.58():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.h:96
    void onRequest(void (*)(void));

    inline size_t write(unsigned long n) { return write((uint8_t)n); }
    inline size_t write(long n) { return write((uint8_t)n); }
    inline size_t write(unsigned int n) { return write((uint8_t)n); }
    inline size_t write(int n) { return write((uint8_t)n); }
     528:	68 2f       	mov	r22, r24
     52a:	86 e2       	ldi	r24, 0x26	; 38
     52c:	9a e3       	ldi	r25, 0x3A	; 58
     52e:	0c 94 79 02 	jmp	0x4f2	; 0x4f2 <TwoWire::write(unsigned char)>

00000532 <UartClass::begin(unsigned long)>:
_ZN9UartClass5beginEm():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.h:175
  public:
    inline UartClass(volatile USART_t *hwserial_module, uint8_t hwserial_rx_pin, uint8_t hwserial_tx_pin, uint8_t hwserial_rx_pin_swap, uint8_t hwserial_tx_pin_swap, uint8_t dre_vect_num, uint8_t uart_mux, uint8_t uart_mux_swap);
    bool pins(uint8_t tx, uint8_t rx);
    bool swap(uint8_t state = 1);
    void begin(unsigned long baud) {
      begin(baud, SERIAL_8N1);
     532:	dc 01       	movw	r26, r24
     534:	ed 91       	ld	r30, X+
     536:	fc 91       	ld	r31, X
     538:	06 84       	ldd	r0, Z+14	; 0x0e
     53a:	f7 85       	ldd	r31, Z+15	; 0x0f
     53c:	e0 2d       	mov	r30, r0
     53e:	23 e0       	ldi	r18, 0x03	; 3
     540:	30 e0       	ldi	r19, 0x00	; 0
     542:	09 94       	ijmp

00000544 <Print::write(char const*) [clone .part.2] [clone .constprop.57]>:
_ZN5Print5writeEPKc.part.2.constprop.57():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.h:56
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) {
        return 0;
      }
      return write((const uint8_t *)str, strlen(str));
     544:	fc 01       	movw	r30, r24
     546:	01 90       	ld	r0, Z+
     548:	00 20       	and	r0, r0
     54a:	e9 f7       	brne	.-6      	; 0x546 <Print::write(char const*) [clone .part.2] [clone .constprop.57]+0x2>
     54c:	31 97       	sbiw	r30, 0x01	; 1
     54e:	af 01       	movw	r20, r30
     550:	48 1b       	sub	r20, r24
     552:	59 0b       	sbc	r21, r25
     554:	bc 01       	movw	r22, r24
     556:	8b e8       	ldi	r24, 0x8B	; 139
     558:	99 e3       	ldi	r25, 0x39	; 57
     55a:	0c 94 6e 00 	jmp	0xdc	; 0xdc <Print::write(unsigned char const*, unsigned int)>

0000055e <Print::printNumber(unsigned long, unsigned char) [clone .constprop.54]>:
_ZN5Print11printNumberEmh.constprop.54():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:215
  return vfprintf_P(&f, (const char *)format, ap);
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base) {
     55e:	8f 92       	push	r8
     560:	9f 92       	push	r9
     562:	af 92       	push	r10
     564:	bf 92       	push	r11
     566:	0f 93       	push	r16
     568:	1f 93       	push	r17
     56a:	cf 93       	push	r28
     56c:	df 93       	push	r29
     56e:	cd b7       	in	r28, 0x3d	; 61
     570:	de b7       	in	r29, 0x3e	; 62
     572:	a1 97       	sbiw	r28, 0x21	; 33
     574:	cd bf       	out	0x3d, r28	; 61
     576:	de bf       	out	0x3e, r29	; 62
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:219
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
     578:	19 a2       	std	Y+33, r1	; 0x21
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:222

  // prevent crash if called with base == 1
  if (base < 2) {
     57a:	42 30       	cpi	r20, 0x02	; 2
     57c:	08 f4       	brcc	.+2      	; 0x580 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.54]+0x22>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:223
    base = 10;
     57e:	4a e0       	ldi	r20, 0x0A	; 10
     580:	8e 01       	movw	r16, r28
     582:	0f 5d       	subi	r16, 0xDF	; 223
     584:	1f 4f       	sbci	r17, 0xFF	; 255
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:227
  }

  do {
    char c = n % base;
     586:	84 2e       	mov	r8, r20
     588:	91 2c       	mov	r9, r1
     58a:	b1 2c       	mov	r11, r1
     58c:	a1 2c       	mov	r10, r1
     58e:	a5 01       	movw	r20, r10
     590:	94 01       	movw	r18, r8
     592:	0e 94 69 0d 	call	0x1ad2	; 0x1ad2 <__udivmodsi4>
     596:	e6 2f       	mov	r30, r22
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:228
    n /= base;
     598:	b9 01       	movw	r22, r18
     59a:	ca 01       	movw	r24, r20
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:230

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
     59c:	ea 30       	cpi	r30, 0x0A	; 10
     59e:	dc f4       	brge	.+54     	; 0x5d6 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.54]+0x78>
     5a0:	e0 5d       	subi	r30, 0xD0	; 208
     5a2:	d8 01       	movw	r26, r16
     5a4:	ee 93       	st	-X, r30
     5a6:	8d 01       	movw	r16, r26
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:231
  } while (n);
     5a8:	23 2b       	or	r18, r19
     5aa:	24 2b       	or	r18, r20
     5ac:	25 2b       	or	r18, r21
     5ae:	79 f7       	brne	.-34     	; 0x58e <Print::printNumber(unsigned long, unsigned char) [clone .constprop.54]+0x30>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.h:54
    }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) {
        return 0;
     5b0:	90 e0       	ldi	r25, 0x00	; 0
     5b2:	80 e0       	ldi	r24, 0x00	; 0
write():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.h:53
      setWriteError(0);
    }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) {
     5b4:	10 97       	sbiw	r26, 0x00	; 0
     5b6:	19 f0       	breq	.+6      	; 0x5be <Print::printNumber(unsigned long, unsigned char) [clone .constprop.54]+0x60>
     5b8:	cd 01       	movw	r24, r26
     5ba:	0e 94 a2 02 	call	0x544	; 0x544 <Print::write(char const*) [clone .part.2] [clone .constprop.57]>
_ZN5Print11printNumberEmh.constprop.54():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:234

  return write(str);
}
     5be:	a1 96       	adiw	r28, 0x21	; 33
     5c0:	cd bf       	out	0x3d, r28	; 61
     5c2:	de bf       	out	0x3e, r29	; 62
     5c4:	df 91       	pop	r29
     5c6:	cf 91       	pop	r28
     5c8:	1f 91       	pop	r17
     5ca:	0f 91       	pop	r16
     5cc:	bf 90       	pop	r11
     5ce:	af 90       	pop	r10
     5d0:	9f 90       	pop	r9
     5d2:	8f 90       	pop	r8
     5d4:	08 95       	ret
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:230

  do {
    char c = n % base;
    n /= base;

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
     5d6:	e9 5c       	subi	r30, 0xC9	; 201
     5d8:	e4 cf       	rjmp	.-56     	; 0x5a2 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.54]+0x44>

000005da <Print::print(char const*) [clone .constprop.49]>:
_ZN5Print5printEPKc.constprop.49():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:66

size_t Print::print(const String &s) {
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[]) {
     5da:	0c 94 a2 02 	jmp	0x544	; 0x544 <Print::write(char const*) [clone .part.2] [clone .constprop.57]>

000005de <Print::println(char const*) [clone .constprop.44]>:
_ZN5Print7printlnEPKc.constprop.44():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:133
  size_t n = print(s);
  n += println();
  return n;
}

size_t Print::println(const char c[]) {
     5de:	cf 93       	push	r28
     5e0:	df 93       	push	r29
write():
     5e2:	0e 94 a2 02 	call	0x544	; 0x544 <Print::write(char const*) [clone .part.2] [clone .constprop.57]>
     5e6:	ec 01       	movw	r28, r24
     5e8:	88 ee       	ldi	r24, 0xE8	; 232
     5ea:	9d e9       	ldi	r25, 0x9D	; 157
     5ec:	0e 94 a2 02 	call	0x544	; 0x544 <Print::write(char const*) [clone .part.2] [clone .constprop.57]>
_ZN5Print7printlnEPKc.constprop.44():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:137
  size_t n = print(c);
  n += println();
  return n;
}
     5f0:	8c 0f       	add	r24, r28
     5f2:	9d 1f       	adc	r25, r29
     5f4:	df 91       	pop	r29
     5f6:	cf 91       	pop	r28
     5f8:	08 95       	ret

000005fa <Print::println(unsigned char, int) [clone .constprop.50]>:
_ZN5Print7printlnEhi.constprop.50():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:145
  size_t n = print(c);
  n += println();
  return n;
}

size_t Print::println(unsigned char b, int base) {
     5fa:	cf 93       	push	r28
     5fc:	df 93       	push	r29
print():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:75
size_t Print::print(char c) {
  return write(c);
}

size_t Print::print(unsigned char b, int base) {
  return print((unsigned long) b, base);
     5fe:	68 2f       	mov	r22, r24
     600:	70 e0       	ldi	r23, 0x00	; 0
     602:	90 e0       	ldi	r25, 0x00	; 0
     604:	80 e0       	ldi	r24, 0x00	; 0
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:105

size_t Print::print(unsigned long n, int base) {
  if (base == 0) {
    return write(n);
  } else {
    return printNumber(n, base);
     606:	4a e0       	ldi	r20, 0x0A	; 10
     608:	0e 94 af 02 	call	0x55e	; 0x55e <Print::printNumber(unsigned long, unsigned char) [clone .constprop.54]>
     60c:	ec 01       	movw	r28, r24
write():
     60e:	88 ee       	ldi	r24, 0xE8	; 232
     610:	9d e9       	ldi	r25, 0x9D	; 157
     612:	0e 94 a2 02 	call	0x544	; 0x544 <Print::write(char const*) [clone .part.2] [clone .constprop.57]>
_ZN5Print7printlnEhi.constprop.50():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:149

size_t Print::println(unsigned char b, int base) {
  size_t n = print(b, base);
  n += println();
  return n;
}
     616:	8c 0f       	add	r24, r28
     618:	9d 1f       	adc	r25, r29
     61a:	df 91       	pop	r29
     61c:	cf 91       	pop	r28
     61e:	08 95       	ret

00000620 <readTouchData(unsigned char, unsigned char, unsigned char*)>:
_Z13readTouchDatahhPh():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:55

    Serial.println("");
}


uint8_t readTouchData(uint8_t offset, uint8_t count, uint8_t * buf) {
     620:	af 92       	push	r10
     622:	bf 92       	push	r11
     624:	df 92       	push	r13
     626:	ef 92       	push	r14
     628:	ff 92       	push	r15
     62a:	0f 93       	push	r16
     62c:	1f 93       	push	r17
     62e:	cf 93       	push	r28
     630:	df 93       	push	r29
     632:	d6 2e       	mov	r13, r22
     634:	ea 01       	movw	r28, r20
     636:	fa 01       	movw	r30, r20
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:58
    uint8_t error;

    for (int i=0; i<count; ++i) {
     638:	26 2f       	mov	r18, r22
     63a:	30 e0       	ldi	r19, 0x00	; 0
     63c:	af 01       	movw	r20, r30
     63e:	4c 1b       	sub	r20, r28
     640:	5d 0b       	sbc	r21, r29
     642:	42 17       	cp	r20, r18
     644:	53 07       	cpc	r21, r19
     646:	14 f4       	brge	.+4      	; 0x64c <readTouchData(unsigned char, unsigned char, unsigned char*)+0x2c>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:59
      buf[i] = 0;
     648:	11 92       	st	Z+, r1
     64a:	f8 cf       	rjmp	.-16     	; 0x63c <readTouchData(unsigned char, unsigned char, unsigned char*)+0x1c>
beginTransmission():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:256

void TwoWire::beginTransmission(uint8_t address) {
  // indicate that we are transmitting
  transmitting = 1;
  // set address of targeted slave
  txAddress = address;
     64c:	95 e7       	ldi	r25, 0x75	; 117
     64e:	90 93 89 39 	sts	0x3989, r25	; 0x803989 <TwoWire::txAddress>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:258
  // reset tx buffer iterator vars
  txBufferIndex = 0;
     652:	10 92 68 39 	sts	0x3968, r1	; 0x803968 <TwoWire::txBufferIndex>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:259
  txBufferLength = 0;
     656:	10 92 8a 39 	sts	0x398A, r1	; 0x80398a <TwoWire::txBufferLength>
_Z13readTouchDatahhPh():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:63
    }

    Wire.beginTransmission(TOUCH_ADDRESS);
    Wire.write(offset);
     65a:	68 2f       	mov	r22, r24
     65c:	86 e2       	ldi	r24, 0x26	; 38
     65e:	9a e3       	ldi	r25, 0x3A	; 58
     660:	0e 94 79 02 	call	0x4f2	; 0x4f2 <TwoWire::write(unsigned char)>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:64
    error = Wire.endTransmission(false);
     664:	0e 94 19 02 	call	0x432	; 0x432 <TwoWire::endTransmission(bool) [clone .constprop.47]>
     668:	18 2f       	mov	r17, r24
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:66

    if (error) {
     66a:	7e 01       	movw	r14, r28
TWI_MasterRead():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:294
*/
uint8_t TWI_MasterRead(uint8_t slave_address,
                       uint8_t *read_data,
                       uint8_t bytes_to_read,
                       uint8_t send_stop) {
  master_readData = read_data;
     66c:	8f e4       	ldi	r24, 0x4F	; 79
     66e:	a8 2e       	mov	r10, r24
     670:	88 e3       	ldi	r24, 0x38	; 56
     672:	b8 2e       	mov	r11, r24
_Z13readTouchDatahhPh():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:66
     674:	11 23       	and	r17, r17
     676:	91 f0       	breq	.+36     	; 0x69c <readTouchData(unsigned char, unsigned char, unsigned char*)+0x7c>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:67
        Serial.print("oopsie (read): ");
     678:	8b ee       	ldi	r24, 0xEB	; 235
     67a:	9d e9       	ldi	r25, 0x9D	; 157
     67c:	0e 94 ed 02 	call	0x5da	; 0x5da <Print::print(char const*) [clone .constprop.49]>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:68
        Serial.println(error);
     680:	81 2f       	mov	r24, r17
     682:	0e 94 fd 02 	call	0x5fa	; 0x5fa <Print::println(unsigned char, int) [clone .constprop.50]>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:78
      Wire.requestFrom(TOUCH_ADDRESS, 1);
      buf[i] = Wire.read();
    }

    return 0; // or error if we read too few?
}
     686:	81 2f       	mov	r24, r17
     688:	df 91       	pop	r29
     68a:	cf 91       	pop	r28
     68c:	1f 91       	pop	r17
     68e:	0f 91       	pop	r16
     690:	ff 90       	pop	r15
     692:	ef 90       	pop	r14
     694:	df 90       	pop	r13
     696:	bf 90       	pop	r11
     698:	af 90       	pop	r10
     69a:	08 95       	ret
TWI_MasterRead():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:294
     69c:	a0 92 4b 38 	sts	0x384B, r10	; 0x80384b <master_readData>
     6a0:	b0 92 4c 38 	sts	0x384C, r11	; 0x80384c <master_readData+0x1>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:296

  uint8_t bytes_read = TWI_MasterWriteRead(slave_address,
     6a4:	01 e0       	ldi	r16, 0x01	; 1
     6a6:	21 e0       	ldi	r18, 0x01	; 1
     6a8:	40 e0       	ldi	r20, 0x00	; 0
     6aa:	70 e0       	ldi	r23, 0x00	; 0
     6ac:	60 e0       	ldi	r22, 0x00	; 0
     6ae:	85 e7       	ldi	r24, 0x75	; 117
     6b0:	0e 94 ba 01 	call	0x374	; 0x374 <TWI_MasterWriteRead>
requestFrom():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:227
  }

  uint8_t bytes_read = TWI_MasterRead(address, rxBuffer, quantity, sendStop);

  /* Initialize read variables */
  rxBufferIndex = 0;
     6b4:	10 92 4e 38 	sts	0x384E, r1	; 0x80384e <TwoWire::rxBufferIndex>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:228
  rxBufferLength = bytes_read;
     6b8:	80 93 4d 38 	sts	0x384D, r24	; 0x80384d <TwoWire::rxBufferLength>
_Z13readTouchDatahhPh():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:74
        return error;
    }

    for (uint8_t i=0; i<count; ++i) {
      Wire.requestFrom(TOUCH_ADDRESS, 1);
      buf[i] = Wire.read();
     6bc:	86 e2       	ldi	r24, 0x26	; 38
     6be:	9a e3       	ldi	r25, 0x3A	; 58
     6c0:	0e 94 3a 02 	call	0x474	; 0x474 <TwoWire::read()>
     6c4:	f7 01       	movw	r30, r14
     6c6:	81 93       	st	Z+, r24
     6c8:	7f 01       	movw	r14, r30
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:72
        Serial.print("oopsie (read): ");
        Serial.println(error);
        return error;
    }

    for (uint8_t i=0; i<count; ++i) {
     6ca:	8e 2f       	mov	r24, r30
     6cc:	8c 1b       	sub	r24, r28
     6ce:	8d 15       	cp	r24, r13
     6d0:	28 f3       	brcs	.-54     	; 0x69c <readTouchData(unsigned char, unsigned char, unsigned char*)+0x7c>
     6d2:	d9 cf       	rjmp	.-78     	; 0x686 <readTouchData(unsigned char, unsigned char, unsigned char*)+0x66>

000006d4 <printTouchData(unsigned char, unsigned char*)>:
_Z14printTouchDatahPh():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:80
    }

    return 0; // or error if we read too few?
}

void printTouchData(uint8_t count, uint8_t * buf) {
     6d4:	cf 92       	push	r12
     6d6:	df 92       	push	r13
     6d8:	ef 92       	push	r14
     6da:	ff 92       	push	r15
     6dc:	0f 93       	push	r16
     6de:	1f 93       	push	r17
     6e0:	cf 93       	push	r28
     6e2:	df 93       	push	r29
     6e4:	7b 01       	movw	r14, r22
     6e6:	eb 01       	movw	r28, r22
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:82

  for (int i=0; i<count; ++i) {
     6e8:	08 2f       	mov	r16, r24
     6ea:	10 e0       	ldi	r17, 0x00	; 0
     6ec:	ce 01       	movw	r24, r28
     6ee:	8e 19       	sub	r24, r14
     6f0:	9f 09       	sbc	r25, r15
     6f2:	80 17       	cp	r24, r16
     6f4:	91 07       	cpc	r25, r17
     6f6:	a4 f4       	brge	.+40     	; 0x720 <printTouchData(unsigned char, unsigned char*)+0x4c>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:83
    Serial.print(' ');
     6f8:	80 e2       	ldi	r24, 0x20	; 32
     6fa:	0e 94 68 01 	call	0x2d0	; 0x2d0 <Print::print(char) [clone .constprop.43]>
     6fe:	6e 01       	movw	r12, r28
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:85

    if (buf[i] < 16) {
     700:	88 81       	ld	r24, Y
     702:	80 31       	cpi	r24, 0x10	; 16
     704:	18 f4       	brcc	.+6      	; 0x70c <printTouchData(unsigned char, unsigned char*)+0x38>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:86
      Serial.print('0');
     706:	80 e3       	ldi	r24, 0x30	; 48
     708:	0e 94 68 01 	call	0x2d0	; 0x2d0 <Print::print(char) [clone .constprop.43]>
     70c:	21 96       	adiw	r28, 0x01	; 1
print():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:75
size_t Print::print(char c) {
  return write(c);
}

size_t Print::print(unsigned char b, int base) {
  return print((unsigned long) b, base);
     70e:	f6 01       	movw	r30, r12
     710:	60 81       	ld	r22, Z
     712:	70 e0       	ldi	r23, 0x00	; 0
     714:	90 e0       	ldi	r25, 0x00	; 0
     716:	80 e0       	ldi	r24, 0x00	; 0
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:105

size_t Print::print(unsigned long n, int base) {
  if (base == 0) {
    return write(n);
  } else {
    return printNumber(n, base);
     718:	40 e1       	ldi	r20, 0x10	; 16
     71a:	0e 94 af 02 	call	0x55e	; 0x55e <Print::printNumber(unsigned long, unsigned char) [clone .constprop.54]>
     71e:	e6 cf       	rjmp	.-52     	; 0x6ec <printTouchData(unsigned char, unsigned char*)+0x18>
_Z14printTouchDatahPh():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:90
    }
    Serial.print(buf[i], HEX);
  }
}
     720:	df 91       	pop	r29
     722:	cf 91       	pop	r28
     724:	1f 91       	pop	r17
     726:	0f 91       	pop	r16
     728:	ff 90       	pop	r15
     72a:	ef 90       	pop	r14
     72c:	df 90       	pop	r13
     72e:	cf 90       	pop	r12
     730:	08 95       	ret

00000732 <CmdParser::equalCmdParam(unsigned int, char const*) [clone .constprop.22]>:
_ZN9CmdParser13equalCmdParamEjPKc.constprop.22():
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.hpp:106
     *
     * @param idx               Number of param to get
     * @param value             String to compare
     * @return                  TRUE is equal
     */
    bool equalCmdParam(uint16_t idx, CmdParserString value)
     732:	cf 93       	push	r28
     734:	df 93       	push	r29
     736:	bc 01       	movw	r22, r24
getCmdParam():
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.cpp:79
    if (idx > m_paramCount) {
        return NULL;
    }

    // search hole cmd buffer
    for (size_t i = 0; i < m_bufferSize; i++) {
     738:	a0 91 5f 3a 	lds	r26, 0x3A5F	; 0x803a5f <cmdParser+0x5>
     73c:	b0 91 60 3a 	lds	r27, 0x3A60	; 0x803a60 <cmdParser+0x6>
     740:	e0 91 5d 3a 	lds	r30, 0x3A5D	; 0x803a5d <cmdParser+0x3>
     744:	f0 91 5e 3a 	lds	r31, 0x3A5E	; 0x803a5e <cmdParser+0x4>
_ZN9CmdParser13equalCmdParamEjPKc.constprop.22():
     748:	50 e0       	ldi	r21, 0x00	; 0
     74a:	40 e0       	ldi	r20, 0x00	; 0
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.cpp:71
    return m_paramCount;
}

char *CmdParser::getCmdParam(uint16_t idx)
{
    uint16_t count = 0;
     74c:	30 e0       	ldi	r19, 0x00	; 0
     74e:	20 e0       	ldi	r18, 0x00	; 0
getCmdParam():
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.cpp:79
    if (idx > m_paramCount) {
        return NULL;
    }

    // search hole cmd buffer
    for (size_t i = 0; i < m_bufferSize; i++) {
     750:	a4 17       	cp	r26, r20
     752:	b5 07       	cpc	r27, r21
     754:	19 f1       	breq	.+70     	; 0x79c <CmdParser::equalCmdParam(unsigned int, char const*) [clone .constprop.22]+0x6a>
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.cpp:82

        // find next position
        if (i > 0 && m_buffer[i] == 0x00 && m_buffer[i - 1] != 0x00) {
     756:	41 15       	cp	r20, r1
     758:	51 05       	cpc	r21, r1
     75a:	79 f0       	breq	.+30     	; 0x77a <CmdParser::equalCmdParam(unsigned int, char const*) [clone .constprop.22]+0x48>
     75c:	cf 01       	movw	r24, r30
     75e:	c0 81       	ld	r28, Z
     760:	c1 11       	cpse	r28, r1
     762:	1f c0       	rjmp	.+62     	; 0x7a2 <CmdParser::equalCmdParam(unsigned int, char const*) [clone .constprop.22]+0x70>
     764:	ef 01       	movw	r28, r30
     766:	21 97       	sbiw	r28, 0x01	; 1
     768:	88 81       	ld	r24, Y
     76a:	88 23       	and	r24, r24
     76c:	11 f0       	breq	.+4      	; 0x772 <CmdParser::equalCmdParam(unsigned int, char const*) [clone .constprop.22]+0x40>
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.cpp:83
            count++;
     76e:	2f 5f       	subi	r18, 0xFF	; 255
     770:	3f 4f       	sbci	r19, 0xFF	; 255
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.cpp:79
    if (idx > m_paramCount) {
        return NULL;
    }

    // search hole cmd buffer
    for (size_t i = 0; i < m_bufferSize; i++) {
     772:	4f 5f       	subi	r20, 0xFF	; 255
     774:	5f 4f       	sbci	r21, 0xFF	; 255
     776:	31 96       	adiw	r30, 0x01	; 1
     778:	eb cf       	rjmp	.-42     	; 0x750 <CmdParser::equalCmdParam(unsigned int, char const*) [clone .constprop.22]+0x1e>
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.cpp:87
        if (i > 0 && m_buffer[i] == 0x00 && m_buffer[i - 1] != 0x00) {
            count++;
        }

        // found indx with next character
        if (count == idx && m_buffer[i] != 0x00) {
     77a:	21 15       	cp	r18, r1
     77c:	31 05       	cpc	r19, r1
     77e:	c9 f7       	brne	.-14     	; 0x772 <CmdParser::equalCmdParam(unsigned int, char const*) [clone .constprop.22]+0x40>
     780:	cf 01       	movw	r24, r30
     782:	c0 81       	ld	r28, Z
     784:	cc 23       	and	r28, r28
     786:	a9 f3       	breq	.-22     	; 0x772 <CmdParser::equalCmdParam(unsigned int, char const*) [clone .constprop.22]+0x40>
_ZN9CmdParser13equalCmdParamEjPKc.constprop.22():
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.hpp:108
    {
        if (strcasecmp(this->getCmdParam(idx), value) == 0) {
     788:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <strcasecmp>
     78c:	21 e0       	ldi	r18, 0x01	; 1
     78e:	89 2b       	or	r24, r25
     790:	09 f0       	breq	.+2      	; 0x794 <CmdParser::equalCmdParam(unsigned int, char const*) [clone .constprop.22]+0x62>
     792:	20 e0       	ldi	r18, 0x00	; 0
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.hpp:113
            return true;
        }

        return false;
    }
     794:	82 2f       	mov	r24, r18
     796:	df 91       	pop	r29
     798:	cf 91       	pop	r28
     79a:	08 95       	ret
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.cpp:92
            return reinterpret_cast<char *>(&m_buffer[i]);
        }
    }

    return NULL;
     79c:	80 e0       	ldi	r24, 0x00	; 0
     79e:	90 e0       	ldi	r25, 0x00	; 0
     7a0:	f3 cf       	rjmp	.-26     	; 0x788 <CmdParser::equalCmdParam(unsigned int, char const*) [clone .constprop.22]+0x56>
getCmdParam():
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.cpp:87
        if (i > 0 && m_buffer[i] == 0x00 && m_buffer[i - 1] != 0x00) {
            count++;
        }

        // found indx with next character
        if (count == idx && m_buffer[i] != 0x00) {
     7a2:	21 15       	cp	r18, r1
     7a4:	31 05       	cpc	r19, r1
     7a6:	29 f7       	brne	.-54     	; 0x772 <CmdParser::equalCmdParam(unsigned int, char const*) [clone .constprop.22]+0x40>
     7a8:	ef cf       	rjmp	.-34     	; 0x788 <CmdParser::equalCmdParam(unsigned int, char const*) [clone .constprop.22]+0x56>

000007aa <digitalWrite.constprop.6>:
digitalWrite.constprop.6():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:221
  that the value of the port was set correctly when it was
  changed to an output. Code in the wild relies on this behavior.
  */

  if (val == LOW) { /* If LOW */
    port->OUTCLR = bit_mask;
     7aa:	90 e4       	ldi	r25, 0x40	; 64
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:220
  you could digitalWrite() a pin while it's an input, to ensure
  that the value of the port was set correctly when it was
  changed to an output. Code in the wild relies on this behavior.
  */

  if (val == LOW) { /* If LOW */
     7ac:	81 11       	cpse	r24, r1
     7ae:	13 c0       	rjmp	.+38     	; 0x7d6 <digitalWrite.constprop.6+0x2c>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:221
    port->OUTCLR = bit_mask;
     7b0:	90 93 06 04 	sts	0x0406, r25	; 0x800406 <vtable for CmdBuffer<32u>+0x7f6628>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:238
  } else {
    port->OUTSET = bit_mask;
  }

  /* Input direction */
  if (!(port->DIR & bit_mask)) {
     7b4:	90 91 00 04 	lds	r25, 0x0400	; 0x800400 <vtable for CmdBuffer<32u>+0x7f6622>
     7b8:	96 fd       	sbrc	r25, 6
     7ba:	0a c0       	rjmp	.+20     	; 0x7d0 <digitalWrite.constprop.6+0x26>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:251

    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);

    /* Save system status and disable interrupts */
    uint8_t status = SREG;
     7bc:	9f b7       	in	r25, 0x3f	; 63
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:252
    cli();
     7be:	f8 94       	cli
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:254

    if (val == LOW) {
     7c0:	81 11       	cpse	r24, r1
     7c2:	0c c0       	rjmp	.+24     	; 0x7dc <digitalWrite.constprop.6+0x32>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:256
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
     7c4:	80 91 16 04 	lds	r24, 0x0416	; 0x800416 <vtable for CmdBuffer<32u>+0x7f6638>
     7c8:	87 7f       	andi	r24, 0xF7	; 247
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:259
    } else {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
     7ca:	80 93 16 04 	sts	0x0416, r24	; 0x800416 <vtable for CmdBuffer<32u>+0x7f6638>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:263
    }

    /* Restore system status */
    SREG = status;
     7ce:	9f bf       	out	0x3f, r25	; 63
turnOffPWM():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:150
    /* we don't need the type b timers as this core does not use them for PWM      */

    // 1-series parts have a DAC that we can use...
    #if defined(DAC0)
      case DACOUT:
        DAC0.CTRLA = 0x00;
     7d0:	10 92 a0 06 	sts	0x06A0, r1	; 0x8006a0 <vtable for CmdBuffer<32u>+0x7f68c2>
digitalWrite.constprop.6():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:270
  /* Turn off PWM if applicable */
  // If the pin supports PWM output, we need to turn it off
  // Better to do so AFTER we have set PORTx.OUT to what we want it to be when we're done
  // The glitch would be super short, of course, but why make a glitch we don't have to?
  turnOffPWM(pin);
}
     7d4:	08 95       	ret
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:234
    // val will now be 0 (LOW) if the toggling made it LOW
    // or bit_mask if not. And further down, we only need to
    // know if it's
  /* If HIGH OR  > TOGGLE  */
  } else {
    port->OUTSET = bit_mask;
     7d6:	90 93 05 04 	sts	0x0405, r25	; 0x800405 <vtable for CmdBuffer<32u>+0x7f6627>
     7da:	ec cf       	rjmp	.-40     	; 0x7b4 <digitalWrite.constprop.6+0xa>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:259
    if (val == LOW) {
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
    } else {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
     7dc:	80 91 16 04 	lds	r24, 0x0416	; 0x800416 <vtable for CmdBuffer<32u>+0x7f6638>
     7e0:	88 60       	ori	r24, 0x08	; 8
     7e2:	f3 cf       	rjmp	.-26     	; 0x7ca <digitalWrite.constprop.6+0x20>

000007e4 <digitalRead.constprop.3>:
digitalRead.constprop.3():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:322

  /* Get port and check valid port */
  PORT_t *port = digitalPinToPortStruct(pin);

  /* Read pin value from PORTx.IN register */
  if (port->IN & bit_mask) {
     7e4:	80 91 08 04 	lds	r24, 0x0408	; 0x800408 <vtable for CmdBuffer<32u>+0x7f662a>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:327
    return HIGH;
  } else {
    return LOW;
  }
}
     7e8:	88 1f       	adc	r24, r24
     7ea:	88 27       	eor	r24, r24
     7ec:	88 1f       	adc	r24, r24
     7ee:	08 95       	ret

000007f0 <pinMode>:
pinMode():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:41
    // taking shortcuts we disapprove of, but to call out things that are virtually guaranteed to be a bug.
    // Passing -1/255/NOT_A_PIN to the digital I/O functions is most likely intentional.
      badArg("Digital pin is constant, but not a valid pin");
}

void pinMode(uint8_t pin, uint8_t mode) {
     7f0:	cf 93       	push	r28
     7f2:	df 93       	push	r29
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:44
  check_valid_digital_pin(pin);

  uint8_t bit_mask = digitalPinToBitMask(pin);
     7f4:	8c 30       	cpi	r24, 0x0C	; 12
     7f6:	98 f4       	brcc	.+38     	; 0x81e <__DATA_REGION_LENGTH__+0x1e>
check_valid_digital_pin():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:32
#include "pins_arduino.h"


inline __attribute__((always_inline)) void check_valid_digital_pin(pin_size_t pin)
{
  if(__builtin_constant_p(pin))
     7f8:	90 e0       	ldi	r25, 0x00	; 0
pinMode():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:44
}

void pinMode(uint8_t pin, uint8_t mode) {
  check_valid_digital_pin(pin);

  uint8_t bit_mask = digitalPinToBitMask(pin);
     7fa:	fc 01       	movw	r30, r24
     7fc:	e8 55       	subi	r30, 0x58	; 88
     7fe:	f2 46       	sbci	r31, 0x62	; 98
     800:	20 81       	ld	r18, Z
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:46

  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
     802:	2f 3f       	cpi	r18, 0xFF	; 255
     804:	61 f0       	breq	.+24     	; 0x81e <__DATA_REGION_LENGTH__+0x1e>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:50
    return;
  }

  PORT_t *port = digitalPinToPortStruct(pin);
     806:	fc 01       	movw	r30, r24
     808:	e4 56       	subi	r30, 0x64	; 100
     80a:	f2 46       	sbci	r31, 0x62	; 98
     80c:	e0 81       	ld	r30, Z
     80e:	30 e2       	ldi	r19, 0x20	; 32
     810:	e3 9f       	mul	r30, r19
     812:	f0 01       	movw	r30, r0
     814:	11 24       	eor	r1, r1
     816:	fc 5f       	subi	r31, 0xFC	; 252
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:55
  if (port == NULL) {
    return;
  }

  if (mode == OUTPUT) {
     818:	61 30       	cpi	r22, 0x01	; 1
     81a:	21 f4       	brne	.+8      	; 0x824 <__DATA_REGION_LENGTH__+0x24>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:58

    /* Configure direction as output */
    port->DIRSET = bit_mask;
     81c:	21 83       	std	Z+1, r18	; 0x01
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:95
    }

    /* Restore state */
    SREG = status;
  }
}
     81e:	df 91       	pop	r29
     820:	cf 91       	pop	r28
     822:	08 95       	ret
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:62
    /* Configure direction as output */
    port->DIRSET = bit_mask;

  } else { /* mode == INPUT or INPUT_PULLUP */

    uint8_t bit_pos = digitalPinToBitPosition(pin);
     824:	80 57       	subi	r24, 0x70	; 112
     826:	92 46       	sbci	r25, 0x62	; 98
     828:	ec 01       	movw	r28, r24
     82a:	a8 81       	ld	r26, Y
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:64
    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
     82c:	af 3f       	cpi	r26, 0xFF	; 255
     82e:	71 f0       	breq	.+28     	; 0x84c <__DATA_REGION_LENGTH__+0x4c>
     830:	cf 01       	movw	r24, r30
     832:	40 96       	adiw	r24, 0x10	; 16
     834:	a8 0f       	add	r26, r24
     836:	b9 2f       	mov	r27, r25
     838:	b1 1d       	adc	r27, r1
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:67

    /* Save state */
    uint8_t status = SREG;
     83a:	9f b7       	in	r25, 0x3f	; 63
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:68
    cli();
     83c:	f8 94       	cli
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:71

    /* Configure direction as input */
    port->DIRCLR = bit_mask;
     83e:	22 83       	std	Z+2, r18	; 0x02
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:77

    /* Configure pull-up resistor */
    if (mode == INPUT_PULLUP) {

      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
     840:	8c 91       	ld	r24, X
     842:	88 60       	ori	r24, 0x08	; 8
     844:	8c 93       	st	X, r24
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:82
      /* Considered this, it was in some 2.2.0 releases. This is debatable - it actually broke Wire...
       * though only because of errata effecting Wire that wasn't explicitly accounted for.
       */
      // emulate setting of the port output register on classic AVR
      port->OUTSET=bit_mask;
     846:	25 83       	std	Z+5, r18	; 0x05
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:93
      port->OUTCLR=bit_mask;

    }

    /* Restore state */
    SREG = status;
     848:	9f bf       	out	0x3f, r25	; 63
     84a:	e9 cf       	rjmp	.-46     	; 0x81e <__DATA_REGION_LENGTH__+0x1e>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:64

  } else { /* mode == INPUT or INPUT_PULLUP */

    uint8_t bit_pos = digitalPinToBitPosition(pin);
    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
     84c:	b0 e0       	ldi	r27, 0x00	; 0
     84e:	a0 e0       	ldi	r26, 0x00	; 0
     850:	f4 cf       	rjmp	.-24     	; 0x83a <__DATA_REGION_LENGTH__+0x3a>

00000852 <UartClass::begin(unsigned long, unsigned int)>:
_ZN9UartClass5beginEmj():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:172
    _pin_set = 0;
    return false;
  }
}

void UartClass::begin(unsigned long baud, uint16_t config) {
     852:	8f 92       	push	r8
     854:	9f 92       	push	r9
     856:	af 92       	push	r10
     858:	bf 92       	push	r11
     85a:	df 92       	push	r13
     85c:	ef 92       	push	r14
     85e:	ff 92       	push	r15
     860:	0f 93       	push	r16
     862:	1f 93       	push	r17
     864:	cf 93       	push	r28
     866:	df 93       	push	r29
     868:	ec 01       	movw	r28, r24
     86a:	4a 01       	movw	r8, r20
     86c:	5b 01       	movw	r10, r22
     86e:	d2 2e       	mov	r13, r18
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:179
    if (baud > (F_CPU/8)) badArg("Unachievable baud, too high - must be less than F_CPU/8");
    if (baud < (F_CPU/16800)) badArg("Unachievable baud, too low - must be more than F_CPU/16800 (16384 plus allowable error)");
  }
  // Make sure no transmissions are ongoing and USART is disabled in case begin() is called by accident
  // without first calling end()
  if (_written) {
     870:	8d 89       	ldd	r24, Y+21	; 0x15
     872:	88 23       	and	r24, r24
     874:	39 f0       	breq	.+14     	; 0x884 <UartClass::begin(unsigned long, unsigned int)+0x32>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:180
    this->end();
     876:	e8 81       	ld	r30, Y
     878:	f9 81       	ldd	r31, Y+1	; 0x01
     87a:	00 88       	ldd	r0, Z+16	; 0x10
     87c:	f1 89       	ldd	r31, Z+17	; 0x11
     87e:	e0 2d       	mov	r30, r0
     880:	ce 01       	movw	r24, r28
     882:	09 95       	icall
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:183
  }

  struct UartPinSet *set = &_hw_set[_pin_set];
     884:	0c 89       	ldd	r16, Y+20	; 0x14
     886:	10 e0       	ldi	r17, 0x00	; 0
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:186

  int32_t baud_setting = 0;
  uint8_t rxmode=0;
     888:	e1 2c       	mov	r14, r1
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:190

  // Use CLK2X if appropriate.
  #if (F_CPU > 2000000)
  if(baud>=(38400*(F_CPU/1000000))) {
     88a:	81 14       	cp	r8, r1
     88c:	2c ed       	ldi	r18, 0xDC	; 220
     88e:	92 06       	cpc	r9, r18
     890:	25 e0       	ldi	r18, 0x05	; 5
     892:	a2 06       	cpc	r10, r18
     894:	b1 04       	cpc	r11, r1
     896:	30 f0       	brcs	.+12     	; 0x8a4 <UartClass::begin(unsigned long, unsigned int)+0x52>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:192
    rxmode = USART_RXMODE_CLK2X_gc;
    baud=baud>>1;
     898:	b6 94       	lsr	r11
     89a:	a7 94       	ror	r10
     89c:	97 94       	ror	r9
     89e:	87 94       	ror	r8
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:191
  uint8_t rxmode=0;

  // Use CLK2X if appropriate.
  #if (F_CPU > 2000000)
  if(baud>=(38400*(F_CPU/1000000))) {
    rxmode = USART_RXMODE_CLK2X_gc;
     8a0:	42 e0       	ldi	r20, 0x02	; 2
     8a2:	e4 2e       	mov	r14, r20
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:204
  #else
  //if clocked at 1 or 2 MHz, always use CLK2X mode and save a bit of space, we correct for not shifting the baud value below, as it saves a bit of flash
    rxmode = USART_RXMODE_CLK2X_gc;
  #endif

  _written = false;
     8a4:	1d 8a       	std	Y+21, r1	; 0x15
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:216
    // it's close enough to work under normal circumstances anyway.
    #if (F_CPU==20000000UL || F_CPU==10000000UL || F_CPU==5000000UL) //this means we are on the 20MHz oscillator
      #ifdef UARTBAUD3V
        int8_t sigrow_val = SIGROW.OSC20ERR3V;
      #else
        int8_t sigrow_val = SIGROW.OSC20ERR5V;
     8a6:	f0 90 25 11 	lds	r15, 0x1125	; 0x801125 <vtable for CmdBuffer<32u>+0x7f7347>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:227
        int8_t sigrow_val = SIGROW.OSC16ERR5V;
      #endif
    #endif
    #if (F_CPU > 2000000)
      //if we are above 2 MHz, baud was corrected above if CLK2X used.
      baud_setting = ((8 * F_CPU) / baud);
     8aa:	60 e0       	ldi	r22, 0x00	; 0
     8ac:	74 eb       	ldi	r23, 0xB4	; 180
     8ae:	84 ec       	ldi	r24, 0xC4	; 196
     8b0:	94 e0       	ldi	r25, 0x04	; 4
     8b2:	a5 01       	movw	r20, r10
     8b4:	94 01       	movw	r18, r8
     8b6:	0e 94 69 0d 	call	0x1ad2	; 0x1ad2 <__udivmodsi4>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:232
    #else
      //if clocked at 1 or 2 MHz, always use CLK2X mode and save a bit of flash...
      baud_setting = ((16 * F_CPU) / baud);
    #endif
    baud_setting *= (1024 + sigrow_val);
     8ba:	af 2d       	mov	r26, r15
     8bc:	ff 0c       	add	r15, r15
     8be:	bb 0b       	sbc	r27, r27
     8c0:	bc 5f       	subi	r27, 0xFC	; 252
     8c2:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <__mulshisi3>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:233
    baud_setting /= 2048;
     8c6:	dc 01       	movw	r26, r24
     8c8:	cb 01       	movw	r24, r22
     8ca:	2b e0       	ldi	r18, 0x0B	; 11
     8cc:	b5 95       	asr	r27
     8ce:	a7 95       	ror	r26
     8d0:	97 95       	ror	r25
     8d2:	87 95       	ror	r24
     8d4:	2a 95       	dec	r18
     8d6:	d1 f7       	brne	.-12     	; 0x8cc <UartClass::begin(unsigned long, unsigned int)+0x7a>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:249
    #endif
  #endif

  // Make sure global interrupts are disabled during initialization
  // no reason to do this before we potentially do all that long division, right?
  uint8_t oldSREG = SREG;
     8d8:	ff b6       	in	r15, 0x3f	; 63
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:250
  cli();
     8da:	f8 94       	cli
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:252
  // assign the baud_setting, a.k.a. BAUD (USART Baud Rate Register)
  (*_hwserial_module).BAUD = (uint16_t)baud_setting;
     8dc:	ec 85       	ldd	r30, Y+12	; 0x0c
     8de:	fd 85       	ldd	r31, Y+13	; 0x0d
     8e0:	00 97       	sbiw	r24, 0x00	; 0
     8e2:	21 e0       	ldi	r18, 0x01	; 1
     8e4:	a2 07       	cpc	r26, r18
     8e6:	b1 05       	cpc	r27, r1
     8e8:	24 f0       	brlt	.+8      	; 0x8f2 <UartClass::begin(unsigned long, unsigned int)+0xa0>
     8ea:	8f ef       	ldi	r24, 0xFF	; 255
     8ec:	9f ef       	ldi	r25, 0xFF	; 255
     8ee:	a0 e0       	ldi	r26, 0x00	; 0
     8f0:	b0 e0       	ldi	r27, 0x00	; 0
     8f2:	80 87       	std	Z+8, r24	; 0x08
     8f4:	91 87       	std	Z+9, r25	; 0x09
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:255

  // Set USART mode of operation
  (*_hwserial_module).CTRLC = config;
     8f6:	ec 85       	ldd	r30, Y+12	; 0x0c
     8f8:	fd 85       	ldd	r31, Y+13	; 0x0d
     8fa:	d7 82       	std	Z+7, r13	; 0x07
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:258

  // Enable transmitter and receiver
  (*_hwserial_module).CTRLB = ((*_hwserial_module).CTRLB&(~USART_RXMODE_gm)) | rxmode | (USART_RXEN_bm | USART_TXEN_bm);
     8fc:	ec 85       	ldd	r30, Y+12	; 0x0c
     8fe:	fd 85       	ldd	r31, Y+13	; 0x0d
     900:	86 81       	ldd	r24, Z+6	; 0x06
     902:	89 7f       	andi	r24, 0xF9	; 249
     904:	80 6c       	ori	r24, 0xC0	; 192
     906:	8e 29       	or	r24, r14
     908:	86 83       	std	Z+6, r24	; 0x06
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:260

  (*_hwserial_module).CTRLA |= USART_RXCIE_bm;
     90a:	ec 85       	ldd	r30, Y+12	; 0x0c
     90c:	fd 85       	ldd	r31, Y+13	; 0x0d
     90e:	85 81       	ldd	r24, Z+5	; 0x05
     910:	80 68       	ori	r24, 0x80	; 128
     912:	85 83       	std	Z+5, r24	; 0x05
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:265


  // Let PORTMUX point to alternative UART pins as requested
  #ifdef PORTMUX_CTRLB
    PORTMUX.CTRLB = set->mux | (PORTMUX.CTRLB & ~_hw_set[1].mux);
     914:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <vtable for CmdBuffer<32u>+0x7f6423>
     918:	8b 89       	ldd	r24, Y+19	; 0x13
     91a:	80 95       	com	r24
     91c:	89 23       	and	r24, r25
     91e:	98 01       	movw	r18, r16
     920:	22 0f       	add	r18, r18
     922:	33 1f       	adc	r19, r19
     924:	02 0f       	add	r16, r18
     926:	13 1f       	adc	r17, r19
     928:	c0 0f       	add	r28, r16
     92a:	d1 1f       	adc	r29, r17
     92c:	98 89       	ldd	r25, Y+16	; 0x10
     92e:	89 2b       	or	r24, r25
     930:	80 93 01 02 	sts	0x0201, r24	; 0x800201 <vtable for CmdBuffer<32u>+0x7f6423>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:271
  #else
    PORTMUX.USARTROUTEA = set->mux | (PORTMUX.USARTROUTEA & ~_hw_set[1].mux);
  #endif

  // Set pin state for swapped UART pins
  pinMode(set->rx_pin, INPUT_PULLUP);
     934:	62 e0       	ldi	r22, 0x02	; 2
     936:	8e 85       	ldd	r24, Y+14	; 0x0e
     938:	0e 94 f8 03 	call	0x7f0	; 0x7f0 <pinMode>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:273
  //digitalWrite(set->tx_pin, HIGH);
  pinMode(set->tx_pin, OUTPUT);
     93c:	61 e0       	ldi	r22, 0x01	; 1
     93e:	8f 85       	ldd	r24, Y+15	; 0x0f
     940:	0e 94 f8 03 	call	0x7f0	; 0x7f0 <pinMode>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:276

  // Restore SREG content
  SREG = oldSREG;
     944:	ff be       	out	0x3f, r15	; 63
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:277
}
     946:	df 91       	pop	r29
     948:	cf 91       	pop	r28
     94a:	1f 91       	pop	r17
     94c:	0f 91       	pop	r16
     94e:	ff 90       	pop	r15
     950:	ef 90       	pop	r14
     952:	df 90       	pop	r13
     954:	bf 90       	pop	r11
     956:	af 90       	pop	r10
     958:	9f 90       	pop	r9
     95a:	8f 90       	pop	r8
     95c:	08 95       	ret

0000095e <__cxa_pure_virtual>:
__cxa_pure_virtual():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/abi.cpp:27
extern "C" void __cxa_deleted_virtual(void) __attribute__((__noreturn__));

void __cxa_pure_virtual(void) {
  // We might want to write some diagnostics to uart in this case
  //std::terminate();
  abort();
     95e:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <abort>

00000962 <CmdBuffer<32u>::clear()>:
_ZN9CmdBufferILj32EE5clearEv():
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdBuffer.hpp:146
    CmdBuffer() { this->clear(); }

    /**
     * @interface CmdBufferObject
     */
    virtual void clear() { memset(m_buffer, 0x00, BUFFERSIZE + 1); }
     962:	07 96       	adiw	r24, 0x07	; 7
     964:	21 e2       	ldi	r18, 0x21	; 33
     966:	fc 01       	movw	r30, r24
     968:	11 92       	st	Z+, r1
     96a:	2a 95       	dec	r18
     96c:	e9 f7       	brne	.-6      	; 0x968 <CmdBuffer<32u>::clear()+0x6>
     96e:	08 95       	ret

00000970 <__vector_28>:
__vector_28():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART0.cpp:48
#else
#error "Don't know what the Data Received interrupt vector is called for Serial"
#endif

#if defined(HWSERIAL0_DRE_VECTOR)
ISR(HWSERIAL0_DRE_VECTOR) {
     970:	1f 92       	push	r1
     972:	0f 92       	push	r0
     974:	0f b6       	in	r0, 0x3f	; 63
     976:	0f 92       	push	r0
     978:	11 24       	eor	r1, r1
     97a:	2f 93       	push	r18
     97c:	3f 93       	push	r19
     97e:	4f 93       	push	r20
     980:	5f 93       	push	r21
     982:	6f 93       	push	r22
     984:	7f 93       	push	r23
     986:	8f 93       	push	r24
     988:	9f 93       	push	r25
     98a:	af 93       	push	r26
     98c:	bf 93       	push	r27
     98e:	ef 93       	push	r30
     990:	ff 93       	push	r31
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART0.cpp:49
  Serial._tx_data_empty_irq();
     992:	8b e8       	ldi	r24, 0x8B	; 139
     994:	99 e3       	ldi	r25, 0x39	; 57
     996:	0e 94 f1 00 	call	0x1e2	; 0x1e2 <UartClass::_tx_data_empty_irq()>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART0.cpp:50
}
     99a:	ff 91       	pop	r31
     99c:	ef 91       	pop	r30
     99e:	bf 91       	pop	r27
     9a0:	af 91       	pop	r26
     9a2:	9f 91       	pop	r25
     9a4:	8f 91       	pop	r24
     9a6:	7f 91       	pop	r23
     9a8:	6f 91       	pop	r22
     9aa:	5f 91       	pop	r21
     9ac:	4f 91       	pop	r20
     9ae:	3f 91       	pop	r19
     9b0:	2f 91       	pop	r18
     9b2:	0f 90       	pop	r0
     9b4:	0f be       	out	0x3f, r0	; 63
     9b6:	0f 90       	pop	r0
     9b8:	1f 90       	pop	r1
     9ba:	18 95       	reti

000009bc <__vector_27>:
__vector_27():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART0.cpp:40
// first place.

#if defined(HAVE_HWSERIAL0)

#if defined(HWSERIAL0_RXC_VECTOR)
ISR(HWSERIAL0_RXC_VECTOR) {
     9bc:	1f 92       	push	r1
     9be:	0f 92       	push	r0
     9c0:	0f b6       	in	r0, 0x3f	; 63
     9c2:	0f 92       	push	r0
     9c4:	11 24       	eor	r1, r1
     9c6:	2f 93       	push	r18
     9c8:	8f 93       	push	r24
     9ca:	9f 93       	push	r25
     9cc:	ef 93       	push	r30
     9ce:	ff 93       	push	r31
_rx_complete_irq():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART_private.h:59

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void UartClass::_rx_complete_irq(void) {
  //if (bit_is_clear(*_rxdatah, USART_PERR_bp)) {
  if (!(((*_hwserial_module).RXDATAH) & USART_PERR_bm)) {
     9d0:	e0 91 97 39 	lds	r30, 0x3997	; 0x803997 <Serial+0xc>
     9d4:	f0 91 98 39 	lds	r31, 0x3998	; 0x803998 <Serial+0xd>
     9d8:	81 81       	ldd	r24, Z+1	; 0x01
     9da:	81 fd       	sbrc	r24, 1
     9dc:	1b c0       	rjmp	.+54     	; 0xa14 <__vector_27+0x58>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART_private.h:62
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = (*_hwserial_module).RXDATAL;
     9de:	90 81       	ld	r25, Z
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART_private.h:63
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
     9e0:	80 91 a1 39 	lds	r24, 0x39A1	; 0x8039a1 <Serial+0x16>
     9e4:	8f 5f       	subi	r24, 0xFF	; 255
     9e6:	8f 73       	andi	r24, 0x3F	; 63
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART_private.h:69

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
     9e8:	20 91 a2 39 	lds	r18, 0x39A2	; 0x8039a2 <Serial+0x17>
     9ec:	82 17       	cp	r24, r18
     9ee:	41 f0       	breq	.+16     	; 0xa00 <__vector_27+0x44>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART_private.h:70
      _rx_buffer[_rx_buffer_head] = c;
     9f0:	e0 91 a1 39 	lds	r30, 0x39A1	; 0x8039a1 <Serial+0x16>
     9f4:	f0 e0       	ldi	r31, 0x00	; 0
     9f6:	e5 57       	subi	r30, 0x75	; 117
     9f8:	f6 4c       	sbci	r31, 0xC6	; 198
     9fa:	93 8f       	std	Z+27, r25	; 0x1b
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART_private.h:71
      _rx_buffer_head = i;
     9fc:	80 93 a1 39 	sts	0x39A1, r24	; 0x8039a1 <Serial+0x16>
__vector_27():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART0.cpp:42
  Serial._rx_complete_irq();
}
     a00:	ff 91       	pop	r31
     a02:	ef 91       	pop	r30
     a04:	9f 91       	pop	r25
     a06:	8f 91       	pop	r24
     a08:	2f 91       	pop	r18
     a0a:	0f 90       	pop	r0
     a0c:	0f be       	out	0x3f, r0	; 63
     a0e:	0f 90       	pop	r0
     a10:	1f 90       	pop	r1
     a12:	18 95       	reti
_rx_complete_irq():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART_private.h:75
    }
  } else {
    // Parity error, read byte but discard it
    (*_hwserial_module).RXDATAL;
     a14:	80 81       	ld	r24, Z
     a16:	f4 cf       	rjmp	.-24     	; 0xa00 <__vector_27+0x44>

00000a18 <__vector_15>:
__vector_15():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:139
#elif defined(MILLIS_USE_TIMERB1)
  ISR(TCB1_INT_vect)
#else
  #error "No millis timer selected, but not disabled - cannot determine millis vector"
#endif
{
     a18:	1f 92       	push	r1
     a1a:	0f 92       	push	r0
     a1c:	0f b6       	in	r0, 0x3f	; 63
     a1e:	0f 92       	push	r0
     a20:	11 24       	eor	r1, r1
     a22:	2f 93       	push	r18
     a24:	3f 93       	push	r19
     a26:	4f 93       	push	r20
     a28:	5f 93       	push	r21
     a2a:	6f 93       	push	r22
     a2c:	8f 93       	push	r24
     a2e:	9f 93       	push	r25
     a30:	af 93       	push	r26
     a32:	bf 93       	push	r27
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:151
  #else
  timer_millis += 2;
  #endif
  #else
  #if !defined(MILLIS_USE_TIMERRTC) //TCA0 or TCD0
  uint32_t m = timer_millis;
     a34:	80 91 42 38 	lds	r24, 0x3842	; 0x803842 <timer_millis>
     a38:	90 91 43 38 	lds	r25, 0x3843	; 0x803843 <timer_millis+0x1>
     a3c:	a0 91 44 38 	lds	r26, 0x3844	; 0x803844 <timer_millis+0x2>
     a40:	b0 91 45 38 	lds	r27, 0x3845	; 0x803845 <timer_millis+0x3>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:152
  uint16_t f = timer_fract;
     a44:	40 91 40 38 	lds	r20, 0x3840	; 0x803840 <timer_fract>
     a48:	50 91 41 38 	lds	r21, 0x3841	; 0x803841 <timer_fract+0x1>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:154
  m += MILLIS_INC;
  f += FRACT_INC;
     a4c:	9a 01       	movw	r18, r20
     a4e:	20 5d       	subi	r18, 0xD0	; 208
     a50:	3c 4f       	sbci	r19, 0xFC	; 252
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:155
  if (f >= FRACT_MAX) {
     a52:	28 3e       	cpi	r18, 0xE8	; 232
     a54:	63 e0       	ldi	r22, 0x03	; 3
     a56:	36 07       	cpc	r19, r22
     a58:	28 f0       	brcs	.+10     	; 0xa64 <__vector_15+0x4c>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:157

    f -= FRACT_MAX;
     a5a:	28 5e       	subi	r18, 0xE8	; 232
     a5c:	33 40       	sbci	r19, 0x03	; 3
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:158
    m += 1;
     a5e:	01 96       	adiw	r24, 0x01	; 1
     a60:	a1 1d       	adc	r26, r1
     a62:	b1 1d       	adc	r27, r1
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:160
  }
  timer_fract = f;
     a64:	20 93 40 38 	sts	0x3840, r18	; 0x803840 <timer_fract>
     a68:	30 93 41 38 	sts	0x3841, r19	; 0x803841 <timer_fract+0x1>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:161
  timer_millis = m;
     a6c:	80 93 42 38 	sts	0x3842, r24	; 0x803842 <timer_millis>
     a70:	90 93 43 38 	sts	0x3843, r25	; 0x803843 <timer_millis+0x1>
     a74:	a0 93 44 38 	sts	0x3844, r26	; 0x803844 <timer_millis+0x2>
     a78:	b0 93 45 38 	sts	0x3845, r27	; 0x803845 <timer_millis+0x3>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:164
  #endif
  //if RTC is used as timer, we only increment the overflow count
  timer_overflow_count++;
     a7c:	80 91 3c 38 	lds	r24, 0x383C	; 0x80383c <timer_overflow_count>
     a80:	90 91 3d 38 	lds	r25, 0x383D	; 0x80383d <timer_overflow_count+0x1>
     a84:	a0 91 3e 38 	lds	r26, 0x383E	; 0x80383e <timer_overflow_count+0x2>
     a88:	b0 91 3f 38 	lds	r27, 0x383F	; 0x80383f <timer_overflow_count+0x3>
     a8c:	01 96       	adiw	r24, 0x01	; 1
     a8e:	a1 1d       	adc	r26, r1
     a90:	b1 1d       	adc	r27, r1
     a92:	80 93 3c 38 	sts	0x383C, r24	; 0x80383c <timer_overflow_count>
     a96:	90 93 3d 38 	sts	0x383D, r25	; 0x80383d <timer_overflow_count+0x1>
     a9a:	a0 93 3e 38 	sts	0x383E, r26	; 0x80383e <timer_overflow_count+0x2>
     a9e:	b0 93 3f 38 	sts	0x383F, r27	; 0x80383f <timer_overflow_count+0x3>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:170
  #endif
  /* Clear flag */
  #if defined(MILLIS_USE_TIMERA0)
  TCA0.SPLIT.INTFLAGS = TCA_SPLIT_HUNF_bm;
  #elif defined(MILLIS_USE_TIMERD0)
  TCD0.INTFLAGS = TCD_OVF_bm;
     aa2:	81 e0       	ldi	r24, 0x01	; 1
     aa4:	80 93 8d 0a 	sts	0x0A8D, r24	; 0x800a8d <vtable for CmdBuffer<32u>+0x7f6caf>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:176
  #elif defined(MILLIS_USE_TIMERRTC)
  RTC.INTFLAGS = RTC_OVF_bm;
  #else //timerb
  _timer->INTFLAGS = TCB_CAPT_bm;
  #endif
}
     aa8:	bf 91       	pop	r27
     aaa:	af 91       	pop	r26
     aac:	9f 91       	pop	r25
     aae:	8f 91       	pop	r24
     ab0:	6f 91       	pop	r22
     ab2:	5f 91       	pop	r21
     ab4:	4f 91       	pop	r20
     ab6:	3f 91       	pop	r19
     ab8:	2f 91       	pop	r18
     aba:	0f 90       	pop	r0
     abc:	0f be       	out	0x3f, r0	; 63
     abe:	0f 90       	pop	r0
     ac0:	1f 90       	pop	r1
     ac2:	18 95       	reti

00000ac4 <__vector_24>:
__vector_24():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:818

ISR(TWI0_TWIM_vect) {
  TWI_MasterInterruptHandler();
}

ISR(TWI0_TWIS_vect) {
     ac4:	1f 92       	push	r1
     ac6:	0f 92       	push	r0
     ac8:	0f b6       	in	r0, 0x3f	; 63
     aca:	0f 92       	push	r0
     acc:	11 24       	eor	r1, r1
     ace:	2f 93       	push	r18
     ad0:	3f 93       	push	r19
     ad2:	4f 93       	push	r20
     ad4:	5f 93       	push	r21
     ad6:	6f 93       	push	r22
     ad8:	7f 93       	push	r23
     ada:	8f 93       	push	r24
     adc:	9f 93       	push	r25
     ade:	af 93       	push	r26
     ae0:	bf 93       	push	r27
     ae2:	cf 93       	push	r28
     ae4:	ef 93       	push	r30
     ae6:	ff 93       	push	r31
TWI_SlaveInterruptHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:581

    Check current status and calls the appropriate handler.

*/
void TWI_SlaveInterruptHandler() {
  uint8_t currentStatus = TWI0.SSTATUS;
     ae8:	c0 91 1b 08 	lds	r28, 0x081B	; 0x80081b <vtable for CmdBuffer<32u>+0x7f6a3d>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:584

  /* If bus error */
  if (currentStatus & TWI_BUSERR_bm) {
     aec:	c2 ff       	sbrs	r28, 2
     aee:	0a c0       	rjmp	.+20     	; 0xb04 <__vector_24+0x40>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:585
    slave_bytesRead = 0;
     af0:	10 92 3b 38 	sts	0x383B, r1	; 0x80383b <slave_bytesRead>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:586
    slave_bytesWritten = 0;
     af4:	10 92 3a 38 	sts	0x383A, r1	; 0x80383a <slave_bytesWritten>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:587
    slave_bytesToWrite = 0;
     af8:	10 92 39 38 	sts	0x3839, r1	; 0x803839 <slave_bytesToWrite>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:588
    TWI_SlaveTransactionFinished(TWIS_RESULT_BUS_ERROR);
     afc:	84 e0       	ldi	r24, 0x04	; 4
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:642
    }
  }

  /* If unexpected state */
  else {
    TWI_SlaveTransactionFinished(TWIS_RESULT_FAIL);
     afe:	0e 94 90 01 	call	0x320	; 0x320 <TWI_SlaveTransactionFinished>
     b02:	12 c0       	rjmp	.+36     	; 0xb28 <__vector_24+0x64>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:592
    slave_bytesToWrite = 0;
    TWI_SlaveTransactionFinished(TWIS_RESULT_BUS_ERROR);
  }

  /* If Address or Stop */
  else if (currentStatus & TWI_APIF_bm) {
     b04:	c6 ff       	sbrs	r28, 6
     b06:	2d c0       	rjmp	.+90     	; 0xb62 <__vector_24+0x9e>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:597

    /* Call user onReceive function if end of Master Write/Slave Read.
       This should be hit when there is a STOP or REPSTART
    */
    if (slave_callUserReceive == 1) {
     b08:	80 91 38 38 	lds	r24, 0x3838	; 0x803838 <slave_callUserReceive>
     b0c:	81 30       	cpi	r24, 0x01	; 1
     b0e:	41 f4       	brne	.+16     	; 0xb20 <__vector_24+0x5c>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:598
      TWI_onSlaveReceive(slave_bytesRead);
     b10:	80 91 3b 38 	lds	r24, 0x383B	; 0x80383b <slave_bytesRead>
     b14:	90 e0       	ldi	r25, 0x00	; 0
     b16:	f0 e0       	ldi	r31, 0x00	; 0
     b18:	e0 e0       	ldi	r30, 0x00	; 0
     b1a:	09 95       	icall
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:599
      slave_callUserReceive = 0;
     b1c:	10 92 38 38 	sts	0x3838, r1	; 0x803838 <slave_callUserReceive>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:603
    }

    /* If address match */
    if (currentStatus & TWI_AP_bm) {
     b20:	c0 ff       	sbrs	r28, 0
     b22:	14 c0       	rjmp	.+40     	; 0xb4c <__vector_24+0x88>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:604
      TWI_SlaveAddressMatchHandler();
     b24:	0e 94 9d 01 	call	0x33a	; 0x33a <TWI_SlaveAddressMatchHandler>
__vector_24():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:820
  TWI_MasterInterruptHandler();
}

ISR(TWI0_TWIS_vect) {
  TWI_SlaveInterruptHandler();
}
     b28:	ff 91       	pop	r31
     b2a:	ef 91       	pop	r30
     b2c:	cf 91       	pop	r28
     b2e:	bf 91       	pop	r27
     b30:	af 91       	pop	r26
     b32:	9f 91       	pop	r25
     b34:	8f 91       	pop	r24
     b36:	7f 91       	pop	r23
     b38:	6f 91       	pop	r22
     b3a:	5f 91       	pop	r21
     b3c:	4f 91       	pop	r20
     b3e:	3f 91       	pop	r19
     b40:	2f 91       	pop	r18
     b42:	0f 90       	pop	r0
     b44:	0f be       	out	0x3f, r0	; 63
     b46:	0f 90       	pop	r0
     b48:	1f 90       	pop	r1
     b4a:	18 95       	reti
TWI_SlaveStopHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:682

*/
void TWI_SlaveStopHandler() {

  /* Clear APIF, don't ACK or NACK */
  TWI0.SSTATUS = TWI_APIF_bm;
     b4c:	80 e4       	ldi	r24, 0x40	; 64
     b4e:	80 93 1b 08 	sts	0x081B, r24	; 0x80081b <vtable for CmdBuffer<32u>+0x7f6a3d>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:684

  TWI_SlaveTransactionFinished(TWIS_RESULT_OK);
     b52:	81 e0       	ldi	r24, 0x01	; 1
     b54:	0e 94 90 01 	call	0x320	; 0x320 <TWI_SlaveTransactionFinished>
TWI_SlaveInterruptHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:615

      /* If CLKHOLD is high, we have missed an address match
        from a fast start after stop.
        Because the flag is shared we need to handle this here.
      */
      if (TWI0.SSTATUS & TWI_CLKHOLD_bm) {
     b58:	80 91 1b 08 	lds	r24, 0x081B	; 0x80081b <vtable for CmdBuffer<32u>+0x7f6a3d>
     b5c:	85 ff       	sbrs	r24, 5
     b5e:	e4 cf       	rjmp	.-56     	; 0xb28 <__vector_24+0x64>
     b60:	e1 cf       	rjmp	.-62     	; 0xb24 <__vector_24+0x60>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:624
      }
    }
  }

  /* If Data Interrupt */
  else if (currentStatus & TWI_DIF_bm) {
     b62:	c7 ff       	sbrs	r28, 7
     b64:	50 c0       	rjmp	.+160    	; 0xc06 <__vector_24+0x142>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:627

    /* If collision flag is raised, slave transmit unsuccessful */
    if (currentStatus & TWI_COLL_bm) {
     b66:	c3 ff       	sbrs	r28, 3
     b68:	08 c0       	rjmp	.+16     	; 0xb7a <__vector_24+0xb6>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:628
      slave_bytesRead = 0;
     b6a:	10 92 3b 38 	sts	0x383B, r1	; 0x80383b <slave_bytesRead>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:629
      slave_bytesWritten = 0;
     b6e:	10 92 3a 38 	sts	0x383A, r1	; 0x80383a <slave_bytesWritten>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:630
      slave_bytesToWrite = 0;
     b72:	10 92 39 38 	sts	0x3839, r1	; 0x803839 <slave_bytesToWrite>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:631
      TWI_SlaveTransactionFinished(TWIS_RESULT_TRANSMIT_COLLISION);
     b76:	83 e0       	ldi	r24, 0x03	; 3
     b78:	c2 cf       	rjmp	.-124    	; 0xafe <__vector_24+0x3a>
TWI_SlaveDataHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:697

*/
void TWI_SlaveDataHandler() {

  /* Enable stop interrupt */
  TWI0.SCTRLA |= (TWI_APIEN_bm | TWI_PIEN_bm);
     b7a:	80 91 19 08 	lds	r24, 0x0819	; 0x800819 <vtable for CmdBuffer<32u>+0x7f6a3b>
     b7e:	80 66       	ori	r24, 0x60	; 96
     b80:	80 93 19 08 	sts	0x0819, r24	; 0x800819 <vtable for CmdBuffer<32u>+0x7f6a3b>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:700

  /* If Master Read/Slave Write */
  if (TWI0.SSTATUS & TWI_DIR_bm) {
     b84:	80 91 1b 08 	lds	r24, 0x081B	; 0x80081b <vtable for CmdBuffer<32u>+0x7f6a3d>
     b88:	81 ff       	sbrs	r24, 1
     b8a:	26 c0       	rjmp	.+76     	; 0xbd8 <__vector_24+0x114>
TWI_SlaveWriteHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:721

*/
void TWI_SlaveWriteHandler() {

  /* If NACK, slave write transaction finished */
  if ((slave_bytesWritten > 0) && (TWI0.SSTATUS & TWI_RXACK_bm)) {
     b8c:	80 91 3a 38 	lds	r24, 0x383A	; 0x80383a <slave_bytesWritten>
     b90:	88 23       	and	r24, r24
     b92:	49 f0       	breq	.+18     	; 0xba6 <__vector_24+0xe2>
     b94:	80 91 1b 08 	lds	r24, 0x081B	; 0x80081b <vtable for CmdBuffer<32u>+0x7f6a3d>
     b98:	84 ff       	sbrs	r24, 4
     b9a:	05 c0       	rjmp	.+10     	; 0xba6 <__vector_24+0xe2>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:723

    TWI0.SCTRLB = TWI_SCMD_COMPTRANS_gc;
     b9c:	82 e0       	ldi	r24, 0x02	; 2
     b9e:	80 93 1a 08 	sts	0x081A, r24	; 0x80081a <vtable for CmdBuffer<32u>+0x7f6a3c>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:724
    TWI_SlaveTransactionFinished(TWIS_RESULT_OK);
     ba2:	81 e0       	ldi	r24, 0x01	; 1
     ba4:	ac cf       	rjmp	.-168    	; 0xafe <__vector_24+0x3a>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:730
  }

  /* If ACK, master expects more data */
  else {

    if (slave_bytesWritten < slave_bytesToWrite) {
     ba6:	90 91 3a 38 	lds	r25, 0x383A	; 0x80383a <slave_bytesWritten>
     baa:	80 91 39 38 	lds	r24, 0x3839	; 0x803839 <slave_bytesToWrite>
     bae:	98 17       	cp	r25, r24
     bb0:	78 f4       	brcc	.+30     	; 0xbd0 <__vector_24+0x10c>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:731
      uint8_t data = slave_writeData[slave_bytesWritten];
     bb2:	e0 91 3a 38 	lds	r30, 0x383A	; 0x80383a <slave_bytesWritten>
     bb6:	f0 e0       	ldi	r31, 0x00	; 0
     bb8:	80 81       	ld	r24, Z
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:732
      TWI0.SDATA = data;
     bba:	80 93 1d 08 	sts	0x081D, r24	; 0x80081d <vtable for CmdBuffer<32u>+0x7f6a3f>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:733
      slave_bytesWritten++;
     bbe:	80 91 3a 38 	lds	r24, 0x383A	; 0x80383a <slave_bytesWritten>
     bc2:	8f 5f       	subi	r24, 0xFF	; 255
     bc4:	80 93 3a 38 	sts	0x383A, r24	; 0x80383a <slave_bytesWritten>
TWI_SlaveReadHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:767
    uint8_t data = TWI0.SDATA;
    slave_readData[slave_bytesRead] = data;
    slave_bytesRead++;

    /* Send ACK and wait for data interrupt */
    TWI0.SCTRLB = TWI_SCMD_RESPONSE_gc;
     bc8:	83 e0       	ldi	r24, 0x03	; 3
     bca:	80 93 1a 08 	sts	0x081A, r24	; 0x80081a <vtable for CmdBuffer<32u>+0x7f6a3c>
     bce:	ac cf       	rjmp	.-168    	; 0xb28 <__vector_24+0x64>
TWI_SlaveWriteHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:742

    }

    /* If buffer overflow */
    else {
      TWI0.SCTRLB = TWI_SCMD_COMPTRANS_gc;
     bd0:	82 e0       	ldi	r24, 0x02	; 2
     bd2:	80 93 1a 08 	sts	0x081A, r24	; 0x80081a <vtable for CmdBuffer<32u>+0x7f6a3c>
     bd6:	93 cf       	rjmp	.-218    	; 0xafe <__vector_24+0x3a>
TWI_SlaveReadHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:759

*/
void TWI_SlaveReadHandler() {

  /* If free space in buffer */
  if (slave_bytesRead < slave_bytesToRead) {
     bd8:	90 91 3b 38 	lds	r25, 0x383B	; 0x80383b <slave_bytesRead>
     bdc:	80 91 37 38 	lds	r24, 0x3837	; 0x803837 <slave_bytesToRead>
     be0:	98 17       	cp	r25, r24
     be2:	60 f4       	brcc	.+24     	; 0xbfc <__vector_24+0x138>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:762

    /* Fetch data */
    uint8_t data = TWI0.SDATA;
     be4:	80 91 1d 08 	lds	r24, 0x081D	; 0x80081d <vtable for CmdBuffer<32u>+0x7f6a3f>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:763
    slave_readData[slave_bytesRead] = data;
     be8:	e0 91 3b 38 	lds	r30, 0x383B	; 0x80383b <slave_bytesRead>
     bec:	f0 e0       	ldi	r31, 0x00	; 0
     bee:	80 83       	st	Z, r24
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:764
    slave_bytesRead++;
     bf0:	80 91 3b 38 	lds	r24, 0x383B	; 0x80383b <slave_bytesRead>
     bf4:	8f 5f       	subi	r24, 0xFF	; 255
     bf6:	80 93 3b 38 	sts	0x383B, r24	; 0x80383b <slave_bytesRead>
     bfa:	e6 cf       	rjmp	.-52     	; 0xbc8 <__vector_24+0x104>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:772
    TWI0.SCTRLB = TWI_SCMD_RESPONSE_gc;
  }
  /* If buffer overflow, send NACK and wait for next START.
    Set result buffer overflow */
  else {
    TWI0.SCTRLB = TWI_ACKACT_bm | TWI_SCMD_COMPTRANS_gc;
     bfc:	86 e0       	ldi	r24, 0x06	; 6
     bfe:	80 93 1a 08 	sts	0x081A, r24	; 0x80081a <vtable for CmdBuffer<32u>+0x7f6a3c>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:773
    TWI_SlaveTransactionFinished(TWIS_RESULT_BUFFER_OVERFLOW);
     c02:	82 e0       	ldi	r24, 0x02	; 2
     c04:	7c cf       	rjmp	.-264    	; 0xafe <__vector_24+0x3a>
TWI_SlaveInterruptHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:642
    }
  }

  /* If unexpected state */
  else {
    TWI_SlaveTransactionFinished(TWIS_RESULT_FAIL);
     c06:	85 e0       	ldi	r24, 0x05	; 5
     c08:	7a cf       	rjmp	.-268    	; 0xafe <__vector_24+0x3a>

00000c0a <__vector_25>:
__vector_25():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:814
  twi_mode = TWI_MODE_SLAVE;
  slave_result = result;
  slave_trans_status = TWIM_STATUS_READY;
}

ISR(TWI0_TWIM_vect) {
     c0a:	1f 92       	push	r1
     c0c:	0f 92       	push	r0
     c0e:	0f b6       	in	r0, 0x3f	; 63
     c10:	0f 92       	push	r0
     c12:	11 24       	eor	r1, r1
     c14:	2f 93       	push	r18
     c16:	3f 93       	push	r19
     c18:	8f 93       	push	r24
     c1a:	9f 93       	push	r25
     c1c:	ef 93       	push	r30
     c1e:	ff 93       	push	r31
TWI_MasterInterruptHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:413

    Check current status and calls the appropriate handler.

*/
void TWI_MasterInterruptHandler() {
  uint8_t currentStatus = TWI0.MSTATUS;
     c20:	80 91 15 08 	lds	r24, 0x0815	; 0x800815 <vtable for CmdBuffer<32u>+0x7f6a37>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:416

  /* If arbitration lost or bus error. */
  if ((currentStatus & TWI_ARBLOST_bm) ||
     c24:	98 2f       	mov	r25, r24
     c26:	9c 70       	andi	r25, 0x0C	; 12
     c28:	c9 f0       	breq	.+50     	; 0xc5c <__vector_25+0x52>
TWI_MasterArbitrationLostBusErrorHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:444

    Handles TWI responses to lost arbitration and bus error.

*/
void TWI_MasterArbitrationLostBusErrorHandler() {
  uint8_t currentStatus = TWI0.MSTATUS;
     c2a:	80 91 15 08 	lds	r24, 0x0815	; 0x800815 <vtable for CmdBuffer<32u>+0x7f6a37>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:448

  /* If bus error. */
  if (currentStatus & TWI_BUSERR_bm) {
    master_result = TWIM_RESULT_BUS_ERROR;
     c2e:	94 e0       	ldi	r25, 0x04	; 4
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:447
*/
void TWI_MasterArbitrationLostBusErrorHandler() {
  uint8_t currentStatus = TWI0.MSTATUS;

  /* If bus error. */
  if (currentStatus & TWI_BUSERR_bm) {
     c30:	82 ff       	sbrs	r24, 2
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:452
    master_result = TWIM_RESULT_BUS_ERROR;
  }
  /* If arbitration lost. */
  else {
    master_result = TWIM_RESULT_ARBITRATION_LOST;
     c32:	93 e0       	ldi	r25, 0x03	; 3
     c34:	90 93 46 38 	sts	0x3846, r25	; 0x803846 <master_result>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:456
  }

  /* Clear all flags, abort operation */
  TWI0.MSTATUS = currentStatus;
     c38:	80 93 15 08 	sts	0x0815, r24	; 0x800815 <vtable for CmdBuffer<32u>+0x7f6a37>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:459

  /* Wait for a new operation */
  twi_mode = TWI_MODE_MASTER;
     c3c:	81 e0       	ldi	r24, 0x01	; 1
     c3e:	80 93 4a 38 	sts	0x384A, r24	; 0x80384a <twi_mode>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:460
  master_trans_status = TWIM_STATUS_READY;
     c42:	10 92 47 38 	sts	0x3847, r1	; 0x803847 <master_trans_status>
__vector_25():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:816
  slave_trans_status = TWIM_STATUS_READY;
}

ISR(TWI0_TWIM_vect) {
  TWI_MasterInterruptHandler();
}
     c46:	ff 91       	pop	r31
     c48:	ef 91       	pop	r30
     c4a:	9f 91       	pop	r25
     c4c:	8f 91       	pop	r24
     c4e:	3f 91       	pop	r19
     c50:	2f 91       	pop	r18
     c52:	0f 90       	pop	r0
     c54:	0f be       	out	0x3f, r0	; 63
     c56:	0f 90       	pop	r0
     c58:	1f 90       	pop	r1
     c5a:	18 95       	reti
TWI_MasterInterruptHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:423

    TWI_MasterArbitrationLostBusErrorHandler();
  }

  /* If master write interrupt. */
  else if (currentStatus & TWI_WIF_bm) {
     c5c:	86 ff       	sbrs	r24, 6
     c5e:	4c c0       	rjmp	.+152    	; 0xcf8 <__vector_25+0xee>
TWI_MasterWriteHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:471
    Handles TWI transactions (master write) and responses to (N)ACK.

*/
void TWI_MasterWriteHandler() {
  /* Local variables used in if tests to avoid compiler warning. */
  uint8_t bytesToWrite  = master_bytesToWrite;
     c60:	20 91 34 38 	lds	r18, 0x3834	; 0x803834 <master_bytesToWrite>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:472
  uint8_t bytesToRead   = master_bytesToRead;
     c64:	90 91 36 38 	lds	r25, 0x3836	; 0x803836 <master_bytesToRead>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:475

  /* If NOT acknowledged (NACK) by slave cancel the transaction. */
  if (TWI0.MSTATUS & TWI_RXACK_bm) {
     c68:	80 91 15 08 	lds	r24, 0x0815	; 0x800815 <vtable for CmdBuffer<32u>+0x7f6a37>
     c6c:	84 ff       	sbrs	r24, 4
     c6e:	10 c0       	rjmp	.+32     	; 0xc90 <__vector_25+0x86>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:476
    if (master_sendStop) {
     c70:	80 91 35 38 	lds	r24, 0x3835	; 0x803835 <master_sendStop>
     c74:	88 23       	and	r24, r24
     c76:	51 f0       	breq	.+20     	; 0xc8c <__vector_25+0x82>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:477
      TWI0.MCTRLB = TWI_MCMD_STOP_gc;
     c78:	83 e0       	ldi	r24, 0x03	; 3
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:479
    } else {
      TWI0.MCTRLB = TWI_MCMD_REPSTART_gc;
     c7a:	80 93 14 08 	sts	0x0814, r24	; 0x800814 <vtable for CmdBuffer<32u>+0x7f6a36>
TWI_MasterTransactionFinished():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:569
    Prepares module for new transaction.

    \param result  The result of the operation.
*/
void TWI_MasterTransactionFinished(uint8_t result) {
  master_result = result;
     c7e:	85 e0       	ldi	r24, 0x05	; 5
     c80:	80 93 46 38 	sts	0x3846, r24	; 0x803846 <master_result>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:570
  master_trans_status = TWIM_STATUS_READY;
     c84:	10 92 47 38 	sts	0x3847, r1	; 0x803847 <master_trans_status>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:571
  twi_mode = TWI_MODE_MASTER;
     c88:	81 e0       	ldi	r24, 0x01	; 1
     c8a:	31 c0       	rjmp	.+98     	; 0xcee <__vector_25+0xe4>
TWI_MasterWriteHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:479
  /* If NOT acknowledged (NACK) by slave cancel the transaction. */
  if (TWI0.MSTATUS & TWI_RXACK_bm) {
    if (master_sendStop) {
      TWI0.MCTRLB = TWI_MCMD_STOP_gc;
    } else {
      TWI0.MCTRLB = TWI_MCMD_REPSTART_gc;
     c8c:	81 e0       	ldi	r24, 0x01	; 1
     c8e:	f5 cf       	rjmp	.-22     	; 0xc7a <__vector_25+0x70>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:486
    }
    TWI_MasterTransactionFinished(TWIM_RESULT_NACK_RECEIVED);
  }

  /* If more bytes to write, send data. */
  else if (master_bytesWritten < bytesToWrite) {
     c90:	80 91 48 38 	lds	r24, 0x3848	; 0x803848 <master_bytesWritten>
     c94:	82 17       	cp	r24, r18
     c96:	90 f4       	brcc	.+36     	; 0xcbc <__vector_25+0xb2>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:487
    uint8_t data = master_writeData[master_bytesWritten];
     c98:	e0 91 48 38 	lds	r30, 0x3848	; 0x803848 <master_bytesWritten>
     c9c:	80 91 32 38 	lds	r24, 0x3832	; 0x803832 <master_writeData>
     ca0:	90 91 33 38 	lds	r25, 0x3833	; 0x803833 <master_writeData+0x1>
     ca4:	e8 0f       	add	r30, r24
     ca6:	f9 2f       	mov	r31, r25
     ca8:	f1 1d       	adc	r31, r1
     caa:	80 81       	ld	r24, Z
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:488
    TWI0.MDATA = data;
     cac:	80 93 18 08 	sts	0x0818, r24	; 0x800818 <vtable for CmdBuffer<32u>+0x7f6a3a>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:489
    master_bytesWritten++;
     cb0:	80 91 48 38 	lds	r24, 0x3848	; 0x803848 <master_bytesWritten>
     cb4:	8f 5f       	subi	r24, 0xFF	; 255
     cb6:	80 93 48 38 	sts	0x3848, r24	; 0x803848 <master_bytesWritten>
     cba:	c5 cf       	rjmp	.-118    	; 0xc46 <__vector_25+0x3c>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:495
  }

  /* If bytes to read, send START condition + Address +
     'R/_W = 1'
  */
  else if (master_bytesRead < bytesToRead) {
     cbc:	80 91 49 38 	lds	r24, 0x3849	; 0x803849 <master_bytesRead>
     cc0:	89 17       	cp	r24, r25
     cc2:	48 f4       	brcc	.+18     	; 0xcd6 <__vector_25+0xcc>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:496
    twi_mode = TWI_MODE_MASTER_RECEIVE;
     cc4:	84 e0       	ldi	r24, 0x04	; 4
     cc6:	80 93 4a 38 	sts	0x384A, r24	; 0x80384a <twi_mode>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:497
    uint8_t readAddress = ADD_READ_BIT(master_slaveAddress);
     cca:	80 91 31 38 	lds	r24, 0x3831	; 0x803831 <master_slaveAddress>
     cce:	81 60       	ori	r24, 0x01	; 1
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:498
    TWI0.MADDR = readAddress;
     cd0:	80 93 17 08 	sts	0x0817, r24	; 0x800817 <vtable for CmdBuffer<32u>+0x7f6a39>
     cd4:	b8 cf       	rjmp	.-144    	; 0xc46 <__vector_25+0x3c>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:503
  }

  /* If transaction finished, send ACK/STOP condition if instructed and set RESULT OK. */
  else {
    if (master_sendStop) {
     cd6:	80 91 35 38 	lds	r24, 0x3835	; 0x803835 <master_sendStop>
     cda:	88 23       	and	r24, r24
     cdc:	59 f0       	breq	.+22     	; 0xcf4 <__vector_25+0xea>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:504
      TWI0.MCTRLB = TWI_MCMD_STOP_gc;
     cde:	83 e0       	ldi	r24, 0x03	; 3
TWI_MasterReadHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:554
  /* If transaction finished, issue NACK and STOP condition if instructed. */
  else {
    if (master_sendStop) {
      TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_STOP_gc;
    } else {
      TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_REPSTART_gc;
     ce0:	80 93 14 08 	sts	0x0814, r24	; 0x800814 <vtable for CmdBuffer<32u>+0x7f6a36>
TWI_MasterTransactionFinished():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:569
    Prepares module for new transaction.

    \param result  The result of the operation.
*/
void TWI_MasterTransactionFinished(uint8_t result) {
  master_result = result;
     ce4:	81 e0       	ldi	r24, 0x01	; 1
     ce6:	80 93 46 38 	sts	0x3846, r24	; 0x803846 <master_result>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:570
  master_trans_status = TWIM_STATUS_READY;
     cea:	10 92 47 38 	sts	0x3847, r1	; 0x803847 <master_trans_status>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:571
  twi_mode = TWI_MODE_MASTER;
     cee:	80 93 4a 38 	sts	0x384A, r24	; 0x80384a <twi_mode>
     cf2:	a9 cf       	rjmp	.-174    	; 0xc46 <__vector_25+0x3c>
TWI_MasterWriteHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:506
  /* If transaction finished, send ACK/STOP condition if instructed and set RESULT OK. */
  else {
    if (master_sendStop) {
      TWI0.MCTRLB = TWI_MCMD_STOP_gc;
    } else {
      TWI0.MCTRLB = TWI_MCMD_REPSTART_gc;
     cf4:	81 e0       	ldi	r24, 0x01	; 1
     cf6:	f4 cf       	rjmp	.-24     	; 0xce0 <__vector_25+0xd6>
TWI_MasterInterruptHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:428
  else if (currentStatus & TWI_WIF_bm) {
    TWI_MasterWriteHandler();
  }

  /* If master read interrupt. */
  else if (currentStatus & TWI_RIF_bm) {
     cf8:	87 ff       	sbrs	r24, 7
     cfa:	3d c0       	rjmp	.+122    	; 0xd76 <__vector_25+0x16c>
TWI_MasterReadHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:522

    \param twi The TWI_Master_t struct instance.
*/
void TWI_MasterReadHandler() {
  /* Fetch data if bytes to be read. */
  if (master_bytesRead < master_bytesToRead) {
     cfc:	90 91 49 38 	lds	r25, 0x3849	; 0x803849 <master_bytesRead>
     d00:	80 91 36 38 	lds	r24, 0x3836	; 0x803836 <master_bytesToRead>
     d04:	98 17       	cp	r25, r24
     d06:	d8 f4       	brcc	.+54     	; 0xd3e <__vector_25+0x134>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:523
    uint8_t data = TWI0.MDATA;
     d08:	80 91 18 08 	lds	r24, 0x0818	; 0x800818 <vtable for CmdBuffer<32u>+0x7f6a3a>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:524
    master_readData[master_bytesRead] = data;
     d0c:	e0 91 49 38 	lds	r30, 0x3849	; 0x803849 <master_bytesRead>
     d10:	20 91 4b 38 	lds	r18, 0x384B	; 0x80384b <master_readData>
     d14:	30 91 4c 38 	lds	r19, 0x384C	; 0x80384c <master_readData+0x1>
     d18:	e2 0f       	add	r30, r18
     d1a:	f3 2f       	mov	r31, r19
     d1c:	f1 1d       	adc	r31, r1
     d1e:	80 83       	st	Z, r24
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:525
    master_bytesRead++;
     d20:	80 91 49 38 	lds	r24, 0x3849	; 0x803849 <master_bytesRead>
     d24:	8f 5f       	subi	r24, 0xFF	; 255
     d26:	80 93 49 38 	sts	0x3849, r24	; 0x803849 <master_bytesRead>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:542
    master_bytesToRead = 0;
    return;
  }

  /* Local variable used in if test to avoid compiler warning. */
  uint8_t bytesToRead = master_bytesToRead;
     d2a:	90 91 36 38 	lds	r25, 0x3836	; 0x803836 <master_bytesToRead>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:545

  /* If more bytes to read, issue ACK and start a byte read. */
  if (master_bytesRead < bytesToRead) {
     d2e:	80 91 49 38 	lds	r24, 0x3849	; 0x803849 <master_bytesRead>
     d32:	89 17       	cp	r24, r25
     d34:	c0 f4       	brcc	.+48     	; 0xd66 <__vector_25+0x15c>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:546
    TWI0.MCTRLB = TWI_MCMD_RECVTRANS_gc;
     d36:	82 e0       	ldi	r24, 0x02	; 2
     d38:	80 93 14 08 	sts	0x0814, r24	; 0x800814 <vtable for CmdBuffer<32u>+0x7f6a36>
     d3c:	84 cf       	rjmp	.-248    	; 0xc46 <__vector_25+0x3c>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:530
    master_bytesRead++;
  }

  /* If buffer overflow, issue NACK/STOP and BUFFER_OVERFLOW condition. */
  else {
    if (master_sendStop) {
     d3e:	80 91 35 38 	lds	r24, 0x3835	; 0x803835 <master_sendStop>
     d42:	88 23       	and	r24, r24
     d44:	71 f0       	breq	.+28     	; 0xd62 <__vector_25+0x158>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:531
      TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_STOP_gc;
     d46:	87 e0       	ldi	r24, 0x07	; 7
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:533
    } else {
      TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_REPSTART_gc;
     d48:	80 93 14 08 	sts	0x0814, r24	; 0x800814 <vtable for CmdBuffer<32u>+0x7f6a36>
TWI_MasterTransactionFinished():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:569
    Prepares module for new transaction.

    \param result  The result of the operation.
*/
void TWI_MasterTransactionFinished(uint8_t result) {
  master_result = result;
     d4c:	82 e0       	ldi	r24, 0x02	; 2
     d4e:	80 93 46 38 	sts	0x3846, r24	; 0x803846 <master_result>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:570
  master_trans_status = TWIM_STATUS_READY;
     d52:	10 92 47 38 	sts	0x3847, r1	; 0x803847 <master_trans_status>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:571
  twi_mode = TWI_MODE_MASTER;
     d56:	81 e0       	ldi	r24, 0x01	; 1
     d58:	80 93 4a 38 	sts	0x384A, r24	; 0x80384a <twi_mode>
TWI_MasterReadHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:537
    } else {
      TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_REPSTART_gc;
    }

    TWI_MasterTransactionFinished(TWIM_RESULT_BUFFER_OVERFLOW);
    master_bytesToRead = 0;
     d5c:	10 92 36 38 	sts	0x3836, r1	; 0x803836 <master_bytesToRead>
     d60:	72 cf       	rjmp	.-284    	; 0xc46 <__vector_25+0x3c>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:533
  /* If buffer overflow, issue NACK/STOP and BUFFER_OVERFLOW condition. */
  else {
    if (master_sendStop) {
      TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_STOP_gc;
    } else {
      TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_REPSTART_gc;
     d62:	85 e0       	ldi	r24, 0x05	; 5
     d64:	f1 cf       	rjmp	.-30     	; 0xd48 <__vector_25+0x13e>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:551
    TWI0.MCTRLB = TWI_MCMD_RECVTRANS_gc;
  }

  /* If transaction finished, issue NACK and STOP condition if instructed. */
  else {
    if (master_sendStop) {
     d66:	80 91 35 38 	lds	r24, 0x3835	; 0x803835 <master_sendStop>
     d6a:	88 23       	and	r24, r24
     d6c:	11 f0       	breq	.+4      	; 0xd72 <__vector_25+0x168>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:552
      TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_STOP_gc;
     d6e:	87 e0       	ldi	r24, 0x07	; 7
     d70:	b7 cf       	rjmp	.-146    	; 0xce0 <__vector_25+0xd6>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:554
    } else {
      TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_REPSTART_gc;
     d72:	85 e0       	ldi	r24, 0x05	; 5
     d74:	b5 cf       	rjmp	.-150    	; 0xce0 <__vector_25+0xd6>
TWI_MasterTransactionFinished():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:569
    Prepares module for new transaction.

    \param result  The result of the operation.
*/
void TWI_MasterTransactionFinished(uint8_t result) {
  master_result = result;
     d76:	86 e0       	ldi	r24, 0x06	; 6
     d78:	83 cf       	rjmp	.-250    	; 0xc80 <__vector_25+0x76>

00000d7a <__vector_3>:
__vector_3():
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:126

    // The interrupt flag has to be cleared manually
    TCA0.SINGLE.INTFLAGS = TCA_SINGLE_OVF_bm;
}

ISR(PORTA_PORT_vect) {
     d7a:	1f 92       	push	r1
     d7c:	0f 92       	push	r0
     d7e:	0f b6       	in	r0, 0x3f	; 63
     d80:	0f 92       	push	r0
     d82:	11 24       	eor	r1, r1
     d84:	2f 93       	push	r18
     d86:	3f 93       	push	r19
     d88:	4f 93       	push	r20
     d8a:	5f 93       	push	r21
     d8c:	6f 93       	push	r22
     d8e:	7f 93       	push	r23
     d90:	8f 93       	push	r24
     d92:	9f 93       	push	r25
     d94:	af 93       	push	r26
     d96:	bf 93       	push	r27
     d98:	ef 93       	push	r30
     d9a:	ff 93       	push	r31
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:127
    byte flags = PORTA.INTFLAGS;
     d9c:	80 91 09 04 	lds	r24, 0x0409	; 0x800409 <vtable for CmdBuffer<32u>+0x7f662b>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:128
    PORTA.INTFLAGS = flags; //clear flags
     da0:	80 93 09 04 	sts	0x0409, r24	; 0x800409 <vtable for CmdBuffer<32u>+0x7f662b>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:130

    if (digitalRead(CHANGE_PIN) == HIGH) {
     da4:	0e 94 f2 03 	call	0x7e4	; 0x7e4 <digitalRead.constprop.3>
     da8:	81 30       	cpi	r24, 0x01	; 1
     daa:	11 f4       	brne	.+4      	; 0xdb0 <__vector_3+0x36>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:131
        touchChanged = true;
     dac:	80 93 66 39 	sts	0x3966, r24	; 0x803966 <touchChanged>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:133
    }
}
     db0:	ff 91       	pop	r31
     db2:	ef 91       	pop	r30
     db4:	bf 91       	pop	r27
     db6:	af 91       	pop	r26
     db8:	9f 91       	pop	r25
     dba:	8f 91       	pop	r24
     dbc:	7f 91       	pop	r23
     dbe:	6f 91       	pop	r22
     dc0:	5f 91       	pop	r21
     dc2:	4f 91       	pop	r20
     dc4:	3f 91       	pop	r19
     dc6:	2f 91       	pop	r18
     dc8:	0f 90       	pop	r0
     dca:	0f be       	out	0x3f, r0	; 63
     dcc:	0f 90       	pop	r0
     dce:	1f 90       	pop	r1
     dd0:	18 95       	reti

00000dd2 <__vector_8>:
__vector_8():
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:100
    }

    sei(); // in case either if up top was false
}

ISR(TCA0_OVF_vect) {
     dd2:	1f 92       	push	r1
     dd4:	0f 92       	push	r0
     dd6:	0f b6       	in	r0, 0x3f	; 63
     dd8:	0f 92       	push	r0
     dda:	11 24       	eor	r1, r1
     ddc:	cf 92       	push	r12
     dde:	df 92       	push	r13
     de0:	ef 92       	push	r14
     de2:	ff 92       	push	r15
     de4:	0f 93       	push	r16
     de6:	1f 93       	push	r17
     de8:	2f 93       	push	r18
     dea:	3f 93       	push	r19
     dec:	4f 93       	push	r20
     dee:	5f 93       	push	r21
     df0:	6f 93       	push	r22
     df2:	7f 93       	push	r23
     df4:	8f 93       	push	r24
     df6:	9f 93       	push	r25
     df8:	af 93       	push	r26
     dfa:	bf 93       	push	r27
     dfc:	ef 93       	push	r30
     dfe:	ff 93       	push	r31
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:104

    //digitalWriteFast(LED_PIN, true);

    ++tick;
     e00:	80 91 2b 38 	lds	r24, 0x382B	; 0x80382b <tick>
     e04:	90 91 2c 38 	lds	r25, 0x382C	; 0x80382c <tick+0x1>
     e08:	a0 91 2d 38 	lds	r26, 0x382D	; 0x80382d <tick+0x2>
     e0c:	b0 91 2e 38 	lds	r27, 0x382E	; 0x80382e <tick+0x3>
     e10:	01 96       	adiw	r24, 0x01	; 1
     e12:	a1 1d       	adc	r26, r1
     e14:	b1 1d       	adc	r27, r1
     e16:	80 93 2b 38 	sts	0x382B, r24	; 0x80382b <tick>
     e1a:	90 93 2c 38 	sts	0x382C, r25	; 0x80382c <tick+0x1>
     e1e:	a0 93 2d 38 	sts	0x382D, r26	; 0x80382d <tick+0x2>
     e22:	b0 93 2e 38 	sts	0x382E, r27	; 0x80382e <tick+0x3>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:106

    if (isPlaying) {
     e26:	80 91 65 39 	lds	r24, 0x3965	; 0x803965 <isPlaying>
     e2a:	88 23       	and	r24, r24
     e2c:	d9 f1       	breq	.+118    	; 0xea4 <__vector_8+0xd2>
digitalWriteFast():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:294
    vport->OUT &= ~mask;
  else // CHANGE
    vport->IN = mask;
*/
  if (val == LOW)
    vport->OUT &= ~mask;
     e2e:	0d 98       	cbi	0x01, 5	; 1
__vector_8():
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:115
        goToSleep = true; // this is so the main loop can put the chip to sleep after this interrupt ran
        digitalWriteFast(SHUTDOWN_PIN, true); // off before next sample
    }

    // write the previously calculated sample first so the timing is reliable no matter how long it takes to calculate the next sample
    analogWrite(DAC_PIN, sample);
     e30:	10 91 00 38 	lds	r17, 0x3800	; 0x803800 <__DATA_REGION_ORIGIN__>
analogWrite():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_analog.c:217
  uint8_t bit_mask  = digitalPinToBitMask(pin);
  if (bit_mask == NOT_A_PIN) {
    return;
  }
  // Set pin output because that's what Arduino does
  pinMode(pin, OUTPUT);
     e34:	61 e0       	ldi	r22, 0x01	; 1
     e36:	82 e0       	ldi	r24, 0x02	; 2
     e38:	0e 94 f8 03 	call	0x7f0	; 0x7f0 <pinMode>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_analog.c:263
      // End of TCA case

  #if defined(DAC0)
    case DACOUT:
    {
      DAC0.DATA = val;
     e3c:	10 93 a1 06 	sts	0x06A1, r17	; 0x8006a1 <vtable for CmdBuffer<32u>+0x7f68c3>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_analog.c:264
      DAC0.CTRLA = 0x41; //OUTEN=1, ENABLE=1
     e40:	81 e4       	ldi	r24, 0x41	; 65
     e42:	80 93 a0 06 	sts	0x06A0, r24	; 0x8006a0 <vtable for CmdBuffer<32u>+0x7f68c2>
nextSample():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:51

uint8_t nextSample(){

    uint16_t sample = 0;

    if (isPlaying) {
     e46:	80 91 65 39 	lds	r24, 0x3965	; 0x803965 <isPlaying>
     e4a:	88 23       	and	r24, r24
     e4c:	49 f1       	breq	.+82     	; 0xea0 <__vector_8+0xce>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:58
            if (oscillators[0].phase < oscillators[0].jump && i == 1 && syncOscillators) {
                // sync the second oscillator to the first one if oscillator sync is enabled and the first oscillator just wrapped
                oscillators[1].phase = oscillators[0].phase;
            }
            else {
                oscillators[i].phase += oscillators[i].jump;
     e4e:	40 91 07 38 	lds	r20, 0x3807	; 0x803807 <oscillators+0x6>
     e52:	50 91 08 38 	lds	r21, 0x3808	; 0x803808 <oscillators+0x7>
     e56:	60 91 09 38 	lds	r22, 0x3809	; 0x803809 <oscillators+0x8>
     e5a:	70 91 0a 38 	lds	r23, 0x380A	; 0x80380a <oscillators+0x9>
     e5e:	80 91 03 38 	lds	r24, 0x3803	; 0x803803 <oscillators+0x2>
     e62:	90 91 04 38 	lds	r25, 0x3804	; 0x803804 <oscillators+0x3>
     e66:	a0 91 05 38 	lds	r26, 0x3805	; 0x803805 <oscillators+0x4>
     e6a:	b0 91 06 38 	lds	r27, 0x3806	; 0x803806 <oscillators+0x5>
     e6e:	84 0f       	add	r24, r20
     e70:	95 1f       	adc	r25, r21
     e72:	a6 1f       	adc	r26, r22
     e74:	b7 1f       	adc	r27, r23
     e76:	80 93 07 38 	sts	0x3807, r24	; 0x803807 <oscillators+0x6>
     e7a:	90 93 08 38 	sts	0x3808, r25	; 0x803808 <oscillators+0x7>
     e7e:	a0 93 09 38 	sts	0x3809, r26	; 0x803809 <oscillators+0x8>
     e82:	b0 93 0a 38 	sts	0x380A, r27	; 0x80380a <oscillators+0x9>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:61
            }

            switch (oscillators[i].waveform) {
     e86:	20 91 01 38 	lds	r18, 0x3801	; 0x803801 <oscillators>
     e8a:	30 91 02 38 	lds	r19, 0x3802	; 0x803802 <oscillators+0x1>
     e8e:	21 30       	cpi	r18, 0x01	; 1
     e90:	31 05       	cpc	r19, r1
     e92:	09 f4       	brne	.+2      	; 0xe96 <__vector_8+0xc4>
     e94:	75 c0       	rjmp	.+234    	; 0xf80 <__vector_8+0x1ae>
     e96:	58 f0       	brcs	.+22     	; 0xeae <__vector_8+0xdc>
     e98:	22 30       	cpi	r18, 0x02	; 2
     e9a:	31 05       	cpc	r19, r1
     e9c:	09 f4       	brne	.+2      	; 0xea0 <__vector_8+0xce>
     e9e:	75 c0       	rjmp	.+234    	; 0xf8a <__vector_8+0x1b8>
__vector_8():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:49
    isPlaying = true;
}

uint8_t nextSample(){

    uint16_t sample = 0;
     ea0:	80 e0       	ldi	r24, 0x00	; 0
     ea2:	52 c0       	rjmp	.+164    	; 0xf48 <__vector_8+0x176>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:110

    if (isPlaying) {
        digitalWriteFast(SHUTDOWN_PIN, false); // on before next sample
    }
    else {
        goToSleep = true; // this is so the main loop can put the chip to sleep after this interrupt ran
     ea4:	81 e0       	ldi	r24, 0x01	; 1
     ea6:	80 93 67 39 	sts	0x3967, r24	; 0x803967 <goToSleep>
digitalWriteFast():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:298
  else if (val == CHANGE)
    vport->IN  |= mask;
  else // HIGH
    vport->OUT |= mask;
     eaa:	0d 9a       	sbi	0x01, 5	; 1
     eac:	c1 cf       	rjmp	.-126    	; 0xe30 <__vector_8+0x5e>
pulseSample():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:126
uint8_t pulseSample(oscillator_t *oscillator) {

    // TODO: something is buggy in here.

    // forwards/backwards
    uint32_t newPulse = oscillator->pulse + oscillator->pulseAmount; // TODO: this is probably the bug. overflow.
     eae:	c0 90 0b 38 	lds	r12, 0x380B	; 0x80380b <oscillators+0xa>
     eb2:	d0 90 0c 38 	lds	r13, 0x380C	; 0x80380c <oscillators+0xb>
     eb6:	e0 90 0d 38 	lds	r14, 0x380D	; 0x80380d <oscillators+0xc>
     eba:	f0 90 0e 38 	lds	r15, 0x380E	; 0x80380e <oscillators+0xd>
     ebe:	40 91 0f 38 	lds	r20, 0x380F	; 0x80380f <oscillators+0xe>
     ec2:	50 91 10 38 	lds	r21, 0x3810	; 0x803810 <oscillators+0xf>
     ec6:	60 91 11 38 	lds	r22, 0x3811	; 0x803811 <oscillators+0x10>
     eca:	70 91 12 38 	lds	r23, 0x3812	; 0x803812 <oscillators+0x11>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:127
    if (newPulse < MIN_PULSE || newPulse > MAX_PULSE) {
     ece:	97 01       	movw	r18, r14
     ed0:	86 01       	movw	r16, r12
     ed2:	09 59       	subi	r16, 0x99	; 153
     ed4:	19 49       	sbci	r17, 0x99	; 153
     ed6:	29 49       	sbci	r18, 0x99	; 153
     ed8:	39 41       	sbci	r19, 0x19	; 25
     eda:	04 0f       	add	r16, r20
     edc:	15 1f       	adc	r17, r21
     ede:	26 1f       	adc	r18, r22
     ee0:	37 1f       	adc	r19, r23
     ee2:	0f 3c       	cpi	r16, 0xCF	; 207
     ee4:	1c 4c       	sbci	r17, 0xCC	; 204
     ee6:	2c 4c       	sbci	r18, 0xCC	; 204
     ee8:	3c 4c       	sbci	r19, 0xCC	; 204
     eea:	78 f0       	brcs	.+30     	; 0xf0a <__vector_8+0x138>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:128
        oscillator->pulseAmount = -oscillator->pulseAmount;
     eec:	70 95       	com	r23
     eee:	60 95       	com	r22
     ef0:	50 95       	com	r21
     ef2:	41 95       	neg	r20
     ef4:	5f 4f       	sbci	r21, 0xFF	; 255
     ef6:	6f 4f       	sbci	r22, 0xFF	; 255
     ef8:	7f 4f       	sbci	r23, 0xFF	; 255
     efa:	40 93 0f 38 	sts	0x380F, r20	; 0x80380f <oscillators+0xe>
     efe:	50 93 10 38 	sts	0x3810, r21	; 0x803810 <oscillators+0xf>
     f02:	60 93 11 38 	sts	0x3811, r22	; 0x803811 <oscillators+0x10>
     f06:	70 93 12 38 	sts	0x3812, r23	; 0x803812 <oscillators+0x11>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:132
    }

    // TODO: This will drift because the last one won't make it to the end before bouncing back. Does that matter, though?
    oscillator->pulse += oscillator->pulseAmount;
     f0a:	40 91 0f 38 	lds	r20, 0x380F	; 0x80380f <oscillators+0xe>
     f0e:	50 91 10 38 	lds	r21, 0x3810	; 0x803810 <oscillators+0xf>
     f12:	60 91 11 38 	lds	r22, 0x3811	; 0x803811 <oscillators+0x10>
     f16:	70 91 12 38 	lds	r23, 0x3812	; 0x803812 <oscillators+0x11>
     f1a:	4c 0d       	add	r20, r12
     f1c:	5d 1d       	adc	r21, r13
     f1e:	6e 1d       	adc	r22, r14
     f20:	7f 1d       	adc	r23, r15
     f22:	40 93 0b 38 	sts	0x380B, r20	; 0x80380b <oscillators+0xa>
     f26:	50 93 0c 38 	sts	0x380C, r21	; 0x80380c <oscillators+0xb>
     f2a:	60 93 0d 38 	sts	0x380D, r22	; 0x80380d <oscillators+0xc>
     f2e:	70 93 0e 38 	sts	0x380E, r23	; 0x80380e <oscillators+0xd>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:136

    // funny how we're using a DAC and right now we're only using it to make a square wave :)
    //if (oscillator->phase < oscillator->pulse) {
    if (oscillator->phase < 2147483648) { // TODO
     f32:	80 95       	com	r24
     f34:	90 95       	com	r25
     f36:	a0 95       	com	r26
     f38:	b0 95       	com	r27
     f3a:	88 27       	eor	r24, r24
     f3c:	b7 fd       	sbrc	r27, 7
     f3e:	83 95       	inc	r24
     f40:	99 27       	eor	r25, r25
     f42:	aa 27       	eor	r26, r26
     f44:	bb 27       	eor	r27, r27
     f46:	81 95       	neg	r24
__vector_8():
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:118

    // write the previously calculated sample first so the timing is reliable no matter how long it takes to calculate the next sample
    analogWrite(DAC_PIN, sample);

    // calculate the sample for next time
    sample = nextSample();
     f48:	80 93 00 38 	sts	0x3800, r24	; 0x803800 <__DATA_REGION_ORIGIN__>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:123

    //digitalWriteFast(LED_PIN, false); // TODO: optimise

    // The interrupt flag has to be cleared manually
    TCA0.SINGLE.INTFLAGS = TCA_SINGLE_OVF_bm;
     f4c:	81 e0       	ldi	r24, 0x01	; 1
     f4e:	80 93 0b 0a 	sts	0x0A0B, r24	; 0x800a0b <vtable for CmdBuffer<32u>+0x7f6c2d>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:124
}
     f52:	ff 91       	pop	r31
     f54:	ef 91       	pop	r30
     f56:	bf 91       	pop	r27
     f58:	af 91       	pop	r26
     f5a:	9f 91       	pop	r25
     f5c:	8f 91       	pop	r24
     f5e:	7f 91       	pop	r23
     f60:	6f 91       	pop	r22
     f62:	5f 91       	pop	r21
     f64:	4f 91       	pop	r20
     f66:	3f 91       	pop	r19
     f68:	2f 91       	pop	r18
     f6a:	1f 91       	pop	r17
     f6c:	0f 91       	pop	r16
     f6e:	ff 90       	pop	r15
     f70:	ef 90       	pop	r14
     f72:	df 90       	pop	r13
     f74:	cf 90       	pop	r12
     f76:	0f 90       	pop	r0
     f78:	0f be       	out	0x3f, r0	; 63
     f7a:	0f 90       	pop	r0
     f7c:	1f 90       	pop	r1
     f7e:	18 95       	reti
sawSample():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:147
}

uint8_t sawSample(oscillator_t *oscillator) {

    // top 8 bits of the 32 bit number
    return oscillator->phase >> 24;
     f80:	8b 2f       	mov	r24, r27
     f82:	99 27       	eor	r25, r25
     f84:	aa 27       	eor	r26, r26
     f86:	bb 27       	eor	r27, r27
     f88:	df cf       	rjmp	.-66     	; 0xf48 <__vector_8+0x176>
triangleSample():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:152
}

uint8_t triangleSample(oscillator_t *oscillator) {

    int8_t temp = oscillator->phase >> 24;
     f8a:	8b 2f       	mov	r24, r27
     f8c:	99 27       	eor	r25, r25
     f8e:	aa 27       	eor	r26, r26
     f90:	bb 27       	eor	r27, r27
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:153
    int8_t mask = temp >> 7;
     f92:	28 2f       	mov	r18, r24
     f94:	08 2e       	mov	r0, r24
     f96:	00 0c       	add	r0, r0
     f98:	33 0b       	sbc	r19, r19
     f9a:	22 0f       	add	r18, r18
     f9c:	23 2f       	mov	r18, r19
     f9e:	22 1f       	adc	r18, r18
     fa0:	33 0b       	sbc	r19, r19
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:155

    return (uint8_t) (temp ^ mask) << 1;
     fa2:	82 27       	eor	r24, r18
     fa4:	88 0f       	add	r24, r24
     fa6:	d0 cf       	rjmp	.-96     	; 0xf48 <__vector_8+0x176>

00000fa8 <global constructors keyed to 65535_0_QT60240.cpp.o.3387>:
_GLOBAL__I_65535_0_QT60240.cpp.o.3387():
     fa8:	eb e8       	ldi	r30, 0x8B	; 139
     faa:	f9 e3       	ldi	r31, 0x39	; 57
     fac:	12 82       	std	Z+2, r1	; 0x02
     fae:	13 82       	std	Z+3, r1	; 0x03
     fb0:	48 ee       	ldi	r20, 0xE8	; 232
     fb2:	53 e0       	ldi	r21, 0x03	; 3
     fb4:	60 e0       	ldi	r22, 0x00	; 0
     fb6:	70 e0       	ldi	r23, 0x00	; 0
     fb8:	44 83       	std	Z+4, r20	; 0x04
     fba:	55 83       	std	Z+5, r21	; 0x05
     fbc:	66 83       	std	Z+6, r22	; 0x06
     fbe:	77 83       	std	Z+7, r23	; 0x07
     fc0:	88 eb       	ldi	r24, 0xB8	; 184
     fc2:	9d e9       	ldi	r25, 0x9D	; 157
     fc4:	80 83       	st	Z, r24
     fc6:	91 83       	std	Z+1, r25	; 0x01
     fc8:	80 e0       	ldi	r24, 0x00	; 0
     fca:	98 e0       	ldi	r25, 0x08	; 8
     fcc:	84 87       	std	Z+12, r24	; 0x0c
     fce:	95 87       	std	Z+13, r25	; 0x0d
     fd0:	84 e0       	ldi	r24, 0x04	; 4
     fd2:	86 87       	std	Z+14, r24	; 0x0e
     fd4:	85 e0       	ldi	r24, 0x05	; 5
     fd6:	87 87       	std	Z+15, r24	; 0x0f
     fd8:	10 8a       	std	Z+16, r1	; 0x10
     fda:	89 e0       	ldi	r24, 0x09	; 9
     fdc:	81 8b       	std	Z+17, r24	; 0x11
     fde:	88 e0       	ldi	r24, 0x08	; 8
     fe0:	82 8b       	std	Z+18, r24	; 0x12
     fe2:	91 e0       	ldi	r25, 0x01	; 1
     fe4:	93 8b       	std	Z+19, r25	; 0x13
     fe6:	14 8a       	std	Z+20, r1	; 0x14
     fe8:	15 8a       	std	Z+21, r1	; 0x15
     fea:	16 8a       	std	Z+22, r1	; 0x16
     fec:	17 8a       	std	Z+23, r1	; 0x17
     fee:	10 8e       	std	Z+24, r1	; 0x18
     ff0:	11 8e       	std	Z+25, r1	; 0x19
     ff2:	9c e1       	ldi	r25, 0x1C	; 28
     ff4:	92 8f       	std	Z+26, r25	; 0x1a
     ff6:	e6 e2       	ldi	r30, 0x26	; 38
     ff8:	fa e3       	ldi	r31, 0x3A	; 58
     ffa:	12 82       	std	Z+2, r1	; 0x02
     ffc:	13 82       	std	Z+3, r1	; 0x03
     ffe:	44 83       	std	Z+4, r20	; 0x04
    1000:	55 83       	std	Z+5, r21	; 0x05
    1002:	66 83       	std	Z+6, r22	; 0x06
    1004:	77 83       	std	Z+7, r23	; 0x07
    1006:	22 ed       	ldi	r18, 0xD2	; 210
    1008:	3d e9       	ldi	r19, 0x9D	; 157
    100a:	20 83       	st	Z, r18
    100c:	31 83       	std	Z+1, r19	; 0x01
    100e:	ea e5       	ldi	r30, 0x5A	; 90
    1010:	fa e3       	ldi	r31, 0x3A	; 58
    1012:	10 82       	st	Z, r1
    1014:	11 82       	std	Z+1, r1	; 0x01
    1016:	90 e2       	ldi	r25, 0x20	; 32
    1018:	92 83       	std	Z+2, r25	; 0x02
    101a:	13 82       	std	Z+3, r1	; 0x03
    101c:	14 82       	std	Z+4, r1	; 0x04
    101e:	15 82       	std	Z+5, r1	; 0x05
    1020:	16 82       	std	Z+6, r1	; 0x06
    1022:	17 82       	std	Z+7, r1	; 0x07
    1024:	10 86       	std	Z+8, r1	; 0x08
    1026:	e2 e3       	ldi	r30, 0x32	; 50
    1028:	fa e3       	ldi	r31, 0x3A	; 58
    102a:	9a e0       	ldi	r25, 0x0A	; 10
    102c:	92 83       	std	Z+2, r25	; 0x02
    102e:	83 83       	std	Z+3, r24	; 0x03
    1030:	14 82       	std	Z+4, r1	; 0x04
    1032:	15 82       	std	Z+5, r1	; 0x05
    1034:	16 82       	std	Z+6, r1	; 0x06
    1036:	82 ee       	ldi	r24, 0xE2	; 226
    1038:	9d e9       	ldi	r25, 0x9D	; 157
    103a:	80 83       	st	Z, r24
    103c:	91 83       	std	Z+1, r25	; 0x01
    103e:	cf 01       	movw	r24, r30
    1040:	0c 94 b1 04 	jmp	0x962	; 0x962 <CmdBuffer<32u>::clear()>

00001044 <main>:
main():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/main.cpp:42

void setupUSB() __attribute__((weak));
void setupUSB() { }

int main(void)
{
    1044:	cf 93       	push	r28
    1046:	df 93       	push	r29
    1048:	cd b7       	in	r28, 0x3d	; 61
    104a:	de b7       	in	r29, 0x3e	; 62
    104c:	29 97       	sbiw	r28, 0x09	; 9
    104e:	cd bf       	out	0x3d, r28	; 61
    1050:	de bf       	out	0x3e, r29	; 62
init():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:609
  /* No division on clock */
  _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, 0x00);

  #elif (F_CPU == 10000000) //20MHz prescaled by 2
  /* Clock DIV2 */
  _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, (CLKCTRL_PEN_bm | CLKCTRL_PDIV_2X_gc));
    1052:	91 e0       	ldi	r25, 0x01	; 1
    1054:	88 ed       	ldi	r24, 0xD8	; 216
    1056:	84 bf       	out	0x34, r24	; 52
    1058:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <vtable for CmdBuffer<32u>+0x7f6283>
init_ADC0():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:671
    compensate for this! */

  #if F_CPU >= 12000000 // 16 MHz / 16 = 1 MHz,  20 MHz / 16 = 1.25 MHz
  ADC0.CTRLC = ADC_PRESC_DIV16_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;;
  #elif F_CPU >= 6000000 // 8 MHz / 8 = 1 MHz, 10 MHz / 64 = 1.25 MHz
  ADC0.CTRLC = ADC_PRESC_DIV8_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;;
    105c:	82 e5       	ldi	r24, 0x52	; 82
    105e:	80 93 02 06 	sts	0x0602, r24	; 0x800602 <vtable for CmdBuffer<32u>+0x7f6824>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:677
  #elif F_CPU >= 3000000 // 4 MHz / 32 = 1 MHz, 5 MHz / 32 = 1.25 MHz
  ADC0.CTRLC = ADC_PRESC_DIV4_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;;
  #else  // 1 MHz / 2 = 500 kHz - the lowest setting
  ADC0.CTRLC = ADC_PRESC_DIV2_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;;
  #endif
  ADC0.SAMPCTRL = 14; //16 ADC clock sampling time - should be about the same amount of *time* as originally?
    1062:	8e e0       	ldi	r24, 0x0E	; 14
    1064:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <vtable for CmdBuffer<32u>+0x7f6827>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:694
  ADC0.CTRLC = ADC_PRESC_DIV8_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;;
  #else // 128 kHz / 2 = 64 kHz -> This is the closest you can get, the prescaler is 2
  ADC0.CTRLC = ADC_PRESC_DIV2_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;;
  #endif
  #endif
  ADC0.CTRLD = ADC_INITDLY_DLY16_gc;
    1068:	80 e2       	ldi	r24, 0x20	; 32
    106a:	80 93 03 06 	sts	0x0603, r24	; 0x800603 <vtable for CmdBuffer<32u>+0x7f6825>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:696
  /* Enable ADC */
  ADC0.CTRLA |= ADC_ENABLE_bm;
    106e:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <vtable for CmdBuffer<32u>+0x7f6822>
    1072:	81 60       	ori	r24, 0x01	; 1
    1074:	80 93 00 06 	sts	0x0600, r24	; 0x800600 <vtable for CmdBuffer<32u>+0x7f6822>
init_TCA0():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:776

  /* PORTMUX setting for TCA - don't need to set because using default */
  //PORTMUX.CTRLA = PORTMUX_TCA00_DEFAULT_gc;

  /* Enable Split Mode */
  TCA0.SPLIT.CTRLD = TCA_SPLIT_SPLITM_bm;
    1078:	90 93 03 0a 	sts	0x0A03, r25	; 0x800a03 <vtable for CmdBuffer<32u>+0x7f6c25>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:781

  //Only 1 WGM so no need to specifically set up.

  /* Period setting, 8-bit register in SPLIT mode */
  TCA0.SPLIT.LPER    = PWM_TIMER_PERIOD;
    107c:	8e ef       	ldi	r24, 0xFE	; 254
    107e:	80 93 26 0a 	sts	0x0A26, r24	; 0x800a26 <vtable for CmdBuffer<32u>+0x7f6c48>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:782
  TCA0.SPLIT.HPER    = PWM_TIMER_PERIOD;
    1082:	80 93 27 0a 	sts	0x0A27, r24	; 0x800a27 <vtable for CmdBuffer<32u>+0x7f6c49>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:799

  /* Use prescale appropriate for system clock speed */
  #if (F_CPU > 25000000) //   use 256 divider when clocked over 25 MHz - probably not terribly relevant - though they might be viable at 30 or 32, and are viable at 24/25 MHz.
    TCA0.SPLIT.CTRLA   = (TCA_SPLIT_CLKSEL_DIV256_gc) | (TCA_SPLIT_ENABLE_bm);
  #elif (F_CPU > 5000000) //  use 64 divider
    TCA0.SPLIT.CTRLA   =  (TCA_SPLIT_CLKSEL_DIV64_gc) | (TCA_SPLIT_ENABLE_bm);
    1086:	8b e0       	ldi	r24, 0x0B	; 11
    1088:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <vtable for CmdBuffer<32u>+0x7f6c22>
init_millis():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:541
    #if defined(MILLIS_USE_TIMERA0)
      TCA0.SPLIT.INTCTRL |= TCA_SPLIT_HUNF_bm;
    #elif defined(MILLIS_USE_TIMERA1)
      TCA1.SPLIT.INTCTRL |= TCA_SPLIT_HUNF_bm;
    #elif defined(MILLIS_USE_TIMERD0)
      TCD0.CMPBCLR        = TIME_TRACKING_TIMER_PERIOD; //essentially, this is TOP
    108c:	2d ef       	ldi	r18, 0xFD	; 253
    108e:	31 e0       	ldi	r19, 0x01	; 1
    1090:	20 93 ae 0a 	sts	0x0AAE, r18	; 0x800aae <vtable for CmdBuffer<32u>+0x7f6cd0>
    1094:	30 93 af 0a 	sts	0x0AAF, r19	; 0x800aaf <vtable for CmdBuffer<32u>+0x7f6cd1>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:542
      TCD0.INTCTRL        = 0x01;//enable interrupt
    1098:	90 93 8c 0a 	sts	0x0A8C, r25	; 0x800a8c <vtable for CmdBuffer<32u>+0x7f6cae>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:543
      TCD0.CTRLB          = 0x00; //oneramp mode
    109c:	10 92 81 0a 	sts	0x0A81, r1	; 0x800a81 <vtable for CmdBuffer<32u>+0x7f6ca3>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:544
      TCD0.CTRLC          = 0x80;
    10a0:	80 e8       	ldi	r24, 0x80	; 128
    10a2:	80 93 82 0a 	sts	0x0A82, r24	; 0x800a82 <vtable for CmdBuffer<32u>+0x7f6ca4>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:545
      TCD0.CTRLA          = TIMERD0_PRESCALER | 0x01; //set clock source and enable!
    10a6:	81 e1       	ldi	r24, 0x11	; 17
    10a8:	80 93 80 0a 	sts	0x0A80, r24	; 0x800a80 <vtable for CmdBuffer<32u>+0x7f6ca2>
init():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:651
  #ifndef MILLIS_USE_TIMERNONE
  init_millis();
  #endif //end #ifndef MILLIS_USE_TIMERNONE
  /*************************** ENABLE GLOBAL INTERRUPTS *************************/

  sei();
    10ac:	78 94       	sei
DACReference():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_analog.c:134

#ifdef DAC0
void DACReference(uint8_t mode) {
  check_valid_dac_ref(mode);
  if (mode < 5) {
    VREF.CTRLA = mode | (VREF.CTRLA & (~VREF_DAC0REFSEL_gm));
    10ae:	80 91 a0 00 	lds	r24, 0x00A0	; 0x8000a0 <vtable for CmdBuffer<32u>+0x7f62c2>
    10b2:	88 7f       	andi	r24, 0xF8	; 248
    10b4:	82 60       	ori	r24, 0x02	; 2
    10b6:	80 93 a0 00 	sts	0x00A0, r24	; 0x8000a0 <vtable for CmdBuffer<32u>+0x7f62c2>
setup():
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:30

    DACReference(INTERNAL2V5);

    // setup a timer overflow interrupt to fire at 25khz
    // system clock is 20Mhz. Prescaler is 16. Period is 49 (so it will be 49+1 = 50)
    TCA0.SINGLE.INTCTRL = 0 << TCA_SINGLE_CMP0_bp   /* Compare 0 Interrupt: disabled */
    10ba:	90 93 0a 0a 	sts	0x0A0A, r25	; 0x800a0a <vtable for CmdBuffer<32u>+0x7f6c2c>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:35
                          | 0 << TCA_SINGLE_CMP1_bp /* Compare 1 Interrupt: disabled */
                          | 0 << TCA_SINGLE_CMP2_bp /* Compare 2 Interrupt: disabled */
                          | 1 << TCA_SINGLE_OVF_bp; /* Overflow Interrupt: enabled */

    TCA0.SINGLE.PER = 49; /* 49 + 1 == 50 */
    10be:	81 e3       	ldi	r24, 0x31	; 49
    10c0:	90 e0       	ldi	r25, 0x00	; 0
    10c2:	80 93 26 0a 	sts	0x0A26, r24	; 0x800a26 <vtable for CmdBuffer<32u>+0x7f6c48>
    10c6:	90 93 27 0a 	sts	0x0A27, r25	; 0x800a27 <vtable for CmdBuffer<32u>+0x7f6c49>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:37

    TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV16_gc /* System Clock / 16 */
    10ca:	89 e0       	ldi	r24, 0x09	; 9
    10cc:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <vtable for CmdBuffer<32u>+0x7f6c22>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:41
                        | 1 << TCA_SINGLE_ENABLE_bp /* Module Enable: enabled */;

    //pinMode(LED_PIN, OUTPUT);
    pinMode(DAC_PIN, OUTPUT);
    10d0:	61 e0       	ldi	r22, 0x01	; 1
    10d2:	82 e0       	ldi	r24, 0x02	; 2
    10d4:	0e 94 f8 03 	call	0x7f0	; 0x7f0 <pinMode>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:42
    pinMode(SHUTDOWN_PIN, OUTPUT);
    10d8:	61 e0       	ldi	r22, 0x01	; 1
    10da:	81 e0       	ldi	r24, 0x01	; 1
    10dc:	0e 94 f8 03 	call	0x7f0	; 0x7f0 <pinMode>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:43
    pinMode(CHANGE_PIN, INPUT_PULLUP);
    10e0:	62 e0       	ldi	r22, 0x02	; 2
    10e2:	83 e0       	ldi	r24, 0x03	; 3
    10e4:	0e 94 f8 03 	call	0x7f0	; 0x7f0 <pinMode>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:46

    // PIN_PA7
    PORTA.PIN7CTRL |= 0x01; // interrupt on change
    10e8:	80 91 17 04 	lds	r24, 0x0417	; 0x800417 <vtable for CmdBuffer<32u>+0x7f6639>
    10ec:	81 60       	ori	r24, 0x01	; 1
    10ee:	80 93 17 04 	sts	0x0417, r24	; 0x800417 <vtable for CmdBuffer<32u>+0x7f6639>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:50

    // TODO: make sure all pins are dealt with from a power consumption perspective

    Serial.begin(57600);
    10f2:	40 e0       	ldi	r20, 0x00	; 0
    10f4:	51 ee       	ldi	r21, 0xE1	; 225
    10f6:	60 e0       	ldi	r22, 0x00	; 0
    10f8:	70 e0       	ldi	r23, 0x00	; 0
    10fa:	8b e8       	ldi	r24, 0x8B	; 139
    10fc:	99 e3       	ldi	r25, 0x39	; 57
    10fe:	0e 94 99 02 	call	0x532	; 0x532 <UartClass::begin(unsigned long)>
begin():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:169
    #endif
  #endif
}

void TwoWire::begin(void) {
  rxBufferIndex = 0;
    1102:	10 92 4e 38 	sts	0x384E, r1	; 0x80384e <TwoWire::rxBufferIndex>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:170
  rxBufferLength = 0;
    1106:	10 92 4d 38 	sts	0x384D, r1	; 0x80384d <TwoWire::rxBufferLength>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:172

  txBufferIndex = 0;
    110a:	10 92 68 39 	sts	0x3968, r1	; 0x803968 <TwoWire::txBufferIndex>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:173
  txBufferLength = 0;
    110e:	10 92 8a 39 	sts	0x398A, r1	; 0x80398a <TwoWire::txBufferLength>
TWI_MasterInit():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:64
    Remember to enable interrupts globally from the main application.

    \param frequency            The required baud.
*/
void TWI_MasterInit(uint32_t frequency) {
  if (twi_mode != TWI_MODE_UNKNOWN) {
    1112:	80 91 4a 38 	lds	r24, 0x384A	; 0x80384a <twi_mode>
    1116:	81 11       	cpse	r24, r1
    1118:	1a c0       	rjmp	.+52     	; 0x114e <main+0x10a>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:77
  } else {
    PORTA.OUTCLR=0x0C; //bits 2 and 3
  }
  #else // megaTinyCore
    #if defined(PORTMUX_TWI0_bm)
      if ((PORTMUX.CTRLB & PORTMUX_TWI0_bm)) {
    111a:	80 91 01 02 	lds	r24, 0x0201	; 0x800201 <vtable for CmdBuffer<32u>+0x7f6423>
    111e:	84 ff       	sbrs	r24, 4
    1120:	1c c1       	rjmp	.+568    	; 0x135a <main+0x316>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:80
        // make sure we don't get errata'ed - make sure their bits in the
        // PORTx.OUT registers are 0.
        PORTA.OUTCLR=0x06; // if swapped it's on PA1, PA2
    1122:	86 e0       	ldi	r24, 0x06	; 6
    1124:	80 93 06 04 	sts	0x0406, r24	; 0x800406 <vtable for CmdBuffer<32u>+0x7f6628>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:91
    #else
      PORTB.OUTCLR=0x03; // else, zero series, no remapping, it's on PB0, PB1
    #endif
  #endif

  twi_mode = TWI_MODE_MASTER;
    1128:	81 e0       	ldi	r24, 0x01	; 1
    112a:	80 93 4a 38 	sts	0x384A, r24	; 0x80384a <twi_mode>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:93

  master_bytesRead = 0;
    112e:	10 92 49 38 	sts	0x3849, r1	; 0x803849 <master_bytesRead>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:94
  master_bytesWritten = 0;
    1132:	10 92 48 38 	sts	0x3848, r1	; 0x803848 <master_bytesWritten>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:95
  master_trans_status = TWIM_STATUS_READY;
    1136:	10 92 47 38 	sts	0x3847, r1	; 0x803847 <master_trans_status>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:96
  master_result = TWIM_RESULT_UNKNOWN;
    113a:	10 92 46 38 	sts	0x3846, r1	; 0x803846 <master_result>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:98

  TWI0.MCTRLA = TWI_RIEN_bm | TWI_WIEN_bm | TWI_ENABLE_bm;
    113e:	91 ec       	ldi	r25, 0xC1	; 193
    1140:	90 93 13 08 	sts	0x0813, r25	; 0x800813 <vtable for CmdBuffer<32u>+0x7f6a35>
TWI_MasterSetBaud():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:246
    frequency = 100000;
    t_rise    = 1000;
  }

  uint32_t baud = (F_CPU / frequency - F_CPU / 1000 / 1000 * t_rise / 1000 - 10) / 2;
  TWI0.MBAUD = (uint8_t)baud;
    1144:	98 e2       	ldi	r25, 0x28	; 40
    1146:	90 93 16 08 	sts	0x0816, r25	; 0x800816 <vtable for CmdBuffer<32u>+0x7f6a38>
TWI_MasterInit():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:100
  master_trans_status = TWIM_STATUS_READY;
  master_result = TWIM_RESULT_UNKNOWN;

  TWI0.MCTRLA = TWI_RIEN_bm | TWI_WIEN_bm | TWI_ENABLE_bm;
  TWI_MasterSetBaud(frequency);
  TWI0.MSTATUS = TWI_BUSSTATE_IDLE_gc;
    114a:	80 93 15 08 	sts	0x0815, r24	; 0x800815 <vtable for CmdBuffer<32u>+0x7f6a37>
_ZN15CmdBufferObject10setEndCharEh():
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdBuffer.hpp:72
     * - CMDBUFFER_CHAR_LF
     * - CMDBUFFER_CHAR_CR
     *
     * @param end       ASCII character
     */
    void setEndChar(uint8_t end) { m_endChar = end; }
    114e:	8d e0       	ldi	r24, 0x0D	; 13
    1150:	80 93 34 3a 	sts	0x3A34, r24	; 0x803a34 <myBuffer+0x2>
_ZN15CmdBufferObject7setEchoEb():
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdBuffer.hpp:91
    /**
     * Set echo serial on (true) or off (false)
     *
     * @param echo      bool
     */
    void setEcho(bool echo) { m_echo = echo; }
    1154:	81 e0       	ldi	r24, 0x01	; 1
    1156:	80 93 38 3a 	sts	0x3A38, r24	; 0x803a38 <myBuffer+0x6>
setup():
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:55
    Wire.begin();

    setupInterface();

    Serial.println("OK");
    115a:	8b ef       	ldi	r24, 0xFB	; 251
    115c:	9d e9       	ldi	r25, 0x9D	; 157
    115e:	0e 94 ef 02 	call	0x5de	; 0x5de <Print::println(char const*) [clone .constprop.44]>
beginTransmission():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:256

void TwoWire::beginTransmission(uint8_t address) {
  // indicate that we are transmitting
  transmitting = 1;
  // set address of targeted slave
  txAddress = address;
    1162:	85 e7       	ldi	r24, 0x75	; 117
    1164:	80 93 89 39 	sts	0x3989, r24	; 0x803989 <TwoWire::txAddress>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:258
  // reset tx buffer iterator vars
  txBufferIndex = 0;
    1168:	10 92 68 39 	sts	0x3968, r1	; 0x803968 <TwoWire::txBufferIndex>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:259
  txBufferLength = 0;
    116c:	10 92 8a 39 	sts	0x398A, r1	; 0x80398a <TwoWire::txBufferLength>
recalibrateTouch():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:7

uint8_t recalibrateTouch() {
    uint8_t error;

    Wire.beginTransmission(TOUCH_ADDRESS);
    Wire.write(125); // recalibrate all keys address
    1170:	8d e7       	ldi	r24, 0x7D	; 125
    1172:	90 e0       	ldi	r25, 0x00	; 0
    1174:	0e 94 94 02 	call	0x528	; 0x528 <TwoWire::write(int) [clone .constprop.58]>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:8
    Wire.write(0x55); // recalibrate all keys
    1178:	85 e5       	ldi	r24, 0x55	; 85
    117a:	90 e0       	ldi	r25, 0x00	; 0
    117c:	0e 94 94 02 	call	0x528	; 0x528 <TwoWire::write(int) [clone .constprop.58]>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:9
    error = Wire.endTransmission(false);
    1180:	0e 94 19 02 	call	0x432	; 0x432 <TwoWire::endTransmission(bool) [clone .constprop.47]>
    1184:	18 2f       	mov	r17, r24
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:11

    if (error) {
    1186:	88 23       	and	r24, r24
    1188:	39 f0       	breq	.+14     	; 0x1198 <main+0x154>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:12
        Serial.print("oopsie (0x55): ");
    118a:	8e ef       	ldi	r24, 0xFE	; 254
    118c:	9d e9       	ldi	r25, 0x9D	; 157
    118e:	0e 94 ed 02 	call	0x5da	; 0x5da <Print::print(char const*) [clone .constprop.49]>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:13
        Serial.println(error);
    1192:	81 2f       	mov	r24, r17
    1194:	0e 94 fd 02 	call	0x5fa	; 0x5fa <Print::println(unsigned char, int) [clone .constprop.50]>
setup():
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:59

    recalibrateTouch();

    Serial.println("recalibrated");
    1198:	8e e0       	ldi	r24, 0x0E	; 14
    119a:	9e e9       	ldi	r25, 0x9E	; 158
    119c:	0e 94 ef 02 	call	0x5de	; 0x5de <Print::println(char const*) [clone .constprop.44]>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:62

    // TODO: uart doesn't stay active during power down. it can stay active during standby if we enable that (somewhere?), but maybe we can just set a pin interrupt on RX?
    set_sleep_mode(SLEEP_MODE_STANDBY);
    11a0:	80 91 50 00 	lds	r24, 0x0050	; 0x800050 <vtable for CmdBuffer<32u>+0x7f6272>
    11a4:	89 7f       	andi	r24, 0xF9	; 249
    11a6:	82 60       	ori	r24, 0x02	; 2
    11a8:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <vtable for CmdBuffer<32u>+0x7f6272>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:63
    USART0.CTRLB |= USART_SFDEN_bm; // enable start of frame detection mode
    11ac:	80 91 06 08 	lds	r24, 0x0806	; 0x800806 <vtable for CmdBuffer<32u>+0x7f6a28>
    11b0:	80 61       	ori	r24, 0x10	; 16
    11b2:	80 93 06 08 	sts	0x0806, r24	; 0x800806 <vtable for CmdBuffer<32u>+0x7f6a28>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:64
    sleep_enable();
    11b6:	80 91 50 00 	lds	r24, 0x0050	; 0x800050 <vtable for CmdBuffer<32u>+0x7f6272>
    11ba:	81 60       	ori	r24, 0x01	; 1
    11bc:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <vtable for CmdBuffer<32u>+0x7f6272>
clearNote():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:34
void clearNote() {

    // for now this is one to one with jump == -1, but once we have things like envelopes that assumption won't hold
    isPlaying = false;

    oscillators[0].jump = -1;
    11c0:	44 24       	eor	r4, r4
    11c2:	4a 94       	dec	r4
    11c4:	54 2c       	mov	r5, r4
    11c6:	32 01       	movw	r6, r4
    11c8:	9e 01       	movw	r18, r28
    11ca:	2c 5f       	subi	r18, 0xFC	; 252
    11cc:	3f 4f       	sbci	r19, 0xFF	; 255
    11ce:	2c 83       	std	Y+4, r18	; 0x04
    11d0:	3d 83       	std	Y+5, r19	; 0x05
updateInterface():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:42
    // TODO: somehow go to sleep if we're not playing

    //Serial.print("elapsed:  ");
    //RSerial.println(micros());

    if (touchChanged)  {
    11d2:	80 91 66 39 	lds	r24, 0x3966	; 0x803966 <touchChanged>
    11d6:	88 23       	and	r24, r24
    11d8:	09 f4       	brne	.+2      	; 0x11dc <main+0x198>
    11da:	8c c0       	rjmp	.+280    	; 0x12f4 <main+0x2b0>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:44
        // This should be safe because the change pin won't go high again until we read the keys which only happens afterwards. And even if that happens immediately after reading the boolean will be set and we'll only clear it next time.
        touchChanged = false;
    11dc:	10 92 66 39 	sts	0x3966, r1	; 0x803966 <touchChanged>
beginTransmission():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:256

void TwoWire::beginTransmission(uint8_t address) {
  // indicate that we are transmitting
  transmitting = 1;
  // set address of targeted slave
  txAddress = address;
    11e0:	35 e7       	ldi	r19, 0x75	; 117
    11e2:	30 93 89 39 	sts	0x3989, r19	; 0x803989 <TwoWire::txAddress>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:258
  // reset tx buffer iterator vars
  txBufferIndex = 0;
    11e6:	10 92 68 39 	sts	0x3968, r1	; 0x803968 <TwoWire::txBufferIndex>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:259
  txBufferLength = 0;
    11ea:	10 92 8a 39 	sts	0x398A, r1	; 0x80398a <TwoWire::txBufferLength>
readKeys():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:25
uint8_t readKeys(uint8_t * buf) {

    uint8_t error;

    Wire.beginTransmission(TOUCH_ADDRESS);
    Wire.write(1);
    11ee:	81 e0       	ldi	r24, 0x01	; 1
    11f0:	90 e0       	ldi	r25, 0x00	; 0
    11f2:	0e 94 94 02 	call	0x528	; 0x528 <TwoWire::write(int) [clone .constprop.58]>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:26
    error = Wire.endTransmission(false);
    11f6:	0e 94 19 02 	call	0x432	; 0x432 <TwoWire::endTransmission(bool) [clone .constprop.47]>
    11fa:	18 2f       	mov	r17, r24
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:29

    if (error) {
      Serial.print("oopsie (keys): ");
    11fc:	80 e2       	ldi	r24, 0x20	; 32
    11fe:	9e e9       	ldi	r25, 0x9E	; 158
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:28

    Wire.beginTransmission(TOUCH_ADDRESS);
    Wire.write(1);
    error = Wire.endTransmission(false);

    if (error) {
    1200:	11 11       	cpse	r17, r1
    1202:	a5 c2       	rjmp	.+1354   	; 0x174e <main+0x70a>
TWI_MasterRead():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:294
*/
uint8_t TWI_MasterRead(uint8_t slave_address,
                       uint8_t *read_data,
                       uint8_t bytes_to_read,
                       uint8_t send_stop) {
  master_readData = read_data;
    1204:	8f e4       	ldi	r24, 0x4F	; 79
    1206:	98 e3       	ldi	r25, 0x38	; 56
    1208:	80 93 4b 38 	sts	0x384B, r24	; 0x80384b <master_readData>
    120c:	90 93 4c 38 	sts	0x384C, r25	; 0x80384c <master_readData+0x1>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:296

  uint8_t bytes_read = TWI_MasterWriteRead(slave_address,
    1210:	01 e0       	ldi	r16, 0x01	; 1
    1212:	21 e0       	ldi	r18, 0x01	; 1
    1214:	40 e0       	ldi	r20, 0x00	; 0
    1216:	70 e0       	ldi	r23, 0x00	; 0
    1218:	60 e0       	ldi	r22, 0x00	; 0
    121a:	85 e7       	ldi	r24, 0x75	; 117
    121c:	0e 94 ba 01 	call	0x374	; 0x374 <TWI_MasterWriteRead>
requestFrom():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:227
  }

  uint8_t bytes_read = TWI_MasterRead(address, rxBuffer, quantity, sendStop);

  /* Initialize read variables */
  rxBufferIndex = 0;
    1220:	10 92 4e 38 	sts	0x384E, r1	; 0x80384e <TwoWire::rxBufferIndex>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:228
  rxBufferLength = bytes_read;
    1224:	80 93 4d 38 	sts	0x384D, r24	; 0x80384d <TwoWire::rxBufferLength>
readKeys():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:36
      return error;
    }

    for (uint8_t i=0; i<2; ++i) {
      Wire.requestFrom(TOUCH_ADDRESS, 1);
      buf[i] = (uint8_t) Wire.read();
    1228:	86 e2       	ldi	r24, 0x26	; 38
    122a:	9a e3       	ldi	r25, 0x3A	; 58
    122c:	0e 94 3a 02 	call	0x474	; 0x474 <TwoWire::read()>
    1230:	80 93 63 39 	sts	0x3963, r24	; 0x803963 <statusData>
TWI_MasterRead():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:296
    1234:	21 e0       	ldi	r18, 0x01	; 1
    1236:	40 e0       	ldi	r20, 0x00	; 0
    1238:	70 e0       	ldi	r23, 0x00	; 0
    123a:	60 e0       	ldi	r22, 0x00	; 0
    123c:	85 e7       	ldi	r24, 0x75	; 117
    123e:	0e 94 ba 01 	call	0x374	; 0x374 <TWI_MasterWriteRead>
requestFrom():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:227
  }

  uint8_t bytes_read = TWI_MasterRead(address, rxBuffer, quantity, sendStop);

  /* Initialize read variables */
  rxBufferIndex = 0;
    1242:	10 92 4e 38 	sts	0x384E, r1	; 0x80384e <TwoWire::rxBufferIndex>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:228
  rxBufferLength = bytes_read;
    1246:	80 93 4d 38 	sts	0x384D, r24	; 0x80384d <TwoWire::rxBufferLength>
readKeys():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:36
    124a:	86 e2       	ldi	r24, 0x26	; 38
    124c:	9a e3       	ldi	r25, 0x3A	; 58
    124e:	0e 94 3a 02 	call	0x474	; 0x474 <TwoWire::read()>
    1252:	80 93 64 39 	sts	0x3964, r24	; 0x803964 <statusData+0x1>
printKeys():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:44
    return 0;
}

void printKeys(uint8_t * buf) {

    Serial.print("KEYS");
    1256:	8b e1       	ldi	r24, 0x1B	; 27
    1258:	9e e9       	ldi	r25, 0x9E	; 158
    125a:	0e 94 ed 02 	call	0x5da	; 0x5da <Print::print(char const*) [clone .constprop.49]>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:47

    for (uint8_t i=0; i<2; ++i) {
      Serial.print(' ');
    125e:	80 e2       	ldi	r24, 0x20	; 32
    1260:	0e 94 68 01 	call	0x2d0	; 0x2d0 <Print::print(char) [clone .constprop.43]>
print():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:75
size_t Print::print(char c) {
  return write(c);
}

size_t Print::print(unsigned char b, int base) {
  return print((unsigned long) b, base);
    1264:	60 91 63 39 	lds	r22, 0x3963	; 0x803963 <statusData>
    1268:	70 e0       	ldi	r23, 0x00	; 0
    126a:	90 e0       	ldi	r25, 0x00	; 0
    126c:	80 e0       	ldi	r24, 0x00	; 0
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:105

size_t Print::print(unsigned long n, int base) {
  if (base == 0) {
    return write(n);
  } else {
    return printNumber(n, base);
    126e:	4a e0       	ldi	r20, 0x0A	; 10
    1270:	0e 94 af 02 	call	0x55e	; 0x55e <Print::printNumber(unsigned long, unsigned char) [clone .constprop.54]>
printKeys():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:47
    1274:	80 e2       	ldi	r24, 0x20	; 32
    1276:	0e 94 68 01 	call	0x2d0	; 0x2d0 <Print::print(char) [clone .constprop.43]>
print():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:75
size_t Print::print(char c) {
  return write(c);
}

size_t Print::print(unsigned char b, int base) {
  return print((unsigned long) b, base);
    127a:	60 91 64 39 	lds	r22, 0x3964	; 0x803964 <statusData+0x1>
    127e:	70 e0       	ldi	r23, 0x00	; 0
    1280:	90 e0       	ldi	r25, 0x00	; 0
    1282:	80 e0       	ldi	r24, 0x00	; 0
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:105

size_t Print::print(unsigned long n, int base) {
  if (base == 0) {
    return write(n);
  } else {
    return printNumber(n, base);
    1284:	4a e0       	ldi	r20, 0x0A	; 10
    1286:	0e 94 af 02 	call	0x55e	; 0x55e <Print::printNumber(unsigned long, unsigned char) [clone .constprop.54]>
printKeys():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:51
      Serial.print(buf[i]);
    }

    Serial.println("");
    128a:	8a ee       	ldi	r24, 0xEA	; 234
    128c:	9d e9       	ldi	r25, 0x9D	; 157
    128e:	0e 94 ef 02 	call	0x5de	; 0x5de <Print::println(char const*) [clone .constprop.44]>
checkKeyStatus():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:140

int8_t checkKeyStatus(uint8_t * buf) {

    // highest note wins ignoring the three buttons

    if (buf[1] & 64) {
    1292:	20 91 64 39 	lds	r18, 0x3964	; 0x803964 <statusData+0x1>
    1296:	80 91 63 39 	lds	r24, 0x3963	; 0x803963 <statusData>
    129a:	26 ff       	sbrs	r18, 6
    129c:	62 c0       	rjmp	.+196    	; 0x1362 <main+0x31e>
main():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:141
        return 12; // c2
    129e:	2c e0       	ldi	r18, 0x0C	; 12
updateInterface():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:52

            printKeys(statusData);

            //  look  at  the  two  bytes  in  statusData  and  determine  which  keys  are  pressed
            //  TODO:  can  we  go  polyphonic?
            currentKey = checkKeyStatus(statusData);
    12a0:	20 93 28 38 	sts	0x3828, r18	; 0x803828 <currentKey>
checkOctaveStatus():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:197

int8_t checkOctaveStatus (uint8_t * buf) {

    // debounce strategy: it has to have changed. Otherwise pressing notes while the octave buttons are pressed will retrigger it

    if (buf[0] & 64) {
    12a4:	86 ff       	sbrs	r24, 6
    12a6:	8c c0       	rjmp	.+280    	; 0x13c0 <main+0x37c>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:198
        if (previousOctaveStatus != 1) {
    12a8:	80 91 6f 38 	lds	r24, 0x386F	; 0x80386f <previousOctaveStatus>
    12ac:	81 30       	cpi	r24, 0x01	; 1
    12ae:	09 f4       	brne	.+2      	; 0x12b2 <main+0x26e>
    12b0:	8f c0       	rjmp	.+286    	; 0x13d0 <main+0x38c>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:199
            previousOctaveStatus = 1;
    12b2:	81 e0       	ldi	r24, 0x01	; 1
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:206
        }
    }
    else if (buf[0] & 128) {

        if (previousOctaveStatus != -1) {
            previousOctaveStatus = -1;
    12b4:	80 93 6f 38 	sts	0x386F, r24	; 0x80386f <previousOctaveStatus>
updateInterface():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:55
            //  look  at  the  two  bytes  in  statusData  and  determine  which  keys  are  pressed
            //  TODO:  can  we  go  polyphonic?
            currentKey = checkKeyStatus(statusData);

            int8_t octaveDelta = checkOctaveStatus(statusData);
            int8_t newOctave = currentOctave + octaveDelta;
    12b8:	90 91 27 38 	lds	r25, 0x3827	; 0x803827 <currentOctave>
    12bc:	89 0f       	add	r24, r25
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:56
            if (newOctave >= MIN_OCTAVE && newOctave <= MAX_OCTAVE) {
    12be:	9f ef       	ldi	r25, 0xFF	; 255
    12c0:	98 0f       	add	r25, r24
    12c2:	96 30       	cpi	r25, 0x06	; 6
    12c4:	10 f4       	brcc	.+4      	; 0x12ca <main+0x286>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:57
                currentOctave = newOctave;
    12c6:	80 93 27 38 	sts	0x3827, r24	; 0x803827 <currentOctave>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:60
            }

            if (currentKey == -1) {
    12ca:	2f 3f       	cpi	r18, 0xFF	; 255
    12cc:	09 f0       	breq	.+2      	; 0x12d0 <main+0x28c>
    12ce:	84 c0       	rjmp	.+264    	; 0x13d8 <main+0x394>
clearNote():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:32
// EXPORTS

void clearNote() {

    // for now this is one to one with jump == -1, but once we have things like envelopes that assumption won't hold
    isPlaying = false;
    12d0:	10 92 65 39 	sts	0x3965, r1	; 0x803965 <isPlaying>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:34

    oscillators[0].jump = -1;
    12d4:	40 92 03 38 	sts	0x3803, r4	; 0x803803 <oscillators+0x2>
    12d8:	50 92 04 38 	sts	0x3804, r5	; 0x803804 <oscillators+0x3>
    12dc:	60 92 05 38 	sts	0x3805, r6	; 0x803805 <oscillators+0x4>
    12e0:	70 92 06 38 	sts	0x3806, r7	; 0x803806 <oscillators+0x5>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:35
    oscillators[1].jump = -1;
    12e4:	40 92 16 38 	sts	0x3816, r4	; 0x803816 <oscillators+0x15>
    12e8:	50 92 17 38 	sts	0x3817, r5	; 0x803817 <oscillators+0x16>
    12ec:	60 92 18 38 	sts	0x3818, r6	; 0x803818 <oscillators+0x17>
    12f0:	70 92 19 38 	sts	0x3819, r7	; 0x803819 <oscillators+0x18>
updateInterface():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:70
            }

        }
    }

    while (Serial.available()) {
    12f4:	8b e8       	ldi	r24, 0x8B	; 139
    12f6:	99 e3       	ldi	r25, 0x39	; 57
    12f8:	0e 94 cc 00 	call	0x198	; 0x198 <UartClass::available()>
    12fc:	89 2b       	or	r24, r25
    12fe:	09 f4       	brne	.+2      	; 0x1302 <main+0x2be>
    1300:	35 c2       	rjmp	.+1130   	; 0x176c <main+0x728>
readFromSerial():
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdBuffer.cpp:23
    }

    ////
    // Calc Timeout
    if (timeOut != 0) {
        startTime = millis();
    1302:	0e 94 84 01 	call	0x308	; 0x308 <millis>
    1306:	4b 01       	movw	r8, r22
    1308:	5c 01       	movw	r10, r24
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdBuffer.cpp:24
        isTimeOut = startTime + timeOut;
    130a:	7c 01       	movw	r14, r24
    130c:	6b 01       	movw	r12, r22
    130e:	e8 ee       	ldi	r30, 0xE8	; 232
    1310:	ce 0e       	add	r12, r30
    1312:	e3 e0       	ldi	r30, 0x03	; 3
    1314:	de 1e       	adc	r13, r30
    1316:	e1 1c       	adc	r14, r1
    1318:	f1 1c       	adc	r15, r1
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdBuffer.cpp:27

        // overloaded
        if (isTimeOut < startTime) {
    131a:	11 e0       	ldi	r17, 0x01	; 1
    131c:	c8 14       	cp	r12, r8
    131e:	d9 04       	cpc	r13, r9
    1320:	ea 04       	cpc	r14, r10
    1322:	fb 04       	cpc	r15, r11
    1324:	08 f0       	brcs	.+2      	; 0x1328 <main+0x2e4>
    1326:	10 e0       	ldi	r17, 0x00	; 0
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdBuffer.cpp:39
    ////
    // process serial reading
    do {

        // if data in serial input buffer
        while (serial->available()) {
    1328:	8b e8       	ldi	r24, 0x8B	; 139
    132a:	99 e3       	ldi	r25, 0x39	; 57
    132c:	0e 94 cc 00 	call	0x198	; 0x198 <UartClass::available()>
    1330:	89 2b       	or	r24, r25
    1332:	09 f4       	brne	.+2      	; 0x1336 <main+0x2f2>
    1334:	ea c0       	rjmp	.+468    	; 0x150a <main+0x4c6>
readSerialChar():
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdBuffer.cpp:76
    // UART initialize?
    if (serial == NULL) {
        return false;
    }

    if (serial->available()) {
    1336:	8b e8       	ldi	r24, 0x8B	; 139
    1338:	99 e3       	ldi	r25, 0x39	; 57
    133a:	0e 94 cc 00 	call	0x198	; 0x198 <UartClass::available()>
    133e:	89 2b       	or	r24, r25
    1340:	99 f3       	breq	.-26     	; 0x1328 <main+0x2e4>
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdBuffer.cpp:78
        // is buffer full?
        if (m_dataOffset >= this->getBufferSize()) {
    1342:	80 91 36 3a 	lds	r24, 0x3A36	; 0x803a36 <myBuffer+0x4>
    1346:	90 91 37 3a 	lds	r25, 0x3A37	; 0x803a37 <myBuffer+0x5>
    134a:	80 97       	sbiw	r24, 0x20	; 32
    134c:	08 f4       	brcc	.+2      	; 0x1350 <main+0x30c>
    134e:	81 c0       	rjmp	.+258    	; 0x1452 <main+0x40e>
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdBuffer.cpp:79
            m_dataOffset = 0;
    1350:	10 92 36 3a 	sts	0x3A36, r1	; 0x803a36 <myBuffer+0x4>
    1354:	10 92 37 3a 	sts	0x3A37, r1	; 0x803a37 <myBuffer+0x5>
    1358:	e7 cf       	rjmp	.-50     	; 0x1328 <main+0x2e4>
TWI_MasterInit():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:82
      if ((PORTMUX.CTRLB & PORTMUX_TWI0_bm)) {
        // make sure we don't get errata'ed - make sure their bits in the
        // PORTx.OUT registers are 0.
        PORTA.OUTCLR=0x06; // if swapped it's on PA1, PA2
      } else {
        PORTB.OUTCLR=0x03; // else PB0, PB1
    135a:	83 e0       	ldi	r24, 0x03	; 3
    135c:	80 93 26 04 	sts	0x0426, r24	; 0x800426 <vtable for CmdBuffer<32u>+0x7f6648>
    1360:	e3 ce       	rjmp	.-570    	; 0x1128 <main+0xe4>
checkKeyStatus():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:143
    // highest note wins ignoring the three buttons

    if (buf[1] & 64) {
        return 12; // c2
    }
    if (buf[0] & 32) {
    1362:	85 fd       	sbrc	r24, 5
    1364:	19 c0       	rjmp	.+50     	; 0x1398 <main+0x354>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:146
        return 11; // b
    }
    if (buf[1] & 32) {
    1366:	25 fd       	sbrc	r18, 5
    1368:	19 c0       	rjmp	.+50     	; 0x139c <main+0x358>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:149
        return 10; // a#
    }
    if (buf[0] & 16) {
    136a:	84 fd       	sbrc	r24, 4
    136c:	19 c0       	rjmp	.+50     	; 0x13a0 <main+0x35c>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:152
        return 9; // a
    }
    if (buf[1] & 16) {
    136e:	24 fd       	sbrc	r18, 4
    1370:	19 c0       	rjmp	.+50     	; 0x13a4 <main+0x360>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:155
        return 8; // g#
    }
    if (buf[0] & 8) {
    1372:	83 fd       	sbrc	r24, 3
    1374:	19 c0       	rjmp	.+50     	; 0x13a8 <main+0x364>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:158
        return 7; // g
    }
    if (buf[1] & 8) {
    1376:	23 fd       	sbrc	r18, 3
    1378:	19 c0       	rjmp	.+50     	; 0x13ac <main+0x368>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:161
        return 6; // f#
    }
    if (buf[0] & 4) {
    137a:	82 fd       	sbrc	r24, 2
    137c:	19 c0       	rjmp	.+50     	; 0x13b0 <main+0x36c>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:164
        return 5; // f
    }
    if (buf[1] & 4) {
    137e:	22 fd       	sbrc	r18, 2
    1380:	19 c0       	rjmp	.+50     	; 0x13b4 <main+0x370>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:167
        return 4; // e
    }
    if (buf[0] & 2) {
    1382:	81 fd       	sbrc	r24, 1
    1384:	19 c0       	rjmp	.+50     	; 0x13b8 <main+0x374>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:170
        return 3; // d#
    }
    if (buf[1] & 2) {
    1386:	21 fd       	sbrc	r18, 1
    1388:	19 c0       	rjmp	.+50     	; 0x13bc <main+0x378>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:176
        return 2; // d
    }
    if (buf[0] & 1) {
        return 1; // c#
    }
    if (buf[1] & 1) {
    138a:	20 95       	com	r18
    138c:	21 70       	andi	r18, 0x01	; 1
    138e:	21 95       	neg	r18
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:173
        return 3; // d#
    }
    if (buf[1] & 2) {
        return 2; // d
    }
    if (buf[0] & 1) {
    1390:	80 ff       	sbrs	r24, 0
    1392:	86 cf       	rjmp	.-244    	; 0x12a0 <main+0x25c>
main():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:174
        return 1; // c#
    1394:	21 e0       	ldi	r18, 0x01	; 1
    1396:	84 cf       	rjmp	.-248    	; 0x12a0 <main+0x25c>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:144

    if (buf[1] & 64) {
        return 12; // c2
    }
    if (buf[0] & 32) {
        return 11; // b
    1398:	2b e0       	ldi	r18, 0x0B	; 11
    139a:	82 cf       	rjmp	.-252    	; 0x12a0 <main+0x25c>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:147
    }
    if (buf[1] & 32) {
        return 10; // a#
    139c:	2a e0       	ldi	r18, 0x0A	; 10
    139e:	80 cf       	rjmp	.-256    	; 0x12a0 <main+0x25c>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:150
    }
    if (buf[0] & 16) {
        return 9; // a
    13a0:	29 e0       	ldi	r18, 0x09	; 9
    13a2:	7e cf       	rjmp	.-260    	; 0x12a0 <main+0x25c>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:153
    }
    if (buf[1] & 16) {
        return 8; // g#
    13a4:	28 e0       	ldi	r18, 0x08	; 8
    13a6:	7c cf       	rjmp	.-264    	; 0x12a0 <main+0x25c>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:156
    }
    if (buf[0] & 8) {
        return 7; // g
    13a8:	27 e0       	ldi	r18, 0x07	; 7
    13aa:	7a cf       	rjmp	.-268    	; 0x12a0 <main+0x25c>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:159
    }
    if (buf[1] & 8) {
        return 6; // f#
    13ac:	26 e0       	ldi	r18, 0x06	; 6
    13ae:	78 cf       	rjmp	.-272    	; 0x12a0 <main+0x25c>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:162
    }
    if (buf[0] & 4) {
        return 5; // f
    13b0:	25 e0       	ldi	r18, 0x05	; 5
    13b2:	76 cf       	rjmp	.-276    	; 0x12a0 <main+0x25c>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:165
    }
    if (buf[1] & 4) {
        return 4; // e
    13b4:	24 e0       	ldi	r18, 0x04	; 4
    13b6:	74 cf       	rjmp	.-280    	; 0x12a0 <main+0x25c>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:168
    }
    if (buf[0] & 2) {
        return 3; // d#
    13b8:	23 e0       	ldi	r18, 0x03	; 3
    13ba:	72 cf       	rjmp	.-284    	; 0x12a0 <main+0x25c>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:171
    }
    if (buf[1] & 2) {
        return 2; // d
    13bc:	22 e0       	ldi	r18, 0x02	; 2
    13be:	70 cf       	rjmp	.-288    	; 0x12a0 <main+0x25c>
checkOctaveStatus():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:203
        if (previousOctaveStatus != 1) {
            previousOctaveStatus = 1;
            return 1; // k1
        }
    }
    else if (buf[0] & 128) {
    13c0:	87 ff       	sbrs	r24, 7
    13c2:	06 c0       	rjmp	.+12     	; 0x13d0 <main+0x38c>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:205

        if (previousOctaveStatus != -1) {
    13c4:	80 91 6f 38 	lds	r24, 0x386F	; 0x80386f <previousOctaveStatus>
    13c8:	8f 3f       	cpi	r24, 0xFF	; 255
    13ca:	11 f0       	breq	.+4      	; 0x13d0 <main+0x38c>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:206
            previousOctaveStatus = -1;
    13cc:	8f ef       	ldi	r24, 0xFF	; 255
    13ce:	72 cf       	rjmp	.-284    	; 0x12b4 <main+0x270>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:211
            return -1; // k3
        }
    }

    previousOctaveStatus = 0;
    13d0:	10 92 6f 38 	sts	0x386F, r1	; 0x80386f <previousOctaveStatus>
main():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:212
    return 0;
    13d4:	80 e0       	ldi	r24, 0x00	; 0
    13d6:	70 cf       	rjmp	.-288    	; 0x12b8 <main+0x274>
setNote():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:40
}

void setNote(uint8_t octave, int8_t key) {

    uint8_t noteOffset = 3 + (octave * 12) + key;
    13d8:	80 91 27 38 	lds	r24, 0x3827	; 0x803827 <currentOctave>
    13dc:	9c e0       	ldi	r25, 0x0C	; 12
    13de:	89 9f       	mul	r24, r25
    13e0:	20 0d       	add	r18, r0
    13e2:	11 24       	eor	r1, r1
    13e4:	2d 5f       	subi	r18, 0xFD	; 253
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:41
    oscillators[0].jump = notes[noteOffset];
    13e6:	30 e0       	ldi	r19, 0x00	; 0
    13e8:	f9 01       	movw	r30, r18
    13ea:	ee 0f       	add	r30, r30
    13ec:	ff 1f       	adc	r31, r31
    13ee:	ee 0f       	add	r30, r30
    13f0:	ff 1f       	adc	r31, r31
    13f2:	e0 5d       	subi	r30, 0xD0	; 208
    13f4:	f3 46       	sbci	r31, 0x63	; 99
    13f6:	80 81       	ld	r24, Z
    13f8:	91 81       	ldd	r25, Z+1	; 0x01
    13fa:	a2 81       	ldd	r26, Z+2	; 0x02
    13fc:	b3 81       	ldd	r27, Z+3	; 0x03
    13fe:	80 93 03 38 	sts	0x3803, r24	; 0x803803 <oscillators+0x2>
    1402:	90 93 04 38 	sts	0x3804, r25	; 0x803804 <oscillators+0x3>
    1406:	a0 93 05 38 	sts	0x3805, r26	; 0x803805 <oscillators+0x4>
    140a:	b0 93 06 38 	sts	0x3806, r27	; 0x803806 <oscillators+0x5>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:42
    oscillators[1].jump = notes[noteOffset + oscillators[1].detune/10]; // TODO: interpolate for the fractional part
    140e:	80 91 26 38 	lds	r24, 0x3826	; 0x803826 <oscillators+0x25>
    1412:	6a e0       	ldi	r22, 0x0A	; 10
    1414:	0e 94 d6 0d 	call	0x1bac	; 0x1bac <__divmodqi4>
    1418:	f9 01       	movw	r30, r18
    141a:	e8 0f       	add	r30, r24
    141c:	f1 1d       	adc	r31, r1
    141e:	87 fd       	sbrc	r24, 7
    1420:	fa 95       	dec	r31
    1422:	ee 0f       	add	r30, r30
    1424:	ff 1f       	adc	r31, r31
    1426:	ee 0f       	add	r30, r30
    1428:	ff 1f       	adc	r31, r31
    142a:	e0 5d       	subi	r30, 0xD0	; 208
    142c:	f3 46       	sbci	r31, 0x63	; 99
    142e:	80 81       	ld	r24, Z
    1430:	91 81       	ldd	r25, Z+1	; 0x01
    1432:	a2 81       	ldd	r26, Z+2	; 0x02
    1434:	b3 81       	ldd	r27, Z+3	; 0x03
    1436:	80 93 16 38 	sts	0x3816, r24	; 0x803816 <oscillators+0x15>
    143a:	90 93 17 38 	sts	0x3817, r25	; 0x803817 <oscillators+0x16>
    143e:	a0 93 18 38 	sts	0x3818, r26	; 0x803818 <oscillators+0x17>
    1442:	b0 93 19 38 	sts	0x3819, r27	; 0x803819 <oscillators+0x18>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:44

    isPlaying = true;
    1446:	81 e0       	ldi	r24, 0x01	; 1
    1448:	80 93 65 39 	sts	0x3965, r24	; 0x803965 <isPlaying>
    144c:	53 cf       	rjmp	.-346    	; 0x12f4 <main+0x2b0>
readFromSerial():
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdBuffer.cpp:56
                    over = false;
                }
            }

            // timeout is receive
            if (isTimeOut <= millis() && !over) {
    144e:	11 e0       	ldi	r17, 0x01	; 1
    1450:	6b cf       	rjmp	.-298    	; 0x1328 <main+0x2e4>
readSerialChar():
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdBuffer.cpp:84
            m_dataOffset = 0;
            return false;
        }

        // read into buffer
        readChar = serial->read();
    1452:	8b e8       	ldi	r24, 0x8B	; 139
    1454:	99 e3       	ldi	r25, 0x39	; 57
    1456:	0e 94 aa 00 	call	0x154	; 0x154 <UartClass::read()>
    145a:	08 2f       	mov	r16, r24
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdBuffer.cpp:86

        if (m_echo) {
    145c:	80 91 38 3a 	lds	r24, 0x3A38	; 0x803a38 <myBuffer+0x6>
    1460:	88 23       	and	r24, r24
    1462:	29 f0       	breq	.+10     	; 0x146e <main+0x42a>
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdBuffer.cpp:87
            serial->write(readChar);
    1464:	60 2f       	mov	r22, r16
    1466:	8b e8       	ldi	r24, 0x8B	; 139
    1468:	99 e3       	ldi	r25, 0x39	; 57
    146a:	0e 94 2f 01 	call	0x25e	; 0x25e <UartClass::write(unsigned char)>
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdBuffer.cpp:91
        }

        // is that the end of command
        if (readChar == m_endChar) {
    146e:	80 91 34 3a 	lds	r24, 0x3A34	; 0x803a34 <myBuffer+0x2>
    1472:	08 13       	cpse	r16, r24
    1474:	18 c0       	rjmp	.+48     	; 0x14a6 <main+0x462>
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdBuffer.cpp:92
            buffer[m_dataOffset] = '\0';
    1476:	e0 91 36 3a 	lds	r30, 0x3A36	; 0x803a36 <myBuffer+0x4>
    147a:	f0 91 37 3a 	lds	r31, 0x3A37	; 0x803a37 <myBuffer+0x5>
    147e:	e7 5c       	subi	r30, 0xC7	; 199
    1480:	f5 4c       	sbci	r31, 0xC5	; 197
    1482:	10 82       	st	Z, r1
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdBuffer.cpp:93
            m_dataOffset         = 0;
    1484:	10 92 36 3a 	sts	0x3A36, r1	; 0x803a36 <myBuffer+0x4>
    1488:	10 92 37 3a 	sts	0x3A37, r1	; 0x803a37 <myBuffer+0x5>
parseCmd():
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.cpp:24
uint16_t CmdParser::parseCmd(uint8_t *buffer, size_t bufferSize)
{
    bool isString = false;

    // init param count
    m_paramCount = 0;
    148c:	10 92 61 3a 	sts	0x3A61, r1	; 0x803a61 <cmdParser+0x7>
    1490:	10 92 62 3a 	sts	0x3A62, r1	; 0x803a62 <cmdParser+0x8>
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.cpp:27

    // buffer is not okay
    if (buffer == NULL || bufferSize == 0 || buffer[0] == 0x00) {
    1494:	80 91 39 3a 	lds	r24, 0x3A39	; 0x803a39 <myBuffer+0x7>
    1498:	81 11       	cpse	r24, r1
    149a:	4f c0       	rjmp	.+158    	; 0x153a <main+0x4f6>
updateInterface():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:74

    while (Serial.available()) {

        if (myBuffer.readFromSerial(&Serial, 1000)) {
            if (cmdParser.parseCmd(&myBuffer) == CMDPARSER_ERROR) {
                Serial.println("parser error");
    149c:	80 e3       	ldi	r24, 0x30	; 48
    149e:	9e e9       	ldi	r25, 0x9E	; 158
writeSetups():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:132
    }

    // then write these over i2c
    error = writeSetupsData(setupsData);
    if (!error) {
        Serial.println("OK");
    14a0:	0e 94 ef 02 	call	0x5de	; 0x5de <Print::println(char const*) [clone .constprop.44]>
    14a4:	27 cf       	rjmp	.-434    	; 0x12f4 <main+0x2b0>
readSerialChar():
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdBuffer.cpp:98
            return true;
        }

        // is that a backspace char?
        if ((readChar == m_bsChar) && (m_dataOffset > 0)) {
    14a6:	80 91 35 3a 	lds	r24, 0x3A35	; 0x803a35 <myBuffer+0x3>
    14aa:	08 13       	cpse	r16, r24
    14ac:	1b c0       	rjmp	.+54     	; 0x14e4 <main+0x4a0>
    14ae:	80 91 36 3a 	lds	r24, 0x3A36	; 0x803a36 <myBuffer+0x4>
    14b2:	90 91 37 3a 	lds	r25, 0x3A37	; 0x803a37 <myBuffer+0x5>
    14b6:	00 97       	sbiw	r24, 0x00	; 0
    14b8:	a9 f0       	breq	.+42     	; 0x14e4 <main+0x4a0>
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdBuffer.cpp:100
            // buffer[--m_dataOffset] = 0;
            --m_dataOffset;
    14ba:	01 97       	sbiw	r24, 0x01	; 1
    14bc:	80 93 36 3a 	sts	0x3A36, r24	; 0x803a36 <myBuffer+0x4>
    14c0:	90 93 37 3a 	sts	0x3A37, r25	; 0x803a37 <myBuffer+0x5>
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdBuffer.cpp:101
            if (m_echo) {
    14c4:	80 91 38 3a 	lds	r24, 0x3A38	; 0x803a38 <myBuffer+0x6>
    14c8:	88 23       	and	r24, r24
    14ca:	09 f4       	brne	.+2      	; 0x14ce <main+0x48a>
    14cc:	2d cf       	rjmp	.-422    	; 0x1328 <main+0x2e4>
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdBuffer.cpp:102
                serial->write(' ');
    14ce:	60 e2       	ldi	r22, 0x20	; 32
    14d0:	8b e8       	ldi	r24, 0x8B	; 139
    14d2:	99 e3       	ldi	r25, 0x39	; 57
    14d4:	0e 94 2f 01 	call	0x25e	; 0x25e <UartClass::write(unsigned char)>
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdBuffer.cpp:103
                serial->write(readChar);
    14d8:	60 2f       	mov	r22, r16
    14da:	8b e8       	ldi	r24, 0x8B	; 139
    14dc:	99 e3       	ldi	r25, 0x39	; 57
    14de:	0e 94 2f 01 	call	0x25e	; 0x25e <UartClass::write(unsigned char)>
    14e2:	22 cf       	rjmp	.-444    	; 0x1328 <main+0x2e4>
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdBuffer.cpp:109
            }
            return false;
        }

        // is a printable character
        if (readChar > CMDBUFFER_CHAR_PRINTABLE) {
    14e4:	00 32       	cpi	r16, 0x20	; 32
    14e6:	08 f4       	brcc	.+2      	; 0x14ea <main+0x4a6>
    14e8:	1f cf       	rjmp	.-450    	; 0x1328 <main+0x2e4>
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdBuffer.cpp:110
            buffer[m_dataOffset++] = readChar;
    14ea:	80 91 36 3a 	lds	r24, 0x3A36	; 0x803a36 <myBuffer+0x4>
    14ee:	90 91 37 3a 	lds	r25, 0x3A37	; 0x803a37 <myBuffer+0x5>
    14f2:	9c 01       	movw	r18, r24
    14f4:	2f 5f       	subi	r18, 0xFF	; 255
    14f6:	3f 4f       	sbci	r19, 0xFF	; 255
    14f8:	20 93 36 3a 	sts	0x3A36, r18	; 0x803a36 <myBuffer+0x4>
    14fc:	30 93 37 3a 	sts	0x3A37, r19	; 0x803a37 <myBuffer+0x5>
    1500:	87 5c       	subi	r24, 0xC7	; 199
    1502:	95 4c       	sbci	r25, 0xC5	; 197
    1504:	fc 01       	movw	r30, r24
    1506:	00 83       	st	Z, r16
    1508:	0f cf       	rjmp	.-482    	; 0x1328 <main+0x2e4>
readFromSerial():
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdBuffer.cpp:49
        }

        // Timeout is active?
        if (timeOut != 0) {
            // calc diff timeout
            if (over) {
    150a:	11 23       	and	r17, r17
    150c:	49 f0       	breq	.+18     	; 0x1520 <main+0x4dc>
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdBuffer.cpp:50
                if (startTime > millis()) {
    150e:	0e 94 84 01 	call	0x308	; 0x308 <millis>
    1512:	11 e0       	ldi	r17, 0x01	; 1
    1514:	68 15       	cp	r22, r8
    1516:	79 05       	cpc	r23, r9
    1518:	8a 05       	cpc	r24, r10
    151a:	9b 05       	cpc	r25, r11
    151c:	08 f4       	brcc	.+2      	; 0x1520 <main+0x4dc>
    151e:	10 e0       	ldi	r17, 0x00	; 0
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdBuffer.cpp:56
                    over = false;
                }
            }

            // timeout is receive
            if (isTimeOut <= millis() && !over) {
    1520:	0e 94 84 01 	call	0x308	; 0x308 <millis>
    1524:	6c 15       	cp	r22, r12
    1526:	7d 05       	cpc	r23, r13
    1528:	8e 05       	cpc	r24, r14
    152a:	9f 05       	cpc	r25, r15
    152c:	08 f4       	brcc	.+2      	; 0x1530 <main+0x4ec>
    152e:	fc ce       	rjmp	.-520    	; 0x1328 <main+0x2e4>
    1530:	11 11       	cpse	r17, r1
    1532:	8d cf       	rjmp	.-230    	; 0x144e <main+0x40a>
updateInterface():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:95

            }
        }
        else {
            //  timeout  occurred  after  starting  to  read  a  command  but  before  it  could  read  a  full  command
            Serial.println("timeout");
    1534:	84 e9       	ldi	r24, 0x94	; 148
    1536:	9e e9       	ldi	r25, 0x9E	; 158
    1538:	b3 cf       	rjmp	.-154    	; 0x14a0 <main+0x45c>
parseCmd():
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.cpp:32
        return CMDPARSER_ERROR;
    }

    // init buffer
    m_buffer     = buffer;
    153a:	29 e3       	ldi	r18, 0x39	; 57
    153c:	3a e3       	ldi	r19, 0x3A	; 58
    153e:	20 93 5d 3a 	sts	0x3A5D, r18	; 0x803a5d <cmdParser+0x3>
    1542:	30 93 5e 3a 	sts	0x3A5E, r19	; 0x803a5e <cmdParser+0x4>
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.cpp:33
    m_bufferSize = bufferSize;
    1546:	80 e2       	ldi	r24, 0x20	; 32
    1548:	90 e0       	ldi	r25, 0x00	; 0
    154a:	80 93 5f 3a 	sts	0x3A5F, r24	; 0x803a5f <cmdParser+0x5>
    154e:	90 93 60 3a 	sts	0x3A60, r25	; 0x803a60 <cmdParser+0x6>
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.cpp:47
                m_paramCount++;
            }
            return m_paramCount;
        }
        // is string "xy zyx" / only the quote option is disabled
        else if (!m_ignoreQuote && buffer[i] == CMDPARSER_CHAR_DQ) {
    1552:	b0 91 5a 3a 	lds	r27, 0x3A5A	; 0x803a5a <cmdParser>
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.cpp:52
            buffer[i] = 0x00;
            isString  = !isString;
        }
        // replace seperator with '\0'
        else if (!isString && buffer[i] == m_seperator) {
    1556:	40 91 5c 3a 	lds	r20, 0x3A5C	; 0x803a5c <cmdParser+0x2>
    155a:	04 2e       	mov	r0, r20
    155c:	00 0c       	add	r0, r0
    155e:	55 0b       	sbc	r21, r21
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.cpp:56
            buffer[i] = 0x00;
        }
        // replace = with '\0' if KEY=Value is set
        else if (!isString && m_useKeyValue && buffer[i] == CMDPARSER_CHAR_EQ) {
    1560:	a0 91 5b 3a 	lds	r26, 0x3A5B	; 0x803a5b <cmdParser+0x1>
    1564:	e2 e3       	ldi	r30, 0x32	; 50
    1566:	fa e3       	ldi	r31, 0x3A	; 58
    1568:	90 e0       	ldi	r25, 0x00	; 0
    156a:	80 e0       	ldi	r24, 0x00	; 0
main():
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.cpp:21
{
}

uint16_t CmdParser::parseCmd(uint8_t *buffer, size_t bufferSize)
{
    bool isString = false;
    156c:	60 e0       	ldi	r22, 0x00	; 0
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.cpp:37
    m_buffer     = buffer;
    m_bufferSize = bufferSize;

    ////
    // Run Parser
    for (size_t i = 0; i < bufferSize; i++) {
    156e:	30 e0       	ldi	r19, 0x00	; 0
    1570:	20 e0       	ldi	r18, 0x00	; 0
parseCmd():
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.cpp:40

        // end
        if (buffer[i] == 0x00 || m_paramCount == 0xFFFE) {
    1572:	77 81       	ldd	r23, Z+7	; 0x07
    1574:	71 11       	cpse	r23, r1
    1576:	a7 c0       	rjmp	.+334    	; 0x16c6 <main+0x682>
    1578:	80 93 61 3a 	sts	0x3A61, r24	; 0x803a61 <cmdParser+0x7>
    157c:	90 93 62 3a 	sts	0x3A62, r25	; 0x803a62 <cmdParser+0x8>
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.cpp:41
            if (i > 0 && buffer[i - 1] != 0x00) {
    1580:	21 15       	cp	r18, r1
    1582:	31 05       	cpc	r19, r1
    1584:	59 f0       	breq	.+22     	; 0x159c <main+0x558>
    1586:	28 5c       	subi	r18, 0xC8	; 200
    1588:	35 4c       	sbci	r19, 0xC5	; 197
    158a:	f9 01       	movw	r30, r18
    158c:	20 81       	ld	r18, Z
    158e:	22 23       	and	r18, r18
    1590:	29 f0       	breq	.+10     	; 0x159c <main+0x558>
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.cpp:42
                m_paramCount++;
    1592:	01 96       	adiw	r24, 0x01	; 1
    1594:	80 93 61 3a 	sts	0x3A61, r24	; 0x803a61 <cmdParser+0x7>
    1598:	90 93 62 3a 	sts	0x3A62, r25	; 0x803a62 <cmdParser+0x8>
updateInterface():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:73
    }

    while (Serial.available()) {

        if (myBuffer.readFromSerial(&Serial, 1000)) {
            if (cmdParser.parseCmd(&myBuffer) == CMDPARSER_ERROR) {
    159c:	80 91 61 3a 	lds	r24, 0x3A61	; 0x803a61 <cmdParser+0x7>
    15a0:	90 91 62 3a 	lds	r25, 0x3A62	; 0x803a62 <cmdParser+0x8>
    15a4:	01 96       	adiw	r24, 0x01	; 1
    15a6:	09 f4       	brne	.+2      	; 0x15aa <main+0x566>
    15a8:	79 cf       	rjmp	.-270    	; 0x149c <main+0x458>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:77
                Serial.println("parser error");
            }
            else {
                Serial.println(".");
    15aa:	8d e3       	ldi	r24, 0x3D	; 61
    15ac:	9e e9       	ldi	r25, 0x9E	; 158
    15ae:	0e 94 ef 02 	call	0x5de	; 0x5de <Print::println(char const*) [clone .constprop.44]>
equalCommand():
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.hpp:123
     * @param value             String to compare
     * @return                  TRUE is equal
     */
    bool equalCommand(CmdParserString value)
    {
        return this->equalCmdParam(0, value);
    15b2:	8f e3       	ldi	r24, 0x3F	; 63
    15b4:	9e e9       	ldi	r25, 0x9E	; 158
    15b6:	0e 94 99 03 	call	0x732	; 0x732 <CmdParser::equalCmdParam(unsigned int, char const*) [clone .constprop.22]>
updateInterface():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:79

                if (cmdParser.equalCommand("RSTATUS") && cmdParser.getParamCount() == 1) {
    15ba:	88 23       	and	r24, r24
    15bc:	c9 f0       	breq	.+50     	; 0x15f0 <main+0x5ac>
    15be:	80 91 61 3a 	lds	r24, 0x3A61	; 0x803a61 <cmdParser+0x7>
    15c2:	90 91 62 3a 	lds	r25, 0x3A62	; 0x803a62 <cmdParser+0x8>
    15c6:	01 97       	sbiw	r24, 0x01	; 1
    15c8:	99 f4       	brne	.+38     	; 0x15f0 <main+0x5ac>
readStatus():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:103
}

void readStatus() {

    // 4 to 123: key data (120 bytes)
    readTouchData(4, 120, keyData);
    15ca:	40 e7       	ldi	r20, 0x70	; 112
    15cc:	58 e3       	ldi	r21, 0x38	; 56
    15ce:	68 e7       	ldi	r22, 0x78	; 120
    15d0:	84 e0       	ldi	r24, 0x04	; 4
    15d2:	0e 94 10 03 	call	0x620	; 0x620 <readTouchData(unsigned char, unsigned char, unsigned char*)>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:104
    Serial.print("STATUS");
    15d6:	80 e4       	ldi	r24, 0x40	; 64
    15d8:	9e e9       	ldi	r25, 0x9E	; 158
    15da:	0e 94 ed 02 	call	0x5da	; 0x5da <Print::print(char const*) [clone .constprop.49]>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:105
    printTouchData(120, keyData);
    15de:	60 e7       	ldi	r22, 0x70	; 112
    15e0:	78 e3       	ldi	r23, 0x38	; 56
    15e2:	88 e7       	ldi	r24, 0x78	; 120
    15e4:	0e 94 6a 03 	call	0x6d4	; 0x6d4 <printTouchData(unsigned char, unsigned char*)>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:106
    Serial.println("");
    15e8:	8a ee       	ldi	r24, 0xEA	; 234
    15ea:	9d e9       	ldi	r25, 0x9D	; 157
    15ec:	0e 94 ef 02 	call	0x5de	; 0x5de <Print::println(char const*) [clone .constprop.44]>
equalCommand():
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.hpp:123
    15f0:	87 e4       	ldi	r24, 0x47	; 71
    15f2:	9e e9       	ldi	r25, 0x9E	; 158
    15f4:	0e 94 99 03 	call	0x732	; 0x732 <CmdParser::equalCmdParam(unsigned int, char const*) [clone .constprop.22]>
updateInterface():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:83

                if (cmdParser.equalCommand("RSTATUS") && cmdParser.getParamCount() == 1) {
                    readStatus();
                }

                if (cmdParser.equalCommand("RSETUPS") && cmdParser.getParamCount() == 1) {
    15f8:	88 23       	and	r24, r24
    15fa:	c9 f0       	breq	.+50     	; 0x162e <main+0x5ea>
    15fc:	80 91 61 3a 	lds	r24, 0x3A61	; 0x803a61 <cmdParser+0x7>
    1600:	90 91 62 3a 	lds	r25, 0x3A62	; 0x803a62 <cmdParser+0x8>
    1604:	01 97       	sbiw	r24, 0x01	; 1
    1606:	99 f4       	brne	.+38     	; 0x162e <main+0x5ea>
readSetups():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:112
}

void readSetups() {

    // 131 to 253: setups (123 bytes)
    readTouchData(131, 123, setupsData);
    1608:	48 ee       	ldi	r20, 0xE8	; 232
    160a:	58 e3       	ldi	r21, 0x38	; 56
    160c:	6b e7       	ldi	r22, 0x7B	; 123
    160e:	83 e8       	ldi	r24, 0x83	; 131
    1610:	0e 94 10 03 	call	0x620	; 0x620 <readTouchData(unsigned char, unsigned char, unsigned char*)>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:113
    Serial.print("SETUPS");
    1614:	88 e4       	ldi	r24, 0x48	; 72
    1616:	9e e9       	ldi	r25, 0x9E	; 158
    1618:	0e 94 ed 02 	call	0x5da	; 0x5da <Print::print(char const*) [clone .constprop.49]>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:114
    printTouchData(123, setupsData);
    161c:	68 ee       	ldi	r22, 0xE8	; 232
    161e:	78 e3       	ldi	r23, 0x38	; 56
    1620:	8b e7       	ldi	r24, 0x7B	; 123
    1622:	0e 94 6a 03 	call	0x6d4	; 0x6d4 <printTouchData(unsigned char, unsigned char*)>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:115
    Serial.println("");
    1626:	8a ee       	ldi	r24, 0xEA	; 234
    1628:	9d e9       	ldi	r25, 0x9D	; 157
    162a:	0e 94 ef 02 	call	0x5de	; 0x5de <Print::println(char const*) [clone .constprop.44]>
equalCommand():
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.hpp:123
    162e:	8f e4       	ldi	r24, 0x4F	; 79
    1630:	9e e9       	ldi	r25, 0x9E	; 158
    1632:	0e 94 99 03 	call	0x732	; 0x732 <CmdParser::equalCmdParam(unsigned int, char const*) [clone .constprop.22]>
updateInterface():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:87

                if (cmdParser.equalCommand("RSETUPS") && cmdParser.getParamCount() == 1) {
                    readSetups();
                }

                if (cmdParser.equalCommand("WSETUPS") && cmdParser.getParamCount() == 1) {
    1636:	88 23       	and	r24, r24
    1638:	09 f4       	brne	.+2      	; 0x163c <main+0x5f8>
    163a:	5c ce       	rjmp	.-840    	; 0x12f4 <main+0x2b0>
    163c:	80 91 61 3a 	lds	r24, 0x3A61	; 0x803a61 <cmdParser+0x7>
    1640:	90 91 62 3a 	lds	r25, 0x3A62	; 0x803a62 <cmdParser+0x8>
    1644:	01 97       	sbiw	r24, 0x01	; 1
    1646:	09 f0       	breq	.+2      	; 0x164a <main+0x606>
    1648:	55 ce       	rjmp	.-854    	; 0x12f4 <main+0x2b0>
readHexCharsFromSerial():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:94
  }
}

uint8_t readHexCharsFromSerial(int count, uint8_t * buf) {

  unsigned long start = millis();
    164a:	0e 94 84 01 	call	0x308	; 0x308 <millis>
    164e:	28 ee       	ldi	r18, 0xE8	; 232
    1650:	38 e3       	ldi	r19, 0x38	; 56
    1652:	2e 83       	std	Y+6, r18	; 0x06
    1654:	3f 83       	std	Y+7, r19	; 0x07
    1656:	28 87       	std	Y+8, r18	; 0x08
    1658:	39 87       	std	Y+9, r19	; 0x09
main():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:95
  int numProcessed = 0;
    165a:	f1 2c       	mov	r15, r1
    165c:	e1 2c       	mov	r14, r1
readHexCharsFromSerial():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:100
  char charBuf[3];
  uint8_t numChars = 0;

  while (numProcessed < count) {
    if (millis() > start + SERIAL_READ_TIMEOUT) {
    165e:	4b 01       	movw	r8, r22
    1660:	5c 01       	movw	r10, r24
    1662:	f8 ee       	ldi	r31, 0xE8	; 232
    1664:	8f 0e       	add	r8, r31
    1666:	f3 e0       	ldi	r31, 0x03	; 3
    1668:	9f 1e       	adc	r9, r31
    166a:	a1 1c       	adc	r10, r1
    166c:	b1 1c       	adc	r11, r1
    166e:	8e 01       	movw	r16, r28
    1670:	0f 5f       	subi	r16, 0xFF	; 255
    1672:	1f 4f       	sbci	r17, 0xFF	; 255
    1674:	18 01       	movw	r2, r16
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:99
  unsigned long start = millis();
  int numProcessed = 0;
  char charBuf[3];
  uint8_t numChars = 0;

  while (numProcessed < count) {
    1676:	2b e7       	ldi	r18, 0x7B	; 123
    1678:	e2 16       	cp	r14, r18
    167a:	f1 04       	cpc	r15, r1
    167c:	09 f4       	brne	.+2      	; 0x1680 <main+0x63c>
    167e:	b4 c0       	rjmp	.+360    	; 0x17e8 <main+0x7a4>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:100
    if (millis() > start + SERIAL_READ_TIMEOUT) {
    1680:	0e 94 84 01 	call	0x308	; 0x308 <millis>
    1684:	86 16       	cp	r8, r22
    1686:	97 06       	cpc	r9, r23
    1688:	a8 06       	cpc	r10, r24
    168a:	b9 06       	cpc	r11, r25
    168c:	08 f4       	brcc	.+2      	; 0x1690 <main+0x64c>
    168e:	9b c0       	rjmp	.+310    	; 0x17c6 <main+0x782>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:104
        return ERROR_SERIAL_PARSE_TIMEOUT; // timeout error;
    }

    if (!Serial.available()) {
    1690:	8b e8       	ldi	r24, 0x8B	; 139
    1692:	99 e3       	ldi	r25, 0x39	; 57
    1694:	0e 94 cc 00 	call	0x198	; 0x198 <UartClass::available()>
    1698:	89 2b       	or	r24, r25
    169a:	69 f3       	breq	.-38     	; 0x1676 <main+0x632>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:108
      continue; // try again next time
    }

    charBuf[numChars] = Serial.read();
    169c:	8b e8       	ldi	r24, 0x8B	; 139
    169e:	99 e3       	ldi	r25, 0x39	; 57
    16a0:	0e 94 aa 00 	call	0x154	; 0x154 <UartClass::read()>
    16a4:	f8 01       	movw	r30, r16
    16a6:	81 93       	st	Z+, r24
    16a8:	8f 01       	movw	r16, r30
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:111
    ++numChars;

    if (numChars != 3) {
    16aa:	2c 81       	ldd	r18, Y+4	; 0x04
    16ac:	3d 81       	ldd	r19, Y+5	; 0x05
    16ae:	e2 17       	cp	r30, r18
    16b0:	f3 07       	cpc	r31, r19
    16b2:	09 f7       	brne	.-62     	; 0x1676 <main+0x632>
    16b4:	8b 81       	ldd	r24, Y+3	; 0x03
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:118
    }

    // every third character we parse the two-char hex number and start over again

    // check that the third char is a space for all chars except the last one where it should be a \r
    if (numProcessed == count - 1) {
    16b6:	3a e7       	ldi	r19, 0x7A	; 122
    16b8:	e3 16       	cp	r14, r19
    16ba:	f1 04       	cpc	r15, r1
    16bc:	99 f5       	brne	.+102    	; 0x1724 <main+0x6e0>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:119
      if (charBuf[2] != '\r') {
    16be:	8d 30       	cpi	r24, 0x0D	; 13
    16c0:	a1 f1       	breq	.+104    	; 0x172a <main+0x6e6>
main():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:120
        return ERROR_SERIAL_PARSE_RETURN; // parse error
    16c2:	12 e0       	ldi	r17, 0x02	; 2
    16c4:	81 c0       	rjmp	.+258    	; 0x17c8 <main+0x784>
parseCmd():
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.cpp:40
    ////
    // Run Parser
    for (size_t i = 0; i < bufferSize; i++) {

        // end
        if (buffer[i] == 0x00 || m_paramCount == 0xFFFE) {
    16c6:	8e 3f       	cpi	r24, 0xFE	; 254
    16c8:	1f ef       	ldi	r17, 0xFF	; 255
    16ca:	91 07       	cpc	r25, r17
    16cc:	09 f4       	brne	.+2      	; 0x16d0 <main+0x68c>
    16ce:	54 cf       	rjmp	.-344    	; 0x1578 <main+0x534>
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.cpp:47
                m_paramCount++;
            }
            return m_paramCount;
        }
        // is string "xy zyx" / only the quote option is disabled
        else if (!m_ignoreQuote && buffer[i] == CMDPARSER_CHAR_DQ) {
    16d0:	b1 11       	cpse	r27, r1
    16d2:	0d c0       	rjmp	.+26     	; 0x16ee <main+0x6aa>
    16d4:	72 32       	cpi	r23, 0x22	; 34
    16d6:	59 f4       	brne	.+22     	; 0x16ee <main+0x6aa>
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.cpp:48
            buffer[i] = 0x00;
    16d8:	17 82       	std	Z+7, r1	; 0x07
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.cpp:49
            isString  = !isString;
    16da:	11 e0       	ldi	r17, 0x01	; 1
    16dc:	61 27       	eor	r22, r17
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.cpp:61
        else if (!isString && m_useKeyValue && buffer[i] == CMDPARSER_CHAR_EQ) {
            buffer[i] = 0x00;
        }

        // count
        if (i > 0 && buffer[i] == 0x00 && buffer[i - 1] != 0x00) {
    16de:	21 15       	cp	r18, r1
    16e0:	31 05       	cpc	r19, r1
    16e2:	81 f0       	breq	.+32     	; 0x1704 <main+0x6c0>
    16e4:	76 81       	ldd	r23, Z+6	; 0x06
    16e6:	77 23       	and	r23, r23
    16e8:	69 f0       	breq	.+26     	; 0x1704 <main+0x6c0>
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.cpp:62
            m_paramCount++;
    16ea:	01 96       	adiw	r24, 0x01	; 1
    16ec:	0b c0       	rjmp	.+22     	; 0x1704 <main+0x6c0>
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.cpp:52
        else if (!m_ignoreQuote && buffer[i] == CMDPARSER_CHAR_DQ) {
            buffer[i] = 0x00;
            isString  = !isString;
        }
        // replace seperator with '\0'
        else if (!isString && buffer[i] == m_seperator) {
    16ee:	61 11       	cpse	r22, r1
    16f0:	15 c0       	rjmp	.+42     	; 0x171c <main+0x6d8>
    16f2:	74 17       	cp	r23, r20
    16f4:	15 06       	cpc	r1, r21
    16f6:	11 f4       	brne	.+4      	; 0x16fc <main+0x6b8>
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.cpp:57
            buffer[i] = 0x00;
        }
        // replace = with '\0' if KEY=Value is set
        else if (!isString && m_useKeyValue && buffer[i] == CMDPARSER_CHAR_EQ) {
            buffer[i] = 0x00;
    16f8:	17 82       	std	Z+7, r1	; 0x07
    16fa:	f1 cf       	rjmp	.-30     	; 0x16de <main+0x69a>
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.cpp:56
        // replace seperator with '\0'
        else if (!isString && buffer[i] == m_seperator) {
            buffer[i] = 0x00;
        }
        // replace = with '\0' if KEY=Value is set
        else if (!isString && m_useKeyValue && buffer[i] == CMDPARSER_CHAR_EQ) {
    16fc:	aa 23       	and	r26, r26
    16fe:	81 f0       	breq	.+32     	; 0x1720 <main+0x6dc>
    1700:	7d 33       	cpi	r23, 0x3D	; 61
    1702:	d1 f3       	breq	.-12     	; 0x16f8 <main+0x6b4>
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.cpp:37
    m_buffer     = buffer;
    m_bufferSize = bufferSize;

    ////
    // Run Parser
    for (size_t i = 0; i < bufferSize; i++) {
    1704:	2f 5f       	subi	r18, 0xFF	; 255
    1706:	3f 4f       	sbci	r19, 0xFF	; 255
    1708:	31 96       	adiw	r30, 0x01	; 1
    170a:	20 32       	cpi	r18, 0x20	; 32
    170c:	31 05       	cpc	r19, r1
    170e:	09 f0       	breq	.+2      	; 0x1712 <main+0x6ce>
    1710:	30 cf       	rjmp	.-416    	; 0x1572 <main+0x52e>
    1712:	80 93 61 3a 	sts	0x3A61, r24	; 0x803a61 <cmdParser+0x7>
    1716:	90 93 62 3a 	sts	0x3A62, r25	; 0x803a62 <cmdParser+0x8>
    171a:	47 cf       	rjmp	.-370    	; 0x15aa <main+0x566>
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.cpp:52
        else if (!m_ignoreQuote && buffer[i] == CMDPARSER_CHAR_DQ) {
            buffer[i] = 0x00;
            isString  = !isString;
        }
        // replace seperator with '\0'
        else if (!isString && buffer[i] == m_seperator) {
    171c:	61 e0       	ldi	r22, 0x01	; 1
    171e:	f2 cf       	rjmp	.-28     	; 0x1704 <main+0x6c0>
/Users/lerouxb/Documents/Arduino/libraries/CmdParser/src/CmdParser.cpp:56
            buffer[i] = 0x00;
        }
        // replace = with '\0' if KEY=Value is set
        else if (!isString && m_useKeyValue && buffer[i] == CMDPARSER_CHAR_EQ) {
    1720:	6a 2f       	mov	r22, r26
    1722:	f0 cf       	rjmp	.-32     	; 0x1704 <main+0x6c0>
readHexCharsFromSerial():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:124
      }
    }
    else {
      if (charBuf[2] != ' ') {
    1724:	80 32       	cpi	r24, 0x20	; 32
    1726:	09 f0       	breq	.+2      	; 0x172a <main+0x6e6>
    1728:	5d c0       	rjmp	.+186    	; 0x17e4 <main+0x7a0>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:129
        return ERROR_SERIAL_PARSE_SPACE; // parse error
      }
    }

    buf[numProcessed] = (uint8_t) strtol(charBuf, 0, 16);
    172a:	40 e1       	ldi	r20, 0x10	; 16
    172c:	50 e0       	ldi	r21, 0x00	; 0
    172e:	70 e0       	ldi	r23, 0x00	; 0
    1730:	60 e0       	ldi	r22, 0x00	; 0
    1732:	c1 01       	movw	r24, r2
    1734:	0e 94 36 0c 	call	0x186c	; 0x186c <strtol>
    1738:	e8 85       	ldd	r30, Y+8	; 0x08
    173a:	f9 85       	ldd	r31, Y+9	; 0x09
    173c:	61 93       	st	Z+, r22
    173e:	e8 87       	std	Y+8, r30	; 0x08
    1740:	f9 87       	std	Y+9, r31	; 0x09
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:132

    numChars = 0;
    ++numProcessed;
    1742:	ff ef       	ldi	r31, 0xFF	; 255
    1744:	ef 1a       	sub	r14, r31
    1746:	ff 0a       	sbc	r15, r31
    1748:	92 cf       	rjmp	.-220    	; 0x166e <main+0x62a>
writeSetupsData():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:148
  Wire.write(130); // setups write unlock
  Wire.write(0x55); // unlock write
  error = Wire.endTransmission(false);

  if (error) {
    Serial.print("oopsie (write unlock): ");
    174a:	87 e5       	ldi	r24, 0x57	; 87
    174c:	9e e9       	ldi	r25, 0x9E	; 158
    174e:	0e 94 ed 02 	call	0x5da	; 0x5da <Print::print(char const*) [clone .constprop.49]>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:149
    Serial.println(error);
    1752:	81 2f       	mov	r24, r17
    1754:	0e 94 fd 02 	call	0x5fa	; 0x5fa <Print::println(unsigned char, int) [clone .constprop.50]>
    1758:	cd cd       	rjmp	.-1126   	; 0x12f4 <main+0x2b0>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:153
    return error;
  }

  for (int i = 0; i < 123; ++i) {
    175a:	0f 5f       	subi	r16, 0xFF	; 255
    175c:	1f 4f       	sbci	r17, 0xFF	; 255
    175e:	0b 37       	cpi	r16, 0x7B	; 123
    1760:	11 05       	cpc	r17, r1
    1762:	09 f0       	breq	.+2      	; 0x1766 <main+0x722>
    1764:	57 c0       	rjmp	.+174    	; 0x1814 <main+0x7d0>
writeSetups():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:132
    }

    // then write these over i2c
    error = writeSetupsData(setupsData);
    if (!error) {
        Serial.println("OK");
    1766:	8b ef       	ldi	r24, 0xFB	; 251
    1768:	9d e9       	ldi	r25, 0x9D	; 157
    176a:	9a ce       	rjmp	.-716    	; 0x14a0 <main+0x45c>
loop():
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:74

    updateInterface();

    // clear interrupts before double-checking to eliminate race conditions
    // see https://www.nongnu.org/avr-libc/user-manual/group__avr__sleep.html
    cli();
    176c:	f8 94       	cli
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:75
    if (goToSleep) {
    176e:	80 91 67 39 	lds	r24, 0x3967	; 0x803967 <goToSleep>
    1772:	88 23       	and	r24, r24
    1774:	31 f1       	breq	.+76     	; 0x17c2 <main+0x77e>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:77
        // reset goToSleep regardless so that it will be re-set if we don't go to sleep and it still applies
        goToSleep = false;
    1776:	10 92 67 39 	sts	0x3967, r1	; 0x803967 <goToSleep>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:80

        // don't go to sleep if there are unprocessed touch events because the touch sensor won't set the change pin high again until we read it. Therefore we have to make very sure we read everything and that it is low so that things don't get stuck
        if (!touchChanged && !isPlaying && digitalRead(CHANGE_PIN) == LOW) {
    177a:	80 91 66 39 	lds	r24, 0x3966	; 0x803966 <touchChanged>
    177e:	81 11       	cpse	r24, r1
    1780:	20 c0       	rjmp	.+64     	; 0x17c2 <main+0x77e>
    1782:	80 91 65 39 	lds	r24, 0x3965	; 0x803965 <isPlaying>
    1786:	81 11       	cpse	r24, r1
    1788:	1c c0       	rjmp	.+56     	; 0x17c2 <main+0x77e>
    178a:	0e 94 f2 03 	call	0x7e4	; 0x7e4 <digitalRead.constprop.3>
    178e:	81 11       	cpse	r24, r1
    1790:	18 c0       	rjmp	.+48     	; 0x17c2 <main+0x77e>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:81
            sei();
    1792:	78 94       	sei
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:82
            Serial.flush();
    1794:	8b e8       	ldi	r24, 0x8B	; 139
    1796:	99 e3       	ldi	r25, 0x39	; 57
    1798:	0e 94 6d 01 	call	0x2da	; 0x2da <UartClass::flush()>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:83
            Serial.println("going to sleep");
    179c:	8e e7       	ldi	r24, 0x7E	; 126
    179e:	9e e9       	ldi	r25, 0x9E	; 158
    17a0:	0e 94 ef 02 	call	0x5de	; 0x5de <Print::println(char const*) [clone .constprop.44]>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:84
            Serial.flush();
    17a4:	8b e8       	ldi	r24, 0x8B	; 139
    17a6:	99 e3       	ldi	r25, 0x39	; 57
    17a8:	0e 94 6d 01 	call	0x2da	; 0x2da <UartClass::flush()>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:87

            // tripple-check because interrupts are on and we printed things which takes time
            cli();
    17ac:	f8 94       	cli
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:88
            if (digitalRead(CHANGE_PIN) == LOW) {
    17ae:	0e 94 f2 03 	call	0x7e4	; 0x7e4 <digitalRead.constprop.3>
    17b2:	81 11       	cpse	r24, r1
    17b4:	02 c0       	rjmp	.+4      	; 0x17ba <main+0x776>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:89
                sei(); // in theory sleep_cpu() straight after sei() is atomic
    17b6:	78 94       	sei
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:90
                sleep_cpu();
    17b8:	88 95       	sleep
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:93
            }

            Serial.println("awake!");
    17ba:	8d e8       	ldi	r24, 0x8D	; 141
    17bc:	9e e9       	ldi	r25, 0x9E	; 158
    17be:	0e 94 ef 02 	call	0x5de	; 0x5de <Print::println(char const*) [clone .constprop.44]>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:97
        }
    }

    sei(); // in case either if up top was false
    17c2:	78 94       	sei
    17c4:	06 cd       	rjmp	.-1524   	; 0x11d2 <main+0x18e>
main():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:101
  char charBuf[3];
  uint8_t numChars = 0;

  while (numProcessed < count) {
    if (millis() > start + SERIAL_READ_TIMEOUT) {
        return ERROR_SERIAL_PARSE_TIMEOUT; // timeout error;
    17c6:	11 e0       	ldi	r17, 0x01	; 1
writeSetups():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:123
void writeSetups() {
    // read 123 bytes from serial as two-character hex codes separated by spaces, then a \r
    uint8_t error = readHexCharsFromSerial(123, setupsData);

    if (error) {
        Serial.print("error reading hex chars: ");
    17c8:	8c e9       	ldi	r24, 0x9C	; 156
    17ca:	9e e9       	ldi	r25, 0x9E	; 158
    17cc:	0e 94 ed 02 	call	0x5da	; 0x5da <Print::print(char const*) [clone .constprop.49]>
print():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:75
size_t Print::print(char c) {
  return write(c);
}

size_t Print::print(unsigned char b, int base) {
  return print((unsigned long) b, base);
    17d0:	61 2f       	mov	r22, r17
    17d2:	70 e0       	ldi	r23, 0x00	; 0
    17d4:	90 e0       	ldi	r25, 0x00	; 0
    17d6:	80 e0       	ldi	r24, 0x00	; 0
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:105

size_t Print::print(unsigned long n, int base) {
  if (base == 0) {
    return write(n);
  } else {
    return printNumber(n, base);
    17d8:	4a e0       	ldi	r20, 0x0A	; 10
    17da:	0e 94 af 02 	call	0x55e	; 0x55e <Print::printNumber(unsigned long, unsigned char) [clone .constprop.54]>
writeSetups():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:125
        Serial.print(error);
        Serial.println("");
    17de:	8a ee       	ldi	r24, 0xEA	; 234
    17e0:	9d e9       	ldi	r25, 0x9D	; 157
    17e2:	5e ce       	rjmp	.-836    	; 0x14a0 <main+0x45c>
main():
        return ERROR_SERIAL_PARSE_RETURN; // parse error
      }
    }
    else {
      if (charBuf[2] != ' ') {
        return ERROR_SERIAL_PARSE_SPACE; // parse error
    17e4:	13 e0       	ldi	r17, 0x03	; 3
    17e6:	f0 cf       	rjmp	.-32     	; 0x17c8 <main+0x784>
beginTransmission():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:256

void TwoWire::beginTransmission(uint8_t address) {
  // indicate that we are transmitting
  transmitting = 1;
  // set address of targeted slave
  txAddress = address;
    17e8:	f5 e7       	ldi	r31, 0x75	; 117
    17ea:	f0 93 89 39 	sts	0x3989, r31	; 0x803989 <TwoWire::txAddress>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:258
  // reset tx buffer iterator vars
  txBufferIndex = 0;
    17ee:	10 92 68 39 	sts	0x3968, r1	; 0x803968 <TwoWire::txBufferIndex>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:259
  txBufferLength = 0;
    17f2:	10 92 8a 39 	sts	0x398A, r1	; 0x80398a <TwoWire::txBufferLength>
writeSetupsData():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:143
uint8_t writeSetupsData(uint8_t * buf) {

  uint8_t error;

  Wire.beginTransmission(TOUCH_ADDRESS);
  Wire.write(130); // setups write unlock
    17f6:	82 e8       	ldi	r24, 0x82	; 130
    17f8:	90 e0       	ldi	r25, 0x00	; 0
    17fa:	0e 94 94 02 	call	0x528	; 0x528 <TwoWire::write(int) [clone .constprop.58]>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:144
  Wire.write(0x55); // unlock write
    17fe:	85 e5       	ldi	r24, 0x55	; 85
    1800:	90 e0       	ldi	r25, 0x00	; 0
    1802:	0e 94 94 02 	call	0x528	; 0x528 <TwoWire::write(int) [clone .constprop.58]>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:145
  error = Wire.endTransmission(false);
    1806:	0e 94 19 02 	call	0x432	; 0x432 <TwoWire::endTransmission(bool) [clone .constprop.47]>
    180a:	18 2f       	mov	r17, r24
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:147

  if (error) {
    180c:	81 11       	cpse	r24, r1
    180e:	9d cf       	rjmp	.-198    	; 0x174a <main+0x706>
main():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:153
    Serial.print("oopsie (write unlock): ");
    Serial.println(error);
    return error;
  }

  for (int i = 0; i < 123; ++i) {
    1810:	10 e0       	ldi	r17, 0x00	; 0
    1812:	00 e0       	ldi	r16, 0x00	; 0
beginTransmission():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:256

void TwoWire::beginTransmission(uint8_t address) {
  // indicate that we are transmitting
  transmitting = 1;
  // set address of targeted slave
  txAddress = address;
    1814:	25 e7       	ldi	r18, 0x75	; 117
    1816:	20 93 89 39 	sts	0x3989, r18	; 0x803989 <TwoWire::txAddress>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:258
  // reset tx buffer iterator vars
  txBufferIndex = 0;
    181a:	10 92 68 39 	sts	0x3968, r1	; 0x803968 <TwoWire::txBufferIndex>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:259
  txBufferLength = 0;
    181e:	10 92 8a 39 	sts	0x398A, r1	; 0x80398a <TwoWire::txBufferLength>
writeSetupsData():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:155
    Wire.beginTransmission(TOUCH_ADDRESS);
    Wire.write(131 + i);
    1822:	c8 01       	movw	r24, r16
    1824:	8d 57       	subi	r24, 0x7D	; 125
    1826:	9f 4f       	sbci	r25, 0xFF	; 255
    1828:	0e 94 94 02 	call	0x528	; 0x528 <TwoWire::write(int) [clone .constprop.58]>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:156
    Wire.write(buf[i]);
    182c:	ee 81       	ldd	r30, Y+6	; 0x06
    182e:	ff 81       	ldd	r31, Y+7	; 0x07
    1830:	61 91       	ld	r22, Z+
    1832:	ee 83       	std	Y+6, r30	; 0x06
    1834:	ff 83       	std	Y+7, r31	; 0x07
    1836:	86 e2       	ldi	r24, 0x26	; 38
    1838:	9a e3       	ldi	r25, 0x3A	; 58
    183a:	0e 94 79 02 	call	0x4f2	; 0x4f2 <TwoWire::write(unsigned char)>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:157
    error = Wire.endTransmission(false);
    183e:	0e 94 19 02 	call	0x432	; 0x432 <TwoWire::endTransmission(bool) [clone .constprop.47]>
    1842:	f8 2e       	mov	r15, r24
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:159

    if (error) {
    1844:	88 23       	and	r24, r24
    1846:	09 f4       	brne	.+2      	; 0x184a <main+0x806>
    1848:	88 cf       	rjmp	.-240    	; 0x175a <main+0x716>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:160
      Serial.print("oopsie (write ");
    184a:	8f e6       	ldi	r24, 0x6F	; 111
    184c:	9e e9       	ldi	r25, 0x9E	; 158
    184e:	0e 94 ed 02 	call	0x5da	; 0x5da <Print::print(char const*) [clone .constprop.49]>
print():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:95
    if (n < 0) {
      int t = print('-');
      n = -n;
      return printNumber(n, 10) + t;
    }
    return printNumber(n, 10);
    1852:	b8 01       	movw	r22, r16
    1854:	11 0f       	add	r17, r17
    1856:	88 0b       	sbc	r24, r24
    1858:	99 0b       	sbc	r25, r25
    185a:	4a e0       	ldi	r20, 0x0A	; 10
    185c:	0e 94 af 02 	call	0x55e	; 0x55e <Print::printNumber(unsigned long, unsigned char) [clone .constprop.54]>
writeSetupsData():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:162
      Serial.print(i);
      Serial.print("): ");
    1860:	8a e0       	ldi	r24, 0x0A	; 10
    1862:	9e e9       	ldi	r25, 0x9E	; 158
    1864:	0e 94 ed 02 	call	0x5da	; 0x5da <Print::print(char const*) [clone .constprop.49]>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/QT60240.cpp:163
      Serial.println(error);
    1868:	8f 2d       	mov	r24, r15
    186a:	74 cf       	rjmp	.-280    	; 0x1754 <main+0x710>

0000186c <strtol>:
strtol():
    186c:	b0 e0       	ldi	r27, 0x00	; 0
    186e:	a0 e0       	ldi	r26, 0x00	; 0
    1870:	ec e3       	ldi	r30, 0x3C	; 60
    1872:	fc e0       	ldi	r31, 0x0C	; 12
    1874:	0c 94 97 0d 	jmp	0x1b2e	; 0x1b2e <__prologue_saves__+0x2>
    1878:	5c 01       	movw	r10, r24
    187a:	6b 01       	movw	r12, r22
    187c:	7a 01       	movw	r14, r20
    187e:	61 15       	cp	r22, r1
    1880:	71 05       	cpc	r23, r1
    1882:	19 f0       	breq	.+6      	; 0x188a <strtol+0x1e>
    1884:	fb 01       	movw	r30, r22
    1886:	80 83       	st	Z, r24
    1888:	91 83       	std	Z+1, r25	; 0x01
    188a:	e1 14       	cp	r14, r1
    188c:	f1 04       	cpc	r15, r1
    188e:	51 f0       	breq	.+20     	; 0x18a4 <strtol+0x38>
    1890:	c7 01       	movw	r24, r14
    1892:	02 97       	sbiw	r24, 0x02	; 2
    1894:	83 97       	sbiw	r24, 0x23	; 35
    1896:	30 f0       	brcs	.+12     	; 0x18a4 <strtol+0x38>
    1898:	40 e0       	ldi	r20, 0x00	; 0
    189a:	30 e0       	ldi	r19, 0x00	; 0
    189c:	20 e0       	ldi	r18, 0x00	; 0
    189e:	90 e0       	ldi	r25, 0x00	; 0
    18a0:	72 c0       	rjmp	.+228    	; 0x1986 <strtol+0x11a>
    18a2:	5e 01       	movw	r10, r28
    18a4:	e5 01       	movw	r28, r10
    18a6:	21 96       	adiw	r28, 0x01	; 1
    18a8:	f5 01       	movw	r30, r10
    18aa:	10 81       	ld	r17, Z
    18ac:	81 2f       	mov	r24, r17
    18ae:	90 e0       	ldi	r25, 0x00	; 0
    18b0:	0e 94 4d 0d 	call	0x1a9a	; 0x1a9a <isspace>
    18b4:	89 2b       	or	r24, r25
    18b6:	a9 f7       	brne	.-22     	; 0x18a2 <strtol+0x36>
    18b8:	1d 32       	cpi	r17, 0x2D	; 45
    18ba:	01 f5       	brne	.+64     	; 0x18fc <strtol+0x90>
    18bc:	21 96       	adiw	r28, 0x01	; 1
    18be:	f5 01       	movw	r30, r10
    18c0:	11 81       	ldd	r17, Z+1	; 0x01
    18c2:	01 e0       	ldi	r16, 0x01	; 1
    18c4:	e1 14       	cp	r14, r1
    18c6:	f1 04       	cpc	r15, r1
    18c8:	09 f4       	brne	.+2      	; 0x18cc <strtol+0x60>
    18ca:	da c0       	rjmp	.+436    	; 0x1a80 <strtol+0x214>
    18cc:	f0 e1       	ldi	r31, 0x10	; 16
    18ce:	ef 16       	cp	r14, r31
    18d0:	f1 04       	cpc	r15, r1
    18d2:	09 f0       	breq	.+2      	; 0x18d6 <strtol+0x6a>
    18d4:	82 c0       	rjmp	.+260    	; 0x19da <strtol+0x16e>
    18d6:	10 33       	cpi	r17, 0x30	; 48
    18d8:	59 f4       	brne	.+22     	; 0x18f0 <strtol+0x84>
    18da:	88 81       	ld	r24, Y
    18dc:	8f 7d       	andi	r24, 0xDF	; 223
    18de:	88 35       	cpi	r24, 0x58	; 88
    18e0:	09 f0       	breq	.+2      	; 0x18e4 <strtol+0x78>
    18e2:	76 c0       	rjmp	.+236    	; 0x19d0 <strtol+0x164>
    18e4:	19 81       	ldd	r17, Y+1	; 0x01
    18e6:	22 96       	adiw	r28, 0x02	; 2
    18e8:	02 60       	ori	r16, 0x02	; 2
    18ea:	f0 e1       	ldi	r31, 0x10	; 16
    18ec:	ef 2e       	mov	r14, r31
    18ee:	f1 2c       	mov	r15, r1
    18f0:	81 2c       	mov	r8, r1
    18f2:	91 2c       	mov	r9, r1
    18f4:	a1 2c       	mov	r10, r1
    18f6:	88 e0       	ldi	r24, 0x08	; 8
    18f8:	b8 2e       	mov	r11, r24
    18fa:	8c c0       	rjmp	.+280    	; 0x1a14 <strtol+0x1a8>
    18fc:	1b 32       	cpi	r17, 0x2B	; 43
    18fe:	21 f4       	brne	.+8      	; 0x1908 <strtol+0x9c>
    1900:	e5 01       	movw	r28, r10
    1902:	22 96       	adiw	r28, 0x02	; 2
    1904:	f5 01       	movw	r30, r10
    1906:	11 81       	ldd	r17, Z+1	; 0x01
    1908:	00 e0       	ldi	r16, 0x00	; 0
    190a:	dc cf       	rjmp	.-72     	; 0x18c4 <strtol+0x58>
    190c:	ea e0       	ldi	r30, 0x0A	; 10
    190e:	ee 16       	cp	r14, r30
    1910:	f1 04       	cpc	r15, r1
    1912:	09 f4       	brne	.+2      	; 0x1916 <strtol+0xaa>
    1914:	bb c0       	rjmp	.+374    	; 0x1a8c <strtol+0x220>
    1916:	f0 e1       	ldi	r31, 0x10	; 16
    1918:	ef 16       	cp	r14, r31
    191a:	f1 04       	cpc	r15, r1
    191c:	09 f0       	breq	.+2      	; 0x1920 <strtol+0xb4>
    191e:	6d c0       	rjmp	.+218    	; 0x19fa <strtol+0x18e>
    1920:	e7 cf       	rjmp	.-50     	; 0x18f0 <strtol+0x84>
    1922:	78 e0       	ldi	r23, 0x08	; 8
    1924:	e7 2e       	mov	r14, r23
    1926:	f1 2c       	mov	r15, r1
    1928:	81 2c       	mov	r8, r1
    192a:	91 2c       	mov	r9, r1
    192c:	a1 2c       	mov	r10, r1
    192e:	60 e1       	ldi	r22, 0x10	; 16
    1930:	b6 2e       	mov	r11, r22
    1932:	70 c0       	rjmp	.+224    	; 0x1a14 <strtol+0x1a8>
    1934:	3f e9       	ldi	r19, 0x9F	; 159
    1936:	31 0f       	add	r19, r17
    1938:	3a 31       	cpi	r19, 0x1A	; 26
    193a:	28 f4       	brcc	.+10     	; 0x1946 <strtol+0xda>
    193c:	39 ea       	ldi	r19, 0xA9	; 169
    193e:	33 2e       	mov	r3, r19
    1940:	80 c0       	rjmp	.+256    	; 0x1a42 <strtol+0x1d6>
    1942:	21 e0       	ldi	r18, 0x01	; 1
    1944:	9a c0       	rjmp	.+308    	; 0x1a7a <strtol+0x20e>
    1946:	30 2f       	mov	r19, r16
    1948:	31 70       	andi	r19, 0x01	; 1
    194a:	c1 14       	cp	r12, r1
    194c:	d1 04       	cpc	r13, r1
    194e:	31 f0       	breq	.+12     	; 0x195c <strtol+0xf0>
    1950:	22 23       	and	r18, r18
    1952:	09 f1       	breq	.+66     	; 0x1996 <strtol+0x12a>
    1954:	21 97       	sbiw	r28, 0x01	; 1
    1956:	f6 01       	movw	r30, r12
    1958:	c0 83       	st	Z, r28
    195a:	d1 83       	std	Z+1, r29	; 0x01
    195c:	27 ff       	sbrs	r18, 7
    195e:	21 c0       	rjmp	.+66     	; 0x19a2 <strtol+0x136>
    1960:	60 e0       	ldi	r22, 0x00	; 0
    1962:	70 e0       	ldi	r23, 0x00	; 0
    1964:	80 e0       	ldi	r24, 0x00	; 0
    1966:	90 e8       	ldi	r25, 0x80	; 128
    1968:	31 11       	cpse	r19, r1
    196a:	04 c0       	rjmp	.+8      	; 0x1974 <strtol+0x108>
    196c:	6f ef       	ldi	r22, 0xFF	; 255
    196e:	7f ef       	ldi	r23, 0xFF	; 255
    1970:	8f ef       	ldi	r24, 0xFF	; 255
    1972:	9f e7       	ldi	r25, 0x7F	; 127
    1974:	22 e2       	ldi	r18, 0x22	; 34
    1976:	30 e0       	ldi	r19, 0x00	; 0
    1978:	20 93 63 3a 	sts	0x3A63, r18	; 0x803a63 <errno>
    197c:	30 93 64 3a 	sts	0x3A64, r19	; 0x803a64 <errno+0x1>
    1980:	46 2f       	mov	r20, r22
    1982:	37 2f       	mov	r19, r23
    1984:	28 2f       	mov	r18, r24
    1986:	64 2f       	mov	r22, r20
    1988:	73 2f       	mov	r23, r19
    198a:	82 2f       	mov	r24, r18
    198c:	cd b7       	in	r28, 0x3d	; 61
    198e:	de b7       	in	r29, 0x3e	; 62
    1990:	e1 e1       	ldi	r30, 0x11	; 17
    1992:	0c 94 b0 0d 	jmp	0x1b60	; 0x1b60 <__epilogue_restores__+0x2>
    1996:	01 ff       	sbrs	r16, 1
    1998:	04 c0       	rjmp	.+8      	; 0x19a2 <strtol+0x136>
    199a:	22 97       	sbiw	r28, 0x02	; 2
    199c:	f6 01       	movw	r30, r12
    199e:	c0 83       	st	Z, r28
    19a0:	d1 83       	std	Z+1, r29	; 0x01
    19a2:	33 23       	and	r19, r19
    19a4:	41 f0       	breq	.+16     	; 0x19b6 <strtol+0x14a>
    19a6:	90 95       	com	r25
    19a8:	80 95       	com	r24
    19aa:	70 95       	com	r23
    19ac:	61 95       	neg	r22
    19ae:	7f 4f       	sbci	r23, 0xFF	; 255
    19b0:	8f 4f       	sbci	r24, 0xFF	; 255
    19b2:	9f 4f       	sbci	r25, 0xFF	; 255
    19b4:	e5 cf       	rjmp	.-54     	; 0x1980 <strtol+0x114>
    19b6:	97 ff       	sbrs	r25, 7
    19b8:	e3 cf       	rjmp	.-58     	; 0x1980 <strtol+0x114>
    19ba:	82 e2       	ldi	r24, 0x22	; 34
    19bc:	90 e0       	ldi	r25, 0x00	; 0
    19be:	80 93 63 3a 	sts	0x3A63, r24	; 0x803a63 <errno>
    19c2:	90 93 64 3a 	sts	0x3A64, r25	; 0x803a64 <errno+0x1>
    19c6:	6f ef       	ldi	r22, 0xFF	; 255
    19c8:	7f ef       	ldi	r23, 0xFF	; 255
    19ca:	8f ef       	ldi	r24, 0xFF	; 255
    19cc:	9f e7       	ldi	r25, 0x7F	; 127
    19ce:	d8 cf       	rjmp	.-80     	; 0x1980 <strtol+0x114>
    19d0:	10 e3       	ldi	r17, 0x30	; 48
    19d2:	e1 14       	cp	r14, r1
    19d4:	f1 04       	cpc	r15, r1
    19d6:	09 f4       	brne	.+2      	; 0x19da <strtol+0x16e>
    19d8:	a4 cf       	rjmp	.-184    	; 0x1922 <strtol+0xb6>
    19da:	28 e0       	ldi	r18, 0x08	; 8
    19dc:	e2 16       	cp	r14, r18
    19de:	f1 04       	cpc	r15, r1
    19e0:	09 f4       	brne	.+2      	; 0x19e4 <strtol+0x178>
    19e2:	a2 cf       	rjmp	.-188    	; 0x1928 <strtol+0xbc>
    19e4:	0c f0       	brlt	.+2      	; 0x19e8 <strtol+0x17c>
    19e6:	92 cf       	rjmp	.-220    	; 0x190c <strtol+0xa0>
    19e8:	81 2c       	mov	r8, r1
    19ea:	91 2c       	mov	r9, r1
    19ec:	a1 2c       	mov	r10, r1
    19ee:	e0 e4       	ldi	r30, 0x40	; 64
    19f0:	be 2e       	mov	r11, r30
    19f2:	82 e0       	ldi	r24, 0x02	; 2
    19f4:	e8 16       	cp	r14, r24
    19f6:	f1 04       	cpc	r15, r1
    19f8:	69 f0       	breq	.+26     	; 0x1a14 <strtol+0x1a8>
    19fa:	60 e0       	ldi	r22, 0x00	; 0
    19fc:	70 e0       	ldi	r23, 0x00	; 0
    19fe:	80 e0       	ldi	r24, 0x00	; 0
    1a00:	90 e8       	ldi	r25, 0x80	; 128
    1a02:	97 01       	movw	r18, r14
    1a04:	0f 2c       	mov	r0, r15
    1a06:	00 0c       	add	r0, r0
    1a08:	44 0b       	sbc	r20, r20
    1a0a:	55 0b       	sbc	r21, r21
    1a0c:	0e 94 69 0d 	call	0x1ad2	; 0x1ad2 <__udivmodsi4>
    1a10:	49 01       	movw	r8, r18
    1a12:	5a 01       	movw	r10, r20
    1a14:	20 e0       	ldi	r18, 0x00	; 0
    1a16:	60 e0       	ldi	r22, 0x00	; 0
    1a18:	70 e0       	ldi	r23, 0x00	; 0
    1a1a:	cb 01       	movw	r24, r22
    1a1c:	27 01       	movw	r4, r14
    1a1e:	0f 2c       	mov	r0, r15
    1a20:	00 0c       	add	r0, r0
    1a22:	66 08       	sbc	r6, r6
    1a24:	77 08       	sbc	r7, r7
    1a26:	fe 01       	movw	r30, r28
    1a28:	50 ed       	ldi	r21, 0xD0	; 208
    1a2a:	35 2e       	mov	r3, r21
    1a2c:	31 0e       	add	r3, r17
    1a2e:	39 e0       	ldi	r19, 0x09	; 9
    1a30:	33 15       	cp	r19, r3
    1a32:	40 f4       	brcc	.+16     	; 0x1a44 <strtol+0x1d8>
    1a34:	3f eb       	ldi	r19, 0xBF	; 191
    1a36:	31 0f       	add	r19, r17
    1a38:	3a 31       	cpi	r19, 0x1A	; 26
    1a3a:	08 f0       	brcs	.+2      	; 0x1a3e <strtol+0x1d2>
    1a3c:	7b cf       	rjmp	.-266    	; 0x1934 <strtol+0xc8>
    1a3e:	49 ec       	ldi	r20, 0xC9	; 201
    1a40:	34 2e       	mov	r3, r20
    1a42:	31 0e       	add	r3, r17
    1a44:	3e 14       	cp	r3, r14
    1a46:	1f 04       	cpc	r1, r15
    1a48:	0c f0       	brlt	.+2      	; 0x1a4c <strtol+0x1e0>
    1a4a:	7d cf       	rjmp	.-262    	; 0x1946 <strtol+0xda>
    1a4c:	27 fd       	sbrc	r18, 7
    1a4e:	15 c0       	rjmp	.+42     	; 0x1a7a <strtol+0x20e>
    1a50:	86 16       	cp	r8, r22
    1a52:	97 06       	cpc	r9, r23
    1a54:	a8 06       	cpc	r10, r24
    1a56:	b9 06       	cpc	r11, r25
    1a58:	78 f0       	brcs	.+30     	; 0x1a78 <strtol+0x20c>
    1a5a:	a3 01       	movw	r20, r6
    1a5c:	92 01       	movw	r18, r4
    1a5e:	0e 94 59 0d 	call	0x1ab2	; 0x1ab2 <__mulsi3>
    1a62:	63 0d       	add	r22, r3
    1a64:	71 1d       	adc	r23, r1
    1a66:	81 1d       	adc	r24, r1
    1a68:	91 1d       	adc	r25, r1
    1a6a:	61 30       	cpi	r22, 0x01	; 1
    1a6c:	71 05       	cpc	r23, r1
    1a6e:	81 05       	cpc	r24, r1
    1a70:	20 e8       	ldi	r18, 0x80	; 128
    1a72:	92 07       	cpc	r25, r18
    1a74:	08 f4       	brcc	.+2      	; 0x1a78 <strtol+0x20c>
    1a76:	65 cf       	rjmp	.-310    	; 0x1942 <strtol+0xd6>
    1a78:	2f ef       	ldi	r18, 0xFF	; 255
    1a7a:	21 96       	adiw	r28, 0x01	; 1
    1a7c:	10 81       	ld	r17, Z
    1a7e:	d3 cf       	rjmp	.-90     	; 0x1a26 <strtol+0x1ba>
    1a80:	10 33       	cpi	r17, 0x30	; 48
    1a82:	09 f4       	brne	.+2      	; 0x1a86 <strtol+0x21a>
    1a84:	2a cf       	rjmp	.-428    	; 0x18da <strtol+0x6e>
    1a86:	2a e0       	ldi	r18, 0x0A	; 10
    1a88:	e2 2e       	mov	r14, r18
    1a8a:	f1 2c       	mov	r15, r1
    1a8c:	9c ec       	ldi	r25, 0xCC	; 204
    1a8e:	89 2e       	mov	r8, r25
    1a90:	98 2c       	mov	r9, r8
    1a92:	a8 2c       	mov	r10, r8
    1a94:	9c e0       	ldi	r25, 0x0C	; 12
    1a96:	b9 2e       	mov	r11, r25
    1a98:	bd cf       	rjmp	.-134    	; 0x1a14 <strtol+0x1a8>

00001a9a <isspace>:
isspace():
    1a9a:	91 11       	cpse	r25, r1
    1a9c:	0c 94 56 0d 	jmp	0x1aac	; 0x1aac <__ctype_isfalse>
    1aa0:	80 32       	cpi	r24, 0x20	; 32
    1aa2:	19 f0       	breq	.+6      	; 0x1aaa <isspace+0x10>
    1aa4:	89 50       	subi	r24, 0x09	; 9
    1aa6:	85 50       	subi	r24, 0x05	; 5
    1aa8:	c8 f7       	brcc	.-14     	; 0x1a9c <isspace+0x2>
    1aaa:	08 95       	ret

00001aac <__ctype_isfalse>:
__ctype_isfalse():
    1aac:	99 27       	eor	r25, r25
    1aae:	88 27       	eor	r24, r24

00001ab0 <__ctype_istrue>:
__ctype_istrue():
    1ab0:	08 95       	ret

00001ab2 <__mulsi3>:
__mulsi3():
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:648
    1ab2:	db 01       	movw	r26, r22
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:649
    1ab4:	8f 93       	push	r24
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:650
    1ab6:	9f 93       	push	r25
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:651
    1ab8:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <__muluhisi3>
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:652
    1abc:	bf 91       	pop	r27
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:653
    1abe:	af 91       	pop	r26
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:655
    1ac0:	a2 9f       	mul	r26, r18
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:656
    1ac2:	80 0d       	add	r24, r0
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:657
    1ac4:	91 1d       	adc	r25, r1
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:658
    1ac6:	a3 9f       	mul	r26, r19
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:659
    1ac8:	90 0d       	add	r25, r0
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:660
    1aca:	b2 9f       	mul	r27, r18
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:661
    1acc:	90 0d       	add	r25, r0
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:662
    1ace:	11 24       	eor	r1, r1
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:663
    1ad0:	08 95       	ret

00001ad2 <__udivmodsi4>:
__udivmodsi4():
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1638
    1ad2:	a1 e2       	ldi	r26, 0x21	; 33
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1639
    1ad4:	1a 2e       	mov	r1, r26
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1640
    1ad6:	aa 1b       	sub	r26, r26
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1641
    1ad8:	bb 1b       	sub	r27, r27
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1642
    1ada:	fd 01       	movw	r30, r26
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1644
    1adc:	0d c0       	rjmp	.+26     	; 0x1af8 <__udivmodsi4_ep>

00001ade <__udivmodsi4_loop>:
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1646
    1ade:	aa 1f       	adc	r26, r26
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1647
    1ae0:	bb 1f       	adc	r27, r27
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1648
    1ae2:	ee 1f       	adc	r30, r30
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1649
    1ae4:	ff 1f       	adc	r31, r31
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1650
    1ae6:	a2 17       	cp	r26, r18
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1651
    1ae8:	b3 07       	cpc	r27, r19
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1652
    1aea:	e4 07       	cpc	r30, r20
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1653
    1aec:	f5 07       	cpc	r31, r21
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1654
    1aee:	20 f0       	brcs	.+8      	; 0x1af8 <__udivmodsi4_ep>
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1655
    1af0:	a2 1b       	sub	r26, r18
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1656
    1af2:	b3 0b       	sbc	r27, r19
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1657
    1af4:	e4 0b       	sbc	r30, r20
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1658
    1af6:	f5 0b       	sbc	r31, r21

00001af8 <__udivmodsi4_ep>:
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1660
    1af8:	66 1f       	adc	r22, r22
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1661
    1afa:	77 1f       	adc	r23, r23
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1662
    1afc:	88 1f       	adc	r24, r24
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1663
    1afe:	99 1f       	adc	r25, r25
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1664
    1b00:	1a 94       	dec	r1
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1665
    1b02:	69 f7       	brne	.-38     	; 0x1ade <__udivmodsi4_loop>
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1667
    1b04:	60 95       	com	r22
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1668
    1b06:	70 95       	com	r23
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1669
    1b08:	80 95       	com	r24
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1670
    1b0a:	90 95       	com	r25
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1672
    1b0c:	9b 01       	movw	r18, r22
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1674
    1b0e:	ac 01       	movw	r20, r24
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1676
    1b10:	bd 01       	movw	r22, r26
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1678
    1b12:	cf 01       	movw	r24, r30
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1680
    1b14:	08 95       	ret

00001b16 <__muluhisi3>:
__muluhisi3():
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:626
    1b16:	0e 94 c7 0d 	call	0x1b8e	; 0x1b8e <__umulhisi3>
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:627
    1b1a:	a5 9f       	mul	r26, r21
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:628
    1b1c:	90 0d       	add	r25, r0
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:629
    1b1e:	b4 9f       	mul	r27, r20
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:630
    1b20:	90 0d       	add	r25, r0
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:631
    1b22:	a4 9f       	mul	r26, r20
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:632
    1b24:	80 0d       	add	r24, r0
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:633
    1b26:	91 1d       	adc	r25, r1
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:634
    1b28:	11 24       	eor	r1, r1
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:635
    1b2a:	08 95       	ret

00001b2c <__prologue_saves__>:
__prologue_saves__():
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2169
    1b2c:	2f 92       	push	r2
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2170
    1b2e:	3f 92       	push	r3
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2171
    1b30:	4f 92       	push	r4
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2172
    1b32:	5f 92       	push	r5
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2173
    1b34:	6f 92       	push	r6
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2174
    1b36:	7f 92       	push	r7
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2175
    1b38:	8f 92       	push	r8
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2176
    1b3a:	9f 92       	push	r9
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2177
    1b3c:	af 92       	push	r10
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2178
    1b3e:	bf 92       	push	r11
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2179
    1b40:	cf 92       	push	r12
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2180
    1b42:	df 92       	push	r13
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2181
    1b44:	ef 92       	push	r14
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2182
    1b46:	ff 92       	push	r15
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2183
    1b48:	0f 93       	push	r16
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2184
    1b4a:	1f 93       	push	r17
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2185
    1b4c:	cf 93       	push	r28
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2186
    1b4e:	df 93       	push	r29
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2193
    1b50:	cd b7       	in	r28, 0x3d	; 61
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2194
    1b52:	de b7       	in	r29, 0x3e	; 62
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2195
    1b54:	ca 1b       	sub	r28, r26
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2196
    1b56:	db 0b       	sbc	r29, r27
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2197
    1b58:	cd bf       	out	0x3d, r28	; 61
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2198
    1b5a:	de bf       	out	0x3e, r29	; 62
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2211
    1b5c:	09 94       	ijmp

00001b5e <__epilogue_restores__>:
__epilogue_restores__():
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2222
    1b5e:	2a 88       	ldd	r2, Y+18	; 0x12
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2223
    1b60:	39 88       	ldd	r3, Y+17	; 0x11
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2224
    1b62:	48 88       	ldd	r4, Y+16	; 0x10
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2225
    1b64:	5f 84       	ldd	r5, Y+15	; 0x0f
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2226
    1b66:	6e 84       	ldd	r6, Y+14	; 0x0e
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2227
    1b68:	7d 84       	ldd	r7, Y+13	; 0x0d
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2228
    1b6a:	8c 84       	ldd	r8, Y+12	; 0x0c
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2229
    1b6c:	9b 84       	ldd	r9, Y+11	; 0x0b
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2230
    1b6e:	aa 84       	ldd	r10, Y+10	; 0x0a
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2231
    1b70:	b9 84       	ldd	r11, Y+9	; 0x09
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2232
    1b72:	c8 84       	ldd	r12, Y+8	; 0x08
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2233
    1b74:	df 80       	ldd	r13, Y+7	; 0x07
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2234
    1b76:	ee 80       	ldd	r14, Y+6	; 0x06
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2235
    1b78:	fd 80       	ldd	r15, Y+5	; 0x05
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2236
    1b7a:	0c 81       	ldd	r16, Y+4	; 0x04
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2237
    1b7c:	1b 81       	ldd	r17, Y+3	; 0x03
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2238
    1b7e:	aa 81       	ldd	r26, Y+2	; 0x02
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2245
    1b80:	b9 81       	ldd	r27, Y+1	; 0x01
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2246
    1b82:	ce 0f       	add	r28, r30
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2247
    1b84:	d1 1d       	adc	r29, r1
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2248
    1b86:	cd bf       	out	0x3d, r28	; 61
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2249
    1b88:	de bf       	out	0x3e, r29	; 62
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2250
    1b8a:	ed 01       	movw	r28, r26
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2263
    1b8c:	08 95       	ret

00001b8e <__umulhisi3>:
__umulhisi3():
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:564
    1b8e:	a2 9f       	mul	r26, r18
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:565
    1b90:	b0 01       	movw	r22, r0
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:566
    1b92:	b3 9f       	mul	r27, r19
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:567
    1b94:	c0 01       	movw	r24, r0
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:568
    1b96:	a3 9f       	mul	r26, r19
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:573
    1b98:	70 0d       	add	r23, r0
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:574
    1b9a:	81 1d       	adc	r24, r1
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:575
    1b9c:	11 24       	eor	r1, r1
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:576
    1b9e:	91 1d       	adc	r25, r1
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:580
    1ba0:	b2 9f       	mul	r27, r18
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:581
    1ba2:	70 0d       	add	r23, r0
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:582
    1ba4:	81 1d       	adc	r24, r1
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:583
    1ba6:	11 24       	eor	r1, r1
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:584
    1ba8:	91 1d       	adc	r25, r1
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:585
    1baa:	08 95       	ret

00001bac <__divmodqi4>:
__divmodqi4():
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1366
    1bac:	87 fb       	bst	r24, 7
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1367
    1bae:	08 2e       	mov	r0, r24
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1368
    1bb0:	06 26       	eor	r0, r22
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1369
    1bb2:	87 fd       	sbrc	r24, 7
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1370
    1bb4:	81 95       	neg	r24
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1371
    1bb6:	67 fd       	sbrc	r22, 7
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1372
    1bb8:	61 95       	neg	r22
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1373
    1bba:	0e 94 ec 0d 	call	0x1bd8	; 0x1bd8 <__udivmodqi4>
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1374
    1bbe:	0e f4       	brtc	.+2      	; 0x1bc2 <__divmodqi4_1>
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1375
    1bc0:	91 95       	neg	r25

00001bc2 <__divmodqi4_1>:
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1377
    1bc2:	07 fc       	sbrc	r0, 7
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1378
    1bc4:	81 95       	neg	r24

00001bc6 <__divmodqi4_exit>:
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1380
    1bc6:	08 95       	ret

00001bc8 <__mulshisi3>:
__mulshisi3():
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:603
    1bc8:	b7 ff       	sbrs	r27, 7
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:605
    1bca:	0c 94 8b 0d 	jmp	0x1b16	; 0x1b16 <__muluhisi3>

00001bce <__mulohisi3>:
__mulohisi3():
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:613
    1bce:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <__muluhisi3>
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:615
    1bd2:	82 1b       	sub	r24, r18
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:616
    1bd4:	93 0b       	sbc	r25, r19
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:617
    1bd6:	08 95       	ret

00001bd8 <__udivmodqi4>:
__udivmodqi4():
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1346
    1bd8:	99 1b       	sub	r25, r25
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1347
    1bda:	79 e0       	ldi	r23, 0x09	; 9
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1348
    1bdc:	04 c0       	rjmp	.+8      	; 0x1be6 <__udivmodqi4_ep>

00001bde <__udivmodqi4_loop>:
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1350
    1bde:	99 1f       	adc	r25, r25
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1351
    1be0:	96 17       	cp	r25, r22
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1352
    1be2:	08 f0       	brcs	.+2      	; 0x1be6 <__udivmodqi4_ep>
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1353
    1be4:	96 1b       	sub	r25, r22

00001be6 <__udivmodqi4_ep>:
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1355
    1be6:	88 1f       	adc	r24, r24
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1356
    1be8:	7a 95       	dec	r23
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1357
    1bea:	c9 f7       	brne	.-14     	; 0x1bde <__udivmodqi4_loop>
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1358
    1bec:	80 95       	com	r24
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1360
    1bee:	08 95       	ret

00001bf0 <__tablejump2__>:
__tablejump2__():
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
    1bf0:	ee 0f       	add	r30, r30
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
    1bf2:	ff 1f       	adc	r31, r31
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2328
    1bf4:	05 90       	lpm	r0, Z+
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2329
    1bf6:	f4 91       	lpm	r31, Z
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2330
    1bf8:	e0 2d       	mov	r30, r0
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2331
    1bfa:	09 94       	ijmp

00001bfc <abort>:
abort():
    1bfc:	81 e0       	ldi	r24, 0x01	; 1
    1bfe:	90 e0       	ldi	r25, 0x00	; 0
    1c00:	f8 94       	cli
    1c02:	0c 94 16 0e 	jmp	0x1c2c	; 0x1c2c <_exit>

00001c06 <strcasecmp>:
strcasecmp():
    1c06:	fb 01       	movw	r30, r22
    1c08:	dc 01       	movw	r26, r24
    1c0a:	8d 91       	ld	r24, X+
    1c0c:	81 34       	cpi	r24, 0x41	; 65
    1c0e:	1c f0       	brlt	.+6      	; 0x1c16 <strcasecmp+0x10>
    1c10:	8b 35       	cpi	r24, 0x5B	; 91
    1c12:	0c f4       	brge	.+2      	; 0x1c16 <strcasecmp+0x10>
    1c14:	80 5e       	subi	r24, 0xE0	; 224
    1c16:	61 91       	ld	r22, Z+
    1c18:	61 34       	cpi	r22, 0x41	; 65
    1c1a:	1c f0       	brlt	.+6      	; 0x1c22 <strcasecmp+0x1c>
    1c1c:	6b 35       	cpi	r22, 0x5B	; 91
    1c1e:	0c f4       	brge	.+2      	; 0x1c22 <strcasecmp+0x1c>
    1c20:	60 5e       	subi	r22, 0xE0	; 224
    1c22:	86 1b       	sub	r24, r22
    1c24:	61 11       	cpse	r22, r1
    1c26:	89 f3       	breq	.-30     	; 0x1c0a <strcasecmp+0x4>
    1c28:	99 0b       	sbc	r25, r25
    1c2a:	08 95       	ret

00001c2c <_exit>:
exit():
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
    1c2c:	f8 94       	cli

00001c2e <__stop_program>:
__stop_program():
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
    1c2e:	ff cf       	rjmp	.-2      	; 0x1c2e <__stop_program>
