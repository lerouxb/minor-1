
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/minor-1.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
../../../../crt1/gcrt1.S:61
       0:	0c 94 3b 03 	jmp	0x676	; 0x676 <__ctors_end>
../../../../crt1/gcrt1.S:67
       4:	0c 94 63 03 	jmp	0x6c6	; 0x6c6 <__bad_interrupt>
../../../../crt1/gcrt1.S:68
       8:	0c 94 63 03 	jmp	0x6c6	; 0x6c6 <__bad_interrupt>
../../../../crt1/gcrt1.S:69
       c:	0c 94 63 03 	jmp	0x6c6	; 0x6c6 <__bad_interrupt>
../../../../crt1/gcrt1.S:70
      10:	0c 94 63 03 	jmp	0x6c6	; 0x6c6 <__bad_interrupt>
../../../../crt1/gcrt1.S:71
      14:	0c 94 63 03 	jmp	0x6c6	; 0x6c6 <__bad_interrupt>
../../../../crt1/gcrt1.S:72
      18:	0c 94 63 03 	jmp	0x6c6	; 0x6c6 <__bad_interrupt>
../../../../crt1/gcrt1.S:73
      1c:	0c 94 63 03 	jmp	0x6c6	; 0x6c6 <__bad_interrupt>
../../../../crt1/gcrt1.S:74
      20:	0c 94 76 08 	jmp	0x10ec	; 0x10ec <__vector_8>
../../../../crt1/gcrt1.S:75
      24:	0c 94 63 03 	jmp	0x6c6	; 0x6c6 <__bad_interrupt>
../../../../crt1/gcrt1.S:76
      28:	0c 94 63 03 	jmp	0x6c6	; 0x6c6 <__bad_interrupt>
../../../../crt1/gcrt1.S:77
      2c:	0c 94 63 03 	jmp	0x6c6	; 0x6c6 <__bad_interrupt>
../../../../crt1/gcrt1.S:78
      30:	0c 94 63 03 	jmp	0x6c6	; 0x6c6 <__bad_interrupt>
../../../../crt1/gcrt1.S:79
      34:	0c 94 63 03 	jmp	0x6c6	; 0x6c6 <__bad_interrupt>
../../../../crt1/gcrt1.S:80
      38:	0c 94 63 03 	jmp	0x6c6	; 0x6c6 <__bad_interrupt>
../../../../crt1/gcrt1.S:81
      3c:	0c 94 cd 06 	jmp	0xd9a	; 0xd9a <__vector_15>
../../../../crt1/gcrt1.S:82
      40:	0c 94 63 03 	jmp	0x6c6	; 0x6c6 <__bad_interrupt>
../../../../crt1/gcrt1.S:83
      44:	0c 94 63 03 	jmp	0x6c6	; 0x6c6 <__bad_interrupt>
../../../../crt1/gcrt1.S:84
      48:	0c 94 63 03 	jmp	0x6c6	; 0x6c6 <__bad_interrupt>
../../../../crt1/gcrt1.S:85
      4c:	0c 94 63 03 	jmp	0x6c6	; 0x6c6 <__bad_interrupt>
../../../../crt1/gcrt1.S:86
      50:	0c 94 63 03 	jmp	0x6c6	; 0x6c6 <__bad_interrupt>
../../../../crt1/gcrt1.S:87
      54:	0c 94 63 03 	jmp	0x6c6	; 0x6c6 <__bad_interrupt>
../../../../crt1/gcrt1.S:88
      58:	0c 94 63 03 	jmp	0x6c6	; 0x6c6 <__bad_interrupt>
../../../../crt1/gcrt1.S:89
      5c:	0c 94 63 03 	jmp	0x6c6	; 0x6c6 <__bad_interrupt>
../../../../crt1/gcrt1.S:90
      60:	0c 94 23 07 	jmp	0xe46	; 0xe46 <__vector_24>
../../../../crt1/gcrt1.S:91
      64:	0c 94 c6 07 	jmp	0xf8c	; 0xf8c <__vector_25>
../../../../crt1/gcrt1.S:92
      68:	0c 94 63 03 	jmp	0x6c6	; 0x6c6 <__bad_interrupt>
../../../../crt1/gcrt1.S:93
      6c:	0c 94 63 03 	jmp	0x6c6	; 0x6c6 <__bad_interrupt>
../../../../crt1/gcrt1.S:94
      70:	0c 94 63 03 	jmp	0x6c6	; 0x6c6 <__bad_interrupt>
../../../../crt1/gcrt1.S:95
      74:	0c 94 63 03 	jmp	0x6c6	; 0x6c6 <__bad_interrupt>
../../../../crt1/gcrt1.S:96
      78:	0c 94 63 03 	jmp	0x6c6	; 0x6c6 <__bad_interrupt>

0000007c <__trampolines_end>:
	...
__trampolines_start():
      8c:	00 00       	nop
      8e:	00 f8       	bld	r0, 0
      90:	00 00       	nop
      92:	00 00       	nop
      94:	00 00       	nop
      96:	00 33       	cpi	r16, 0x30	; 48
      98:	30 00       	.word	0x0030	; ????
      9a:	00 00       	nop
      9c:	00 10       	cpse	r0, r0
      9e:	0c 06       	cpc	r0, r28
      a0:	10 0c       	add	r1, r0
      a2:	06 00       	.word	0x0006	; ????
	...
      ac:	40 c0       	rjmp	.+128    	; 0x12e <__EEPROM_REGION_LENGTH__+0x2e>
      ae:	78 40       	sbci	r23, 0x08	; 8
      b0:	c0 78       	andi	r28, 0x80	; 128
      b2:	40 00       	.word	0x0040	; ????
      b4:	04 3f       	cpi	r16, 0xF4	; 244
      b6:	04 04       	cpc	r0, r4
      b8:	3f 04       	cpc	r3, r15
      ba:	04 00       	.word	0x0004	; ????
      bc:	00 70       	andi	r16, 0x00	; 0
      be:	88 fc       	.word	0xfc88	; ????
      c0:	08 30       	cpi	r16, 0x08	; 8
      c2:	00 00       	nop
      c4:	00 18       	sub	r0, r0
      c6:	20 ff       	sbrs	r18, 0
      c8:	21 1e       	adc	r2, r17
      ca:	00 00       	nop
      cc:	f0 08       	sbc	r15, r0
      ce:	f0 00       	.word	0x00f0	; ????
      d0:	e0 18       	sub	r14, r0
      d2:	00 00       	nop
      d4:	00 21       	and	r16, r0
      d6:	1c 03       	fmul	r17, r20
      d8:	1e 21       	and	r17, r14
      da:	1e 00       	.word	0x001e	; ????
      dc:	00 f0       	brcs	.+0      	; 0xde <__trampolines_end+0x62>
      de:	08 88       	ldd	r0, Y+16	; 0x10
      e0:	70 00       	.word	0x0070	; ????
      e2:	00 00       	nop
      e4:	1e 21       	and	r17, r14
      e6:	23 24       	eor	r2, r3
      e8:	19 27       	eor	r17, r25
      ea:	21 10       	cpse	r2, r1
      ec:	10 16       	cp	r1, r16
      ee:	0e 00       	.word	0x000e	; ????
	...
      fc:	00 00       	nop
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	18 04       	cpc	r1, r8
     102:	02 00       	.word	0x0002	; ????
     104:	00 00       	nop
     106:	00 07       	cpc	r16, r16
     108:	18 20       	and	r1, r8
     10a:	40 00       	.word	0x0040	; ????
     10c:	00 02       	muls	r16, r16
     10e:	04 18       	sub	r0, r4
     110:	e0 00       	.word	0x00e0	; ????
     112:	00 00       	nop
     114:	00 40       	sbci	r16, 0x00	; 0
     116:	20 18       	sub	r2, r0
     118:	07 00       	.word	0x0007	; ????
     11a:	00 00       	nop
     11c:	40 40       	sbci	r20, 0x00	; 0
     11e:	80 f0       	brcs	.+32     	; 0x140 <__EEPROM_REGION_LENGTH__+0x40>
     120:	80 40       	sbci	r24, 0x00	; 0
     122:	40 00       	.word	0x0040	; ????
     124:	02 02       	muls	r16, r18
     126:	01 0f       	add	r16, r17
     128:	01 02       	muls	r16, r17
     12a:	02 00       	.word	0x0002	; ????
     12c:	00 00       	nop
     12e:	00 f0       	brcs	.+0      	; 0x130 <__EEPROM_REGION_LENGTH__+0x30>
     130:	00 00       	nop
     132:	00 00       	nop
     134:	01 01       	movw	r0, r2
     136:	01 1f       	adc	r16, r17
     138:	01 01       	movw	r0, r2
     13a:	01 00       	.word	0x0001	; ????
	...
     144:	80 b0       	in	r8, 0x00	; 0
     146:	70 00       	.word	0x0070	; ????
	...
     154:	00 01       	movw	r0, r0
     156:	01 01       	movw	r0, r2
     158:	01 01       	movw	r0, r2
     15a:	01 01       	movw	r0, r2
	...
     164:	00 30       	cpi	r16, 0x00	; 0
     166:	30 00       	.word	0x0030	; ????
	...
     170:	80 60       	ori	r24, 0x00	; 0
     172:	18 04       	cpc	r1, r8
     174:	00 60       	ori	r16, 0x00	; 0
     176:	18 06       	cpc	r1, r24
     178:	01 00       	.word	0x0001	; ????
     17a:	00 00       	nop
     17c:	00 e0       	ldi	r16, 0x00	; 0
     17e:	10 08       	sbc	r1, r0
     180:	08 10       	cpse	r0, r8
     182:	e0 00       	.word	0x00e0	; ????
     184:	00 0f       	add	r16, r16
     186:	10 20       	and	r1, r0
     188:	20 10       	cpse	r2, r0
     18a:	0f 00       	.word	0x000f	; ????
     18c:	00 10       	cpse	r0, r0
     18e:	10 f8       	bld	r1, 0
     190:	00 00       	nop
     192:	00 00       	nop
     194:	00 20       	and	r0, r0
     196:	20 3f       	cpi	r18, 0xF0	; 240
     198:	20 20       	and	r2, r0
     19a:	00 00       	nop
     19c:	00 70       	andi	r16, 0x00	; 0
     19e:	08 08       	sbc	r0, r8
     1a0:	08 88       	ldd	r0, Y+16	; 0x10
     1a2:	70 00       	.word	0x0070	; ????
     1a4:	00 30       	cpi	r16, 0x00	; 0
     1a6:	28 24       	eor	r2, r8
     1a8:	22 21       	and	r18, r2
     1aa:	30 00       	.word	0x0030	; ????
     1ac:	00 30       	cpi	r16, 0x00	; 0
     1ae:	08 88       	ldd	r0, Y+16	; 0x10
     1b0:	88 48       	sbci	r24, 0x88	; 136
     1b2:	30 00       	.word	0x0030	; ????
     1b4:	00 18       	sub	r0, r0
     1b6:	20 20       	and	r2, r0
     1b8:	20 11       	cpse	r18, r0
     1ba:	0e 00       	.word	0x000e	; ????
     1bc:	00 00       	nop
     1be:	c0 20       	and	r12, r0
     1c0:	10 f8       	bld	r1, 0
     1c2:	00 00       	nop
     1c4:	00 07       	cpc	r16, r16
     1c6:	04 24       	eor	r0, r4
     1c8:	24 3f       	cpi	r18, 0xF4	; 244
     1ca:	24 00       	.word	0x0024	; ????
     1cc:	00 f8       	bld	r0, 0
     1ce:	08 88       	ldd	r0, Y+16	; 0x10
     1d0:	88 08       	sbc	r8, r8
     1d2:	08 00       	.word	0x0008	; ????
     1d4:	00 19       	sub	r16, r0
     1d6:	21 20       	and	r2, r1
     1d8:	20 11       	cpse	r18, r0
     1da:	0e 00       	.word	0x000e	; ????
     1dc:	00 e0       	ldi	r16, 0x00	; 0
     1de:	10 88       	ldd	r1, Z+16	; 0x10
     1e0:	88 18       	sub	r8, r8
     1e2:	00 00       	nop
     1e4:	00 0f       	add	r16, r16
     1e6:	11 20       	and	r1, r1
     1e8:	20 11       	cpse	r18, r0
     1ea:	0e 00       	.word	0x000e	; ????
     1ec:	00 38       	cpi	r16, 0x80	; 128
     1ee:	08 08       	sbc	r0, r8
     1f0:	c8 38       	cpi	r28, 0x88	; 136
     1f2:	08 00       	.word	0x0008	; ????
     1f4:	00 00       	nop
     1f6:	00 3f       	cpi	r16, 0xF0	; 240
     1f8:	00 00       	nop
     1fa:	00 00       	nop
     1fc:	00 70       	andi	r16, 0x00	; 0
     1fe:	88 08       	sbc	r8, r8
     200:	08 88       	ldd	r0, Y+16	; 0x10
     202:	70 00       	.word	0x0070	; ????
     204:	00 1c       	adc	r0, r0
     206:	22 21       	and	r18, r2
     208:	21 22       	and	r2, r17
     20a:	1c 00       	.word	0x001c	; ????
     20c:	00 e0       	ldi	r16, 0x00	; 0
     20e:	10 08       	sbc	r1, r0
     210:	08 10       	cpse	r0, r8
     212:	e0 00       	.word	0x00e0	; ????
     214:	00 00       	nop
     216:	31 22       	and	r3, r17
     218:	22 11       	cpse	r18, r2
     21a:	0f 00       	.word	0x000f	; ????
     21c:	00 00       	nop
     21e:	00 c0       	rjmp	.+0      	; 0x220 <__EEPROM_REGION_LENGTH__+0x120>
     220:	c0 00       	.word	0x00c0	; ????
     222:	00 00       	nop
     224:	00 00       	nop
     226:	00 30       	cpi	r16, 0x00	; 0
     228:	30 00       	.word	0x0030	; ????
     22a:	00 00       	nop
     22c:	00 00       	nop
     22e:	00 80       	ld	r0, Z
     230:	00 00       	nop
     232:	00 00       	nop
     234:	00 00       	nop
     236:	80 60       	ori	r24, 0x00	; 0
     238:	00 00       	nop
     23a:	00 00       	nop
     23c:	00 00       	nop
     23e:	80 40       	sbci	r24, 0x00	; 0
     240:	20 10       	cpse	r2, r0
     242:	08 00       	.word	0x0008	; ????
     244:	00 01       	movw	r0, r0
     246:	02 04       	cpc	r0, r2
     248:	08 10       	cpse	r0, r8
     24a:	20 00       	.word	0x0020	; ????
     24c:	40 40       	sbci	r20, 0x00	; 0
     24e:	40 40       	sbci	r20, 0x00	; 0
     250:	40 40       	sbci	r20, 0x00	; 0
     252:	40 00       	.word	0x0040	; ????
     254:	04 04       	cpc	r0, r4
     256:	04 04       	cpc	r0, r4
     258:	04 04       	cpc	r0, r4
     25a:	04 00       	.word	0x0004	; ????
     25c:	00 08       	sbc	r0, r0
     25e:	10 20       	and	r1, r0
     260:	40 80       	ld	r4, Z
     262:	00 00       	nop
     264:	00 20       	and	r0, r0
     266:	10 08       	sbc	r1, r0
     268:	04 02       	muls	r16, r20
     26a:	01 00       	.word	0x0001	; ????
     26c:	00 70       	andi	r16, 0x00	; 0
     26e:	48 08       	sbc	r4, r8
     270:	08 08       	sbc	r0, r8
     272:	f0 00       	.word	0x00f0	; ????
     274:	00 00       	nop
     276:	00 30       	cpi	r16, 0x00	; 0
     278:	36 01       	movw	r6, r12
     27a:	00 00       	nop
     27c:	c0 30       	cpi	r28, 0x00	; 0
     27e:	c8 28       	or	r12, r8
     280:	e8 10       	cpse	r14, r8
     282:	e0 00       	.word	0x00e0	; ????
     284:	07 18       	sub	r0, r7
     286:	27 24       	eor	r2, r7
     288:	23 14       	cp	r2, r3
     28a:	0b 00       	.word	0x000b	; ????
     28c:	00 00       	nop
     28e:	c0 38       	cpi	r28, 0x80	; 128
     290:	e0 00       	.word	0x00e0	; ????
     292:	00 00       	nop
     294:	20 3c       	cpi	r18, 0xC0	; 192
     296:	23 02       	muls	r18, r19
     298:	02 27       	eor	r16, r18
     29a:	38 20       	and	r3, r8
     29c:	08 f8       	.word	0xf808	; ????
     29e:	88 88       	ldd	r8, Y+16	; 0x10
     2a0:	88 70       	andi	r24, 0x08	; 8
     2a2:	00 00       	nop
     2a4:	20 3f       	cpi	r18, 0xF0	; 240
     2a6:	20 20       	and	r2, r0
     2a8:	20 11       	cpse	r18, r0
     2aa:	0e 00       	.word	0x000e	; ????
     2ac:	c0 30       	cpi	r28, 0x00	; 0
     2ae:	08 08       	sbc	r0, r8
     2b0:	08 08       	sbc	r0, r8
     2b2:	38 00       	.word	0x0038	; ????
     2b4:	07 18       	sub	r0, r7
     2b6:	20 20       	and	r2, r0
     2b8:	20 10       	cpse	r2, r0
     2ba:	08 00       	.word	0x0008	; ????
     2bc:	08 f8       	.word	0xf808	; ????
     2be:	08 08       	sbc	r0, r8
     2c0:	08 10       	cpse	r0, r8
     2c2:	e0 00       	.word	0x00e0	; ????
     2c4:	20 3f       	cpi	r18, 0xF0	; 240
     2c6:	20 20       	and	r2, r0
     2c8:	20 10       	cpse	r2, r0
     2ca:	0f 00       	.word	0x000f	; ????
     2cc:	08 f8       	.word	0xf808	; ????
     2ce:	88 88       	ldd	r8, Y+16	; 0x10
     2d0:	e8 08       	sbc	r14, r8
     2d2:	10 00       	.word	0x0010	; ????
     2d4:	20 3f       	cpi	r18, 0xF0	; 240
     2d6:	20 20       	and	r2, r0
     2d8:	23 20       	and	r2, r3
     2da:	18 00       	.word	0x0018	; ????
     2dc:	08 f8       	.word	0xf808	; ????
     2de:	88 88       	ldd	r8, Y+16	; 0x10
     2e0:	e8 08       	sbc	r14, r8
     2e2:	10 00       	.word	0x0010	; ????
     2e4:	20 3f       	cpi	r18, 0xF0	; 240
     2e6:	20 00       	.word	0x0020	; ????
     2e8:	03 00       	.word	0x0003	; ????
     2ea:	00 00       	nop
     2ec:	c0 30       	cpi	r28, 0x00	; 0
     2ee:	08 08       	sbc	r0, r8
     2f0:	08 38       	cpi	r16, 0x88	; 136
     2f2:	00 00       	nop
     2f4:	07 18       	sub	r0, r7
     2f6:	20 20       	and	r2, r0
     2f8:	22 1e       	adc	r2, r18
     2fa:	02 00       	.word	0x0002	; ????
     2fc:	08 f8       	.word	0xf808	; ????
     2fe:	08 00       	.word	0x0008	; ????
     300:	00 08       	sbc	r0, r0
     302:	f8 08       	sbc	r15, r8
     304:	20 3f       	cpi	r18, 0xF0	; 240
     306:	21 01       	movw	r4, r2
     308:	01 21       	and	r16, r1
     30a:	3f 20       	and	r3, r15
     30c:	00 08       	sbc	r0, r0
     30e:	08 f8       	.word	0xf808	; ????
     310:	08 08       	sbc	r0, r8
     312:	00 00       	nop
     314:	00 20       	and	r0, r0
     316:	20 3f       	cpi	r18, 0xF0	; 240
     318:	20 20       	and	r2, r0
     31a:	00 00       	nop
     31c:	00 00       	nop
     31e:	08 08       	sbc	r0, r8
     320:	f8 08       	sbc	r15, r8
     322:	08 00       	.word	0x0008	; ????
     324:	c0 80       	ld	r12, Z
     326:	80 80       	ld	r8, Z
     328:	7f 00       	.word	0x007f	; ????
     32a:	00 00       	nop
     32c:	08 f8       	.word	0xf808	; ????
     32e:	88 c0       	rjmp	.+272    	; 0x440 <__LOCK_REGION_LENGTH__+0x40>
     330:	28 18       	sub	r2, r8
     332:	08 00       	.word	0x0008	; ????
     334:	20 3f       	cpi	r18, 0xF0	; 240
     336:	20 01       	movw	r4, r0
     338:	26 38       	cpi	r18, 0x86	; 134
     33a:	20 00       	.word	0x0020	; ????
     33c:	08 f8       	.word	0xf808	; ????
     33e:	08 00       	.word	0x0008	; ????
     340:	00 00       	nop
     342:	00 00       	nop
     344:	20 3f       	cpi	r18, 0xF0	; 240
     346:	20 20       	and	r2, r0
     348:	20 20       	and	r2, r0
     34a:	30 00       	.word	0x0030	; ????
     34c:	08 f8       	.word	0xf808	; ????
     34e:	f8 00       	.word	0x00f8	; ????
     350:	f8 f8       	.word	0xf8f8	; ????
     352:	08 00       	.word	0x0008	; ????
     354:	20 3f       	cpi	r18, 0xF0	; 240
     356:	00 3f       	cpi	r16, 0xF0	; 240
     358:	00 3f       	cpi	r16, 0xF0	; 240
     35a:	20 00       	.word	0x0020	; ????
     35c:	08 f8       	.word	0xf808	; ????
     35e:	30 c0       	rjmp	.+96     	; 0x3c0 <__EEPROM_REGION_LENGTH__+0x2c0>
     360:	00 08       	sbc	r0, r0
     362:	f8 08       	sbc	r15, r8
     364:	20 3f       	cpi	r18, 0xF0	; 240
     366:	20 00       	.word	0x0020	; ????
     368:	07 18       	sub	r0, r7
     36a:	3f 00       	.word	0x003f	; ????
     36c:	e0 10       	cpse	r14, r0
     36e:	08 08       	sbc	r0, r8
     370:	08 10       	cpse	r0, r8
     372:	e0 00       	.word	0x00e0	; ????
     374:	0f 10       	cpse	r0, r15
     376:	20 20       	and	r2, r0
     378:	20 10       	cpse	r2, r0
     37a:	0f 00       	.word	0x000f	; ????
     37c:	08 f8       	.word	0xf808	; ????
     37e:	08 08       	sbc	r0, r8
     380:	08 08       	sbc	r0, r8
     382:	f0 00       	.word	0x00f0	; ????
     384:	20 3f       	cpi	r18, 0xF0	; 240
     386:	21 01       	movw	r4, r2
     388:	01 01       	movw	r0, r2
     38a:	00 00       	nop
     38c:	e0 10       	cpse	r14, r0
     38e:	08 08       	sbc	r0, r8
     390:	08 10       	cpse	r0, r8
     392:	e0 00       	.word	0x00e0	; ????
     394:	0f 18       	sub	r0, r15
     396:	24 24       	eor	r2, r4
     398:	38 50       	subi	r19, 0x08	; 8
     39a:	4f 00       	.word	0x004f	; ????
     39c:	08 f8       	.word	0xf808	; ????
     39e:	88 88       	ldd	r8, Y+16	; 0x10
     3a0:	88 88       	ldd	r8, Y+16	; 0x10
     3a2:	70 00       	.word	0x0070	; ????
     3a4:	20 3f       	cpi	r18, 0xF0	; 240
     3a6:	20 00       	.word	0x0020	; ????
     3a8:	03 0c       	add	r0, r3
     3aa:	30 20       	and	r3, r0
     3ac:	00 70       	andi	r16, 0x00	; 0
     3ae:	88 08       	sbc	r8, r8
     3b0:	08 08       	sbc	r0, r8
     3b2:	38 00       	.word	0x0038	; ????
     3b4:	00 38       	cpi	r16, 0x80	; 128
     3b6:	20 21       	and	r18, r0
     3b8:	21 22       	and	r2, r17
     3ba:	1c 00       	.word	0x001c	; ????
     3bc:	18 08       	sbc	r1, r8
     3be:	08 f8       	.word	0xf808	; ????
     3c0:	08 08       	sbc	r0, r8
     3c2:	18 00       	.word	0x0018	; ????
     3c4:	00 00       	nop
     3c6:	20 3f       	cpi	r18, 0xF0	; 240
     3c8:	20 00       	.word	0x0020	; ????
     3ca:	00 00       	nop
     3cc:	08 f8       	.word	0xf808	; ????
     3ce:	08 00       	.word	0x0008	; ????
     3d0:	00 08       	sbc	r0, r0
     3d2:	f8 08       	sbc	r15, r8
     3d4:	00 1f       	adc	r16, r16
     3d6:	20 20       	and	r2, r0
     3d8:	20 20       	and	r2, r0
     3da:	1f 00       	.word	0x001f	; ????
     3dc:	08 78       	andi	r16, 0x88	; 136
     3de:	88 00       	.word	0x0088	; ????
     3e0:	00 c8       	rjmp	.-4096   	; 0xfffff3e2 <__eeprom_end+0xff7ef3e2>
     3e2:	38 08       	sbc	r3, r8
     3e4:	00 00       	nop
     3e6:	07 38       	cpi	r16, 0x87	; 135
     3e8:	0e 01       	movw	r0, r28
     3ea:	00 00       	nop
     3ec:	f8 08       	sbc	r15, r8
     3ee:	00 f8       	bld	r0, 0
     3f0:	00 08       	sbc	r0, r0
     3f2:	f8 00       	.word	0x00f8	; ????
     3f4:	03 3c       	cpi	r16, 0xC3	; 195
     3f6:	07 00       	.word	0x0007	; ????
     3f8:	07 3c       	cpi	r16, 0xC7	; 199
     3fa:	03 00       	.word	0x0003	; ????
     3fc:	08 18       	sub	r0, r8
     3fe:	68 80       	ld	r6, Y
     400:	80 68       	ori	r24, 0x80	; 128
     402:	18 08       	sbc	r1, r8
     404:	20 30       	cpi	r18, 0x00	; 0
     406:	2c 03       	fmul	r18, r20
     408:	03 2c       	mov	r0, r3
     40a:	30 20       	and	r3, r0
     40c:	08 38       	cpi	r16, 0x88	; 136
     40e:	c8 00       	.word	0x00c8	; ????
     410:	c8 38       	cpi	r28, 0x88	; 136
     412:	08 00       	.word	0x0008	; ????
     414:	00 00       	nop
     416:	20 3f       	cpi	r18, 0xF0	; 240
     418:	20 00       	.word	0x0020	; ????
     41a:	00 00       	nop
     41c:	10 08       	sbc	r1, r0
     41e:	08 08       	sbc	r0, r8
     420:	c8 38       	cpi	r28, 0x88	; 136
     422:	08 00       	.word	0x0008	; ????
     424:	20 38       	cpi	r18, 0x80	; 128
     426:	26 21       	and	r18, r6
     428:	20 20       	and	r2, r0
     42a:	18 00       	.word	0x0018	; ????
     42c:	00 00       	nop
     42e:	00 fe       	sbrs	r0, 0
     430:	02 02       	muls	r16, r18
     432:	02 00       	.word	0x0002	; ????
     434:	00 00       	nop
     436:	00 7f       	andi	r16, 0xF0	; 240
     438:	40 40       	sbci	r20, 0x00	; 0
     43a:	40 00       	.word	0x0040	; ????
     43c:	00 0c       	add	r0, r0
     43e:	30 c0       	rjmp	.+96     	; 0x4a0 <__LOCK_REGION_LENGTH__+0xa0>
     440:	00 00       	nop
     442:	00 00       	nop
     444:	00 00       	nop
     446:	00 01       	movw	r0, r0
     448:	06 38       	cpi	r16, 0x86	; 134
     44a:	c0 00       	.word	0x00c0	; ????
     44c:	00 02       	muls	r16, r16
     44e:	02 02       	muls	r16, r18
     450:	fe 00       	.word	0x00fe	; ????
     452:	00 00       	nop
     454:	00 40       	sbci	r16, 0x00	; 0
     456:	40 40       	sbci	r20, 0x00	; 0
     458:	7f 00       	.word	0x007f	; ????
     45a:	00 00       	nop
     45c:	00 00       	nop
     45e:	04 02       	muls	r16, r20
     460:	02 02       	muls	r16, r18
     462:	04 00       	.word	0x0004	; ????
	...
     474:	80 80       	ld	r8, Z
     476:	80 80       	ld	r8, Z
     478:	80 80       	ld	r8, Z
     47a:	80 80       	ld	r8, Z
     47c:	00 02       	muls	r16, r16
     47e:	02 04       	cpc	r0, r2
	...
     48c:	00 00       	nop
     48e:	80 80       	ld	r8, Z
     490:	80 80       	ld	r8, Z
     492:	00 00       	nop
     494:	00 19       	sub	r16, r0
     496:	24 22       	and	r2, r20
     498:	22 22       	and	r2, r18
     49a:	3f 20       	and	r3, r15
     49c:	08 f8       	.word	0xf808	; ????
     49e:	00 80       	ld	r0, Z
     4a0:	80 00       	.word	0x0080	; ????
     4a2:	00 00       	nop
     4a4:	00 3f       	cpi	r16, 0xF0	; 240
     4a6:	11 20       	and	r1, r1
     4a8:	20 11       	cpse	r18, r0
     4aa:	0e 00       	.word	0x000e	; ????
     4ac:	00 00       	nop
     4ae:	00 80       	ld	r0, Z
     4b0:	80 80       	ld	r8, Z
     4b2:	00 00       	nop
     4b4:	00 0e       	add	r0, r16
     4b6:	11 20       	and	r1, r1
     4b8:	20 20       	and	r2, r0
     4ba:	11 00       	.word	0x0011	; ????
     4bc:	00 00       	nop
     4be:	00 80       	ld	r0, Z
     4c0:	80 88       	ldd	r8, Z+16	; 0x10
     4c2:	f8 00       	.word	0x00f8	; ????
     4c4:	00 0e       	add	r0, r16
     4c6:	11 20       	and	r1, r1
     4c8:	20 10       	cpse	r2, r0
     4ca:	3f 20       	and	r3, r15
     4cc:	00 00       	nop
     4ce:	80 80       	ld	r8, Z
     4d0:	80 80       	ld	r8, Z
     4d2:	00 00       	nop
     4d4:	00 1f       	adc	r16, r16
     4d6:	22 22       	and	r2, r18
     4d8:	22 22       	and	r2, r18
     4da:	13 00       	.word	0x0013	; ????
     4dc:	00 80       	ld	r0, Z
     4de:	80 f0       	brcs	.+32     	; 0x500 <__LOCK_REGION_LENGTH__+0x100>
     4e0:	88 88       	ldd	r8, Y+16	; 0x10
     4e2:	88 18       	sub	r8, r8
     4e4:	00 20       	and	r0, r0
     4e6:	20 3f       	cpi	r18, 0xF0	; 240
     4e8:	20 20       	and	r2, r0
     4ea:	00 00       	nop
     4ec:	00 00       	nop
     4ee:	80 80       	ld	r8, Z
     4f0:	80 80       	ld	r8, Z
     4f2:	80 00       	.word	0x0080	; ????
     4f4:	00 6b       	ori	r16, 0xB0	; 176
     4f6:	94 94       	.word	0x9494	; ????
     4f8:	94 93       	xch	Z, r25
     4fa:	60 00       	.word	0x0060	; ????
     4fc:	08 f8       	.word	0xf808	; ????
     4fe:	00 80       	ld	r0, Z
     500:	80 80       	ld	r8, Z
     502:	00 00       	nop
     504:	20 3f       	cpi	r18, 0xF0	; 240
     506:	21 00       	.word	0x0021	; ????
     508:	00 20       	and	r0, r0
     50a:	3f 20       	and	r3, r15
     50c:	00 80       	ld	r0, Z
     50e:	98 98       	cbi	0x13, 0	; 19
     510:	00 00       	nop
     512:	00 00       	nop
     514:	00 20       	and	r0, r0
     516:	20 3f       	cpi	r18, 0xF0	; 240
     518:	20 20       	and	r2, r0
     51a:	00 00       	nop
     51c:	00 00       	nop
     51e:	00 80       	ld	r0, Z
     520:	98 98       	cbi	0x13, 0	; 19
     522:	00 00       	nop
     524:	00 c0       	rjmp	.+0      	; 0x526 <__LOCK_REGION_LENGTH__+0x126>
     526:	80 80       	ld	r8, Z
     528:	80 7f       	andi	r24, 0xF0	; 240
     52a:	00 00       	nop
     52c:	08 f8       	.word	0xf808	; ????
     52e:	00 00       	nop
     530:	80 80       	ld	r8, Z
     532:	80 00       	.word	0x0080	; ????
     534:	20 3f       	cpi	r18, 0xF0	; 240
     536:	24 02       	muls	r18, r20
     538:	2d 30       	cpi	r18, 0x0D	; 13
     53a:	20 00       	.word	0x0020	; ????
     53c:	00 08       	sbc	r0, r0
     53e:	08 f8       	.word	0xf808	; ????
     540:	00 00       	nop
     542:	00 00       	nop
     544:	00 20       	and	r0, r0
     546:	20 3f       	cpi	r18, 0xF0	; 240
     548:	20 20       	and	r2, r0
     54a:	00 00       	nop
     54c:	80 80       	ld	r8, Z
     54e:	80 80       	ld	r8, Z
     550:	80 80       	ld	r8, Z
     552:	80 00       	.word	0x0080	; ????
     554:	20 3f       	cpi	r18, 0xF0	; 240
     556:	20 00       	.word	0x0020	; ????
     558:	3f 20       	and	r3, r15
     55a:	00 3f       	cpi	r16, 0xF0	; 240
     55c:	80 80       	ld	r8, Z
     55e:	00 80       	ld	r0, Z
     560:	80 80       	ld	r8, Z
     562:	00 00       	nop
     564:	20 3f       	cpi	r18, 0xF0	; 240
     566:	21 00       	.word	0x0021	; ????
     568:	00 20       	and	r0, r0
     56a:	3f 20       	and	r3, r15
     56c:	00 00       	nop
     56e:	80 80       	ld	r8, Z
     570:	80 80       	ld	r8, Z
     572:	00 00       	nop
     574:	00 1f       	adc	r16, r16
     576:	20 20       	and	r2, r0
     578:	20 20       	and	r2, r0
     57a:	1f 00       	.word	0x001f	; ????
     57c:	80 80       	ld	r8, Z
     57e:	00 80       	ld	r0, Z
     580:	80 00       	.word	0x0080	; ????
     582:	00 00       	nop
     584:	80 ff       	sbrs	r24, 0
     586:	a1 20       	and	r10, r1
     588:	20 11       	cpse	r18, r0
     58a:	0e 00       	.word	0x000e	; ????
     58c:	00 00       	nop
     58e:	00 80       	ld	r0, Z
     590:	80 80       	ld	r8, Z
     592:	80 00       	.word	0x0080	; ????
     594:	00 0e       	add	r0, r16
     596:	11 20       	and	r1, r1
     598:	20 a0       	ldd	r2, Z+32	; 0x20
     59a:	ff 80       	ldd	r15, Y+7	; 0x07
     59c:	80 80       	ld	r8, Z
     59e:	80 00       	.word	0x0080	; ????
     5a0:	80 80       	ld	r8, Z
     5a2:	80 00       	.word	0x0080	; ????
     5a4:	20 20       	and	r2, r0
     5a6:	3f 21       	and	r19, r15
     5a8:	20 00       	.word	0x0020	; ????
     5aa:	01 00       	.word	0x0001	; ????
     5ac:	00 00       	nop
     5ae:	80 80       	ld	r8, Z
     5b0:	80 80       	ld	r8, Z
     5b2:	80 00       	.word	0x0080	; ????
     5b4:	00 33       	cpi	r16, 0x30	; 48
     5b6:	24 24       	eor	r2, r4
     5b8:	24 24       	eor	r2, r4
     5ba:	19 00       	.word	0x0019	; ????
     5bc:	00 80       	ld	r0, Z
     5be:	80 e0       	ldi	r24, 0x00	; 0
     5c0:	80 80       	ld	r8, Z
     5c2:	00 00       	nop
     5c4:	00 00       	nop
     5c6:	00 1f       	adc	r16, r16
     5c8:	20 20       	and	r2, r0
     5ca:	00 00       	nop
     5cc:	80 80       	ld	r8, Z
     5ce:	00 00       	nop
     5d0:	00 80       	ld	r0, Z
     5d2:	80 00       	.word	0x0080	; ????
     5d4:	00 1f       	adc	r16, r16
     5d6:	20 20       	and	r2, r0
     5d8:	20 10       	cpse	r2, r0
     5da:	3f 20       	and	r3, r15
     5dc:	80 80       	ld	r8, Z
     5de:	80 00       	.word	0x0080	; ????
     5e0:	00 80       	ld	r0, Z
     5e2:	80 80       	ld	r8, Z
     5e4:	00 01       	movw	r0, r0
     5e6:	0e 30       	cpi	r16, 0x0E	; 14
     5e8:	08 06       	cpc	r0, r24
     5ea:	01 00       	.word	0x0001	; ????
     5ec:	80 80       	ld	r8, Z
     5ee:	00 80       	ld	r0, Z
     5f0:	00 80       	ld	r0, Z
     5f2:	80 80       	ld	r8, Z
     5f4:	0f 30       	cpi	r16, 0x0F	; 15
     5f6:	0c 03       	fmul	r16, r20
     5f8:	0c 30       	cpi	r16, 0x0C	; 12
     5fa:	0f 00       	.word	0x000f	; ????
     5fc:	00 80       	ld	r0, Z
     5fe:	80 00       	.word	0x0080	; ????
     600:	80 80       	ld	r8, Z
     602:	80 00       	.word	0x0080	; ????
     604:	00 20       	and	r0, r0
     606:	31 2e       	mov	r3, r17
     608:	0e 31       	cpi	r16, 0x1E	; 30
     60a:	20 00       	.word	0x0020	; ????
     60c:	80 80       	ld	r8, Z
     60e:	80 00       	.word	0x0080	; ????
     610:	00 80       	ld	r0, Z
     612:	80 80       	ld	r8, Z
     614:	80 81       	ld	r24, Z
     616:	8e 70       	andi	r24, 0x0E	; 14
     618:	18 06       	cpc	r1, r24
     61a:	01 00       	.word	0x0001	; ????
     61c:	00 80       	ld	r0, Z
     61e:	80 80       	ld	r8, Z
     620:	80 80       	ld	r8, Z
     622:	80 00       	.word	0x0080	; ????
     624:	00 21       	and	r16, r0
     626:	30 2c       	mov	r3, r0
     628:	22 21       	and	r18, r2
     62a:	30 00       	.word	0x0030	; ????
     62c:	00 00       	nop
     62e:	00 00       	nop
     630:	80 7c       	andi	r24, 0xC0	; 192
     632:	02 02       	muls	r16, r18
     634:	00 00       	nop
     636:	00 00       	nop
     638:	00 3f       	cpi	r16, 0xF0	; 240
     63a:	40 40       	sbci	r20, 0x00	; 0
     63c:	00 00       	nop
     63e:	00 00       	nop
     640:	ff 00       	.word	0x00ff	; ????
     642:	00 00       	nop
     644:	00 00       	nop
     646:	00 00       	nop
     648:	ff 00       	.word	0x00ff	; ????
     64a:	00 00       	nop
     64c:	00 02       	muls	r16, r16
     64e:	02 7c       	andi	r16, 0xC2	; 194
     650:	80 00       	.word	0x0080	; ????
     652:	00 00       	nop
     654:	00 40       	sbci	r16, 0x00	; 0
     656:	40 3f       	cpi	r20, 0xF0	; 240
     658:	00 00       	nop
     65a:	00 00       	nop
     65c:	00 06       	cpc	r0, r16
     65e:	01 01       	movw	r0, r2
     660:	02 02       	muls	r16, r18
     662:	04 04       	cpc	r0, r4
	...

0000066c <tiny4koled_init_128x32r>:
     66c:	c8 a1 a8 1f da 02 8d 14                             ........

00000674 <__ctors_start>:
__ctors_start():
     674:	5b 09       	sbc	r21, r11

00000676 <__ctors_end>:
__dtors_end():
../../../../crt1/gcrt1.S:230
     676:	11 24       	eor	r1, r1
../../../../crt1/gcrt1.S:231
     678:	1f be       	out	0x3f, r1	; 63
../../../../crt1/gcrt1.S:232
     67a:	cf ef       	ldi	r28, 0xFF	; 255
../../../../crt1/gcrt1.S:234
     67c:	cd bf       	out	0x3d, r28	; 61
../../../../crt1/gcrt1.S:236
     67e:	df e3       	ldi	r29, 0x3F	; 63
../../../../crt1/gcrt1.S:237
     680:	de bf       	out	0x3e, r29	; 62

00000682 <__do_copy_data>:
__do_copy_data():
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2409
     682:	18 e3       	ldi	r17, 0x38	; 56
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2410
     684:	a0 e0       	ldi	r26, 0x00	; 0
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2411
     686:	b8 e3       	ldi	r27, 0x38	; 56
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2412
     688:	ec e4       	ldi	r30, 0x4C	; 76
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2413
     68a:	f9 e1       	ldi	r31, 0x19	; 25
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2414
     68c:	02 c0       	rjmp	.+4      	; 0x692 <__do_copy_data+0x10>
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2417
     68e:	05 90       	lpm	r0, Z+
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2422
     690:	0d 92       	st	X+, r0
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2424
     692:	a8 30       	cpi	r26, 0x08	; 8
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2425
     694:	b1 07       	cpc	r27, r17
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2426
     696:	d9 f7       	brne	.-10     	; 0x68e <__do_copy_data+0xc>

00000698 <__do_clear_bss>:
__do_clear_bss():
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
     698:	28 e3       	ldi	r18, 0x38	; 56
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
     69a:	a8 e0       	ldi	r26, 0x08	; 8
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
     69c:	b8 e3       	ldi	r27, 0x38	; 56
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
     69e:	01 c0       	rjmp	.+2      	; 0x6a2 <.do_clear_bss_start>

000006a0 <.do_clear_bss_loop>:
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
     6a0:	1d 92       	st	X+, r1

000006a2 <.do_clear_bss_start>:
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
     6a2:	a6 38       	cpi	r26, 0x86	; 134
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
     6a4:	b2 07       	cpc	r27, r18
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
     6a6:	e1 f7       	brne	.-8      	; 0x6a0 <.do_clear_bss_loop>

000006a8 <__do_global_ctors>:
__do_global_ctors():
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
     6a8:	13 e0       	ldi	r17, 0x03	; 3
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
     6aa:	cb e3       	ldi	r28, 0x3B	; 59
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
     6ac:	d3 e0       	ldi	r29, 0x03	; 3
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
     6ae:	04 c0       	rjmp	.+8      	; 0x6b8 <__do_global_ctors+0x10>
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
     6b0:	21 97       	sbiw	r28, 0x01	; 1
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
     6b2:	fe 01       	movw	r30, r28
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
     6b4:	0e 94 b5 0b 	call	0x176a	; 0x176a <__tablejump2__>
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
     6b8:	ca 33       	cpi	r28, 0x3A	; 58
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
     6ba:	d1 07       	cpc	r29, r17
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
     6bc:	c9 f7       	brne	.-14     	; 0x6b0 <__do_global_ctors+0x8>
../../../../crt1/gcrt1.S:314
     6be:	0e 94 8c 09 	call	0x1318	; 0x1318 <main>
../../../../crt1/gcrt1.S:315
     6c2:	0c 94 ca 0b 	jmp	0x1794	; 0x1794 <_exit>

000006c6 <__bad_interrupt>:
__vector_22():
../../../../crt1/gcrt1.S:209
     6c6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000006ca <Print::write(unsigned char const*, unsigned int)>:
write():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:29
#include "Print.h"

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size) {
     6ca:	af 92       	push	r10
     6cc:	bf 92       	push	r11
     6ce:	cf 92       	push	r12
     6d0:	df 92       	push	r13
     6d2:	ef 92       	push	r14
     6d4:	ff 92       	push	r15
     6d6:	0f 93       	push	r16
     6d8:	1f 93       	push	r17
     6da:	cf 93       	push	r28
     6dc:	df 93       	push	r29
     6de:	6c 01       	movw	r12, r24
     6e0:	7b 01       	movw	r14, r22
     6e2:	8b 01       	movw	r16, r22
     6e4:	04 0f       	add	r16, r20
     6e6:	15 1f       	adc	r17, r21
     6e8:	eb 01       	movw	r28, r22
     6ea:	5e 01       	movw	r10, r28
     6ec:	ae 18       	sub	r10, r14
     6ee:	bf 08       	sbc	r11, r15
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:31
  size_t n = 0;
  while (size--) {
     6f0:	c0 17       	cp	r28, r16
     6f2:	d1 07       	cpc	r29, r17
     6f4:	59 f0       	breq	.+22     	; 0x70c <Print::write(unsigned char const*, unsigned int)+0x42>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:32
    if (write(*buffer++)) {
     6f6:	69 91       	ld	r22, Y+
     6f8:	d6 01       	movw	r26, r12
     6fa:	ed 91       	ld	r30, X+
     6fc:	fc 91       	ld	r31, X
     6fe:	01 90       	ld	r0, Z+
     700:	f0 81       	ld	r31, Z
     702:	e0 2d       	mov	r30, r0
     704:	c6 01       	movw	r24, r12
     706:	09 95       	icall
     708:	89 2b       	or	r24, r25
     70a:	79 f7       	brne	.-34     	; 0x6ea <Print::write(unsigned char const*, unsigned int)+0x20>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:39
    } else {
      break;
    }
  }
  return n;
}
     70c:	c5 01       	movw	r24, r10
     70e:	df 91       	pop	r29
     710:	cf 91       	pop	r28
     712:	1f 91       	pop	r17
     714:	0f 91       	pop	r16
     716:	ff 90       	pop	r15
     718:	ef 90       	pop	r14
     71a:	df 90       	pop	r13
     71c:	cf 90       	pop	r12
     71e:	bf 90       	pop	r11
     720:	af 90       	pop	r10
     722:	08 95       	ret

00000724 <micros>:
micros():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:216
  #else
  uint8_t ticks;
  #endif

  /* Save current state and disable interrupts */
  uint8_t status = SREG;
     724:	8f b7       	in	r24, 0x3f	; 63
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:217
  cli();
     726:	f8 94       	cli
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:223



  /* Get current number of overflows and timer count */
  #if !(defined(MILLIS_USE_TIMERB0)  || defined(MILLIS_USE_TIMERB1) )
  overflows = timer_overflow_count;
     728:	20 91 4e 38 	lds	r18, 0x384E	; 0x80384e <timer_overflow_count>
     72c:	30 91 4f 38 	lds	r19, 0x384F	; 0x80384f <timer_overflow_count+0x1>
     730:	40 91 50 38 	lds	r20, 0x3850	; 0x803850 <timer_overflow_count+0x2>
     734:	50 91 51 38 	lds	r21, 0x3851	; 0x803851 <timer_overflow_count+0x3>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:231
  #endif

  #if defined(MILLIS_USE_TIMERA0)
  ticks = (TIME_TRACKING_TIMER_PERIOD) - TCA0.SPLIT.HCNT;
  #elif defined(MILLIS_USE_TIMERD0)
  TCD0.CTRLE = TCD_SCAPTUREA_bm;
     738:	98 e0       	ldi	r25, 0x08	; 8
     73a:	90 93 84 0a 	sts	0x0A84, r25	; 0x800a84 <vtable for SSD1306Device+0x7f7140>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:232
  while (!(TCD0.STATUS & TCD_CMDRDY_bm)); //wait for sync - should be only one iteration of this loop
     73e:	90 91 8e 0a 	lds	r25, 0x0A8E	; 0x800a8e <vtable for SSD1306Device+0x7f714a>
     742:	91 ff       	sbrs	r25, 1
     744:	fc cf       	rjmp	.-8      	; 0x73e <micros+0x1a>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:233
  ticks = TCD0.CAPTUREA;
     746:	e0 91 a2 0a 	lds	r30, 0x0AA2	; 0x800aa2 <vtable for SSD1306Device+0x7f715e>
     74a:	f0 91 a3 0a 	lds	r31, 0x0AA3	; 0x800aa3 <vtable for SSD1306Device+0x7f715f>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:242
  /* If the timer overflow flag is raised, and the ticks we read are low, then the timer has rolled over but
    ISR has not fired. If we already read a high value of ticks, either we read it just before the overflow,
    so we shouldn't increment overflows, or interrupts are disabled and micros isn't expected to work so it doesn't matter
  */
  #if defined(MILLIS_USE_TIMERD0)
  if ((TCD0.INTFLAGS & TCD_OVF_bm) && !(ticks & 0xFF00)) {
     74e:	90 91 8d 0a 	lds	r25, 0x0A8D	; 0x800a8d <vtable for SSD1306Device+0x7f7149>
     752:	90 ff       	sbrs	r25, 0
     754:	08 c0       	rjmp	.+16     	; 0x766 <micros+0x42>
     756:	bf 01       	movw	r22, r30
     758:	66 27       	eor	r22, r22
     75a:	67 2b       	or	r22, r23
     75c:	21 f4       	brne	.+8      	; 0x766 <micros+0x42>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:251
  if ((_timer->INTFLAGS & TCB_CAPT_bm) && !(ticks & 0xFF00)) {
  #endif
    #if ((defined(MILLIS_USE_TIMERB0)|defined(MILLIS_USE_TIMERB1))&&(F_CPU>1000000))
    overflows++;
    #else
    overflows += 2;
     75e:	2e 5f       	subi	r18, 0xFE	; 254
     760:	3f 4f       	sbci	r19, 0xFF	; 255
     762:	4f 4f       	sbci	r20, 0xFF	; 255
     764:	5f 4f       	sbci	r21, 0xFF	; 255
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:258
  }

  //end getting ticks

  /* Restore state */
  SREG = status;
     766:	8f bf       	out	0x3f, r24	; 63
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:261
  #if defined(MILLIS_USE_TIMERD0)
  #if (F_CPU==20000000UL || F_CPU==10000000UL || F_CPU==5000000UL)
  uint8_t ticks_l = ticks >> 1;
     768:	bf 01       	movw	r22, r30
     76a:	76 95       	lsr	r23
     76c:	67 95       	ror	r22
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:262
  ticks = ticks + ticks_l + ((ticks_l >> 2) - (ticks_l >> 4) + (ticks_l >> 7));
     76e:	cf 01       	movw	r24, r30
     770:	86 0f       	add	r24, r22
     772:	91 1d       	adc	r25, r1
     774:	e6 2f       	mov	r30, r22
     776:	e6 95       	lsr	r30
     778:	e6 95       	lsr	r30
     77a:	76 2f       	mov	r23, r22
     77c:	72 95       	swap	r23
     77e:	7f 70       	andi	r23, 0x0F	; 15
     780:	e7 1b       	sub	r30, r23
     782:	ff 0b       	sbc	r31, r31
     784:	67 fd       	sbrc	r22, 7
     786:	31 96       	adiw	r30, 0x01	; 1
     788:	e8 0f       	add	r30, r24
     78a:	f9 1f       	adc	r31, r25
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:263
  microseconds = overflows * (TIME_TRACKING_CYCLES_PER_OVF / (20))
     78c:	a0 e3       	ldi	r26, 0x30	; 48
     78e:	b3 e0       	ldi	r27, 0x03	; 3
     790:	0e 94 aa 0b 	call	0x1754	; 0x1754 <__muluhisi3>
     794:	6e 0f       	add	r22, r30
     796:	7f 1f       	adc	r23, r31
     798:	81 1d       	adc	r24, r1
     79a:	91 1d       	adc	r25, r1
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:308
  microseconds = ((overflows * millisClockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF))
                  + (ticks * (millisClockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF) / TIME_TRACKING_TIMER_PERIOD)));
  #endif
  #endif //end of timer-specific part of micros calculations
  return microseconds;
}
     79c:	08 95       	ret

0000079e <TWI_SlaveTransactionFinished>:
TWI_SlaveTransactionFinished():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:808
    Prepares module for new transaction.

    \param result  The result of the operation.
*/
void TWI_SlaveTransactionFinished(uint8_t result) {
  TWI0.SCTRLA |= (TWI_APIEN_bm | TWI_PIEN_bm);
     79e:	e0 e1       	ldi	r30, 0x10	; 16
     7a0:	f8 e0       	ldi	r31, 0x08	; 8
     7a2:	91 85       	ldd	r25, Z+9	; 0x09
     7a4:	90 66       	ori	r25, 0x60	; 96
     7a6:	91 87       	std	Z+9, r25	; 0x09
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:809
  twi_mode = TWI_MODE_SLAVE;
     7a8:	92 e0       	ldi	r25, 0x02	; 2
     7aa:	90 93 40 38 	sts	0x3840, r25	; 0x803840 <twi_mode>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:810
  slave_result = result;
     7ae:	80 93 37 38 	sts	0x3837, r24	; 0x803837 <slave_result>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:811
  slave_trans_status = TWIM_STATUS_READY;
     7b2:	10 92 36 38 	sts	0x3836, r1	; 0x803836 <slave_trans_status>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:812
}
     7b6:	08 95       	ret

000007b8 <TWI_SlaveAddressMatchHandler>:
TWI_SlaveAddressMatchHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:653
    This is the slave address match handler that takes care of responding to
    being addressed by a master

*/
void TWI_SlaveAddressMatchHandler() {
  slave_trans_status = TWIS_STATUS_BUSY;
     7b8:	81 e0       	ldi	r24, 0x01	; 1
     7ba:	80 93 36 38 	sts	0x3836, r24	; 0x803836 <slave_trans_status>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:654
  slave_result = TWIS_RESULT_UNKNOWN;
     7be:	10 92 37 38 	sts	0x3837, r1	; 0x803837 <slave_result>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:657

  /* If Master Read/Slave Write */
  if (TWI0.SSTATUS & TWI_DIR_bm) {
     7c2:	90 91 1b 08 	lds	r25, 0x081B	; 0x80081b <vtable for SSD1306Device+0x7f6ed7>
     7c6:	91 ff       	sbrs	r25, 1
     7c8:	0e c0       	rjmp	.+28     	; 0x7e6 <TWI_SlaveAddressMatchHandler+0x2e>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:658
    slave_bytesWritten = 0;
     7ca:	10 92 46 38 	sts	0x3846, r1	; 0x803846 <slave_bytesWritten>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:660
    /* Call user function  */
    slave_bytesToWrite = TWI_onSlaveTransmit();
     7ce:	f0 e0       	ldi	r31, 0x00	; 0
     7d0:	e0 e0       	ldi	r30, 0x00	; 0
     7d2:	09 95       	icall
     7d4:	80 93 45 38 	sts	0x3845, r24	; 0x803845 <slave_bytesToWrite>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:661
    twi_mode = TWI_MODE_SLAVE_TRANSMIT;
     7d8:	85 e0       	ldi	r24, 0x05	; 5
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:667
  }
  /* If Master Write/Slave Read */
  else {
    slave_bytesRead = 0;
    slave_callUserReceive = 1;
    twi_mode = TWI_MODE_SLAVE_RECEIVE;
     7da:	80 93 40 38 	sts	0x3840, r24	; 0x803840 <twi_mode>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:671
  }

  /* Send ACK, wait for data interrupt */
  TWI0.SCTRLB = TWI_SCMD_RESPONSE_gc;
     7de:	83 e0       	ldi	r24, 0x03	; 3
     7e0:	80 93 1a 08 	sts	0x081A, r24	; 0x80081a <vtable for SSD1306Device+0x7f6ed6>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:674

  /* Data interrupt to follow... */
}
     7e4:	08 95       	ret
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:665
    slave_bytesToWrite = TWI_onSlaveTransmit();
    twi_mode = TWI_MODE_SLAVE_TRANSMIT;
  }
  /* If Master Write/Slave Read */
  else {
    slave_bytesRead = 0;
     7e6:	10 92 47 38 	sts	0x3847, r1	; 0x803847 <slave_bytesRead>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:666
    slave_callUserReceive = 1;
     7ea:	80 93 44 38 	sts	0x3844, r24	; 0x803844 <slave_callUserReceive>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:667
    twi_mode = TWI_MODE_SLAVE_RECEIVE;
     7ee:	86 e0       	ldi	r24, 0x06	; 6
     7f0:	f4 cf       	rjmp	.-24     	; 0x7da <TWI_SlaveAddressMatchHandler+0x22>

000007f2 <TwoWire::flush()>:
flush():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:385
  //  rxBufferIndex = 0;
  //  rxBufferLength = 0;
  //
  //  /* Turn off and on TWI module */
  //  TWI_Flush();
}
     7f2:	08 95       	ret

000007f4 <TwoWire::peek()>:
peek():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:361
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::peek(void) {
  int value = -1;

  if (rxBufferIndex < rxBufferLength) {
     7f4:	81 e0       	ldi	r24, 0x01	; 1
     7f6:	90 e0       	ldi	r25, 0x00	; 0
     7f8:	30 91 35 38 	lds	r19, 0x3835	; 0x803835 <TwoWire::rxBufferIndex>
     7fc:	20 91 34 38 	lds	r18, 0x3834	; 0x803834 <TwoWire::rxBufferLength>
     800:	32 17       	cp	r19, r18
     802:	10 f4       	brcc	.+4      	; 0x808 <__DATA_REGION_LENGTH__+0x8>
     804:	90 e0       	ldi	r25, 0x00	; 0
     806:	80 e0       	ldi	r24, 0x00	; 0
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:366
    value = rxBuffer[rxBufferIndex];
  }

  return value;
}
     808:	91 95       	neg	r25
     80a:	81 95       	neg	r24
     80c:	91 09       	sbc	r25, r1
     80e:	08 95       	ret

00000810 <TwoWire::read()>:
read():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:347
// or after requestFrom(address, numBytes)
int TwoWire::read(void) {
  int value = -1;

  // get each successive byte on each call
  if (rxBufferIndex < rxBufferLength) {
     810:	80 91 35 38 	lds	r24, 0x3835	; 0x803835 <TwoWire::rxBufferIndex>
     814:	90 91 34 38 	lds	r25, 0x3834	; 0x803834 <TwoWire::rxBufferLength>
     818:	89 17       	cp	r24, r25
     81a:	30 f4       	brcc	.+12     	; 0x828 <TwoWire::read()+0x18>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:349
    value = rxBuffer[rxBufferIndex];
    rxBufferIndex++;
     81c:	8f 5f       	subi	r24, 0xFF	; 255
     81e:	80 93 35 38 	sts	0x3835, r24	; 0x803835 <TwoWire::rxBufferIndex>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:348
int TwoWire::read(void) {
  int value = -1;

  // get each successive byte on each call
  if (rxBufferIndex < rxBufferLength) {
    value = rxBuffer[rxBufferIndex];
     822:	90 e0       	ldi	r25, 0x00	; 0
     824:	80 e0       	ldi	r24, 0x00	; 0
     826:	08 95       	ret
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:344

// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void) {
  int value = -1;
     828:	8f ef       	ldi	r24, 0xFF	; 255
     82a:	9f ef       	ldi	r25, 0xFF	; 255
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:353
    value = rxBuffer[rxBufferIndex];
    rxBufferIndex++;
  }

  return value;
}
     82c:	08 95       	ret

0000082e <TwoWire::available()>:
available():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:337

// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void) {
  return rxBufferLength - rxBufferIndex;
     82e:	80 91 34 38 	lds	r24, 0x3834	; 0x803834 <TwoWire::rxBufferLength>
     832:	90 91 35 38 	lds	r25, 0x3835	; 0x803835 <TwoWire::rxBufferIndex>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:338
}
     836:	89 1b       	sub	r24, r25
     838:	99 0b       	sbc	r25, r25
     83a:	08 95       	ret

0000083c <TwoWire::write(unsigned char const*, unsigned int)>:
write():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:323
}

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity) {
     83c:	cf 92       	push	r12
     83e:	df 92       	push	r13
     840:	ef 92       	push	r14
     842:	ff 92       	push	r15
     844:	0f 93       	push	r16
     846:	1f 93       	push	r17
     848:	cf 93       	push	r28
     84a:	df 93       	push	r29
     84c:	7c 01       	movw	r14, r24
     84e:	8a 01       	movw	r16, r20
     850:	eb 01       	movw	r28, r22
     852:	6b 01       	movw	r12, r22
     854:	c4 0e       	add	r12, r20
     856:	d5 1e       	adc	r13, r21
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:325

  for (size_t i = 0; i < quantity; i++) {
     858:	cc 15       	cp	r28, r12
     85a:	dd 05       	cpc	r29, r13
     85c:	51 f0       	breq	.+20     	; 0x872 <TwoWire::write(unsigned char const*, unsigned int)+0x36>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:326
    write(*(data + i));
     85e:	69 91       	ld	r22, Y+
     860:	d7 01       	movw	r26, r14
     862:	ed 91       	ld	r30, X+
     864:	fc 91       	ld	r31, X
     866:	01 90       	ld	r0, Z+
     868:	f0 81       	ld	r31, Z
     86a:	e0 2d       	mov	r30, r0
     86c:	c7 01       	movw	r24, r14
     86e:	09 95       	icall
     870:	f3 cf       	rjmp	.-26     	; 0x858 <TwoWire::write(unsigned char const*, unsigned int)+0x1c>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:330
  }

  return quantity;
}
     872:	c8 01       	movw	r24, r16
     874:	df 91       	pop	r29
     876:	cf 91       	pop	r28
     878:	1f 91       	pop	r17
     87a:	0f 91       	pop	r16
     87c:	ff 90       	pop	r15
     87e:	ef 90       	pop	r14
     880:	df 90       	pop	r13
     882:	cf 90       	pop	r12
     884:	08 95       	ret

00000886 <TwoWire::write(unsigned char)>:
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:305
// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data) {
  /* Check if buffer is full */
  if (txBufferLength >= BUFFER_LENGTH) {
     886:	20 91 33 38 	lds	r18, 0x3833	; 0x803833 <TwoWire::txBufferLength>
     88a:	20 32       	cpi	r18, 0x20	; 32
     88c:	40 f0       	brcs	.+16     	; 0x89e <TwoWire::write(unsigned char)+0x18>
_ZN5Print13setWriteErrorEi():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.h:39
    int write_error;
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) {
      write_error = err;
     88e:	21 e0       	ldi	r18, 0x01	; 1
     890:	30 e0       	ldi	r19, 0x00	; 0
     892:	fc 01       	movw	r30, r24
     894:	22 83       	std	Z+2, r18	; 0x02
     896:	33 83       	std	Z+3, r19	; 0x03
write():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:307
    setWriteError();
    return 0;
     898:	90 e0       	ldi	r25, 0x00	; 0
     89a:	80 e0       	ldi	r24, 0x00	; 0
     89c:	08 95       	ret
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:311
  }

  /* Put byte in txBuffer */
  txBuffer[txBufferIndex] = data;
     89e:	80 91 32 38 	lds	r24, 0x3832	; 0x803832 <TwoWire::txBufferIndex>
     8a2:	e8 2f       	mov	r30, r24
     8a4:	f0 e0       	ldi	r31, 0x00	; 0
     8a6:	ee 5e       	subi	r30, 0xEE	; 238
     8a8:	f7 4c       	sbci	r31, 0xC7	; 199
     8aa:	60 83       	st	Z, r22
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:312
  txBufferIndex++;
     8ac:	8f 5f       	subi	r24, 0xFF	; 255
     8ae:	80 93 32 38 	sts	0x3832, r24	; 0x803832 <TwoWire::txBufferIndex>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:315

  /* Update buffer length */
  txBufferLength = txBufferIndex;
     8b2:	80 93 33 38 	sts	0x3833, r24	; 0x803833 <TwoWire::txBufferLength>
     8b6:	81 e0       	ldi	r24, 0x01	; 1
     8b8:	90 e0       	ldi	r25, 0x00	; 0
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:318

  return 1;
}
     8ba:	08 95       	ret

000008bc <datacute_write_wire(unsigned char)>:
datacute_write_wire():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED_Wire.h:18

#ifndef DATACUTE_I2C_WIRE
#define DATACUTE_I2C_WIRE

static bool datacute_write_wire(uint8_t byte) {
	return Wire.write(byte);
     8bc:	68 2f       	mov	r22, r24
     8be:	8e e6       	ldi	r24, 0x6E	; 110
     8c0:	98 e3       	ldi	r25, 0x38	; 56
     8c2:	0e 94 43 04 	call	0x886	; 0x886 <TwoWire::write(unsigned char)>
     8c6:	21 e0       	ldi	r18, 0x01	; 1
     8c8:	89 2b       	or	r24, r25
     8ca:	09 f4       	brne	.+2      	; 0x8ce <datacute_write_wire(unsigned char)+0x12>
     8cc:	20 e0       	ldi	r18, 0x00	; 0
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED_Wire.h:19
}
     8ce:	82 2f       	mov	r24, r18
     8d0:	08 95       	ret

000008d2 <ssd1306_send_stop()>:
ssd1306_send_stop():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:47
static bool ssd1306_send_byte(uint8_t byte) {
	return wireWriteFn(byte);
}

static void ssd1306_send_stop(void) {
	wireEndTransmissionFn();
     8d2:	e0 91 7a 38 	lds	r30, 0x387A	; 0x80387a <wireEndTransmissionFn>
     8d6:	f0 91 7b 38 	lds	r31, 0x387B	; 0x80387b <wireEndTransmissionFn+0x1>
     8da:	09 94       	ijmp

000008dc <ssd1306_send_byte(unsigned char)>:
ssd1306_send_byte():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:43
static void ssd1306_send_start(void) {
	wireBeginTransmissionFn();
}

static bool ssd1306_send_byte(uint8_t byte) {
	return wireWriteFn(byte);
     8dc:	e0 91 7c 38 	lds	r30, 0x387C	; 0x80387c <wireWriteFn>
     8e0:	f0 91 7d 38 	lds	r31, 0x387D	; 0x80387d <wireWriteFn+0x1>
     8e4:	09 94       	ijmp

000008e6 <ssd1306_send_start()>:
ssd1306_send_start():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:39
static void ssd1306_begin(void) {
	wireBeginFn();
}

static void ssd1306_send_start(void) {
	wireBeginTransmissionFn();
     8e6:	e0 91 7e 38 	lds	r30, 0x387E	; 0x80387e <wireBeginTransmissionFn>
     8ea:	f0 91 7f 38 	lds	r31, 0x387F	; 0x80387f <wireBeginTransmissionFn+0x1>
     8ee:	09 94       	ijmp

000008f0 <ssd1306_send_data_byte(unsigned char)>:
ssd1306_send_data_byte():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:68
		ssd1306_send_command_start();
		ssd1306_send_byte(byte);
	}
}

static void ssd1306_send_data_byte(uint8_t byte) {
     8f0:	cf 93       	push	r28
     8f2:	c8 2f       	mov	r28, r24
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:69
	if (ssd1306_send_byte(byte^invertedOutput) == 0) {
     8f4:	0e 94 6e 04 	call	0x8dc	; 0x8dc <ssd1306_send_byte(unsigned char)>
     8f8:	81 11       	cpse	r24, r1
     8fa:	0b c0       	rjmp	.+22     	; 0x912 <ssd1306_send_data_byte(unsigned char)+0x22>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:70
		ssd1306_send_stop();
     8fc:	0e 94 69 04 	call	0x8d2	; 0x8d2 <ssd1306_send_stop()>
ssd1306_send_data_start():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:56
	ssd1306_send_start();
	ssd1306_send_byte(SSD1306_COMMAND);
}

static void ssd1306_send_data_start(void) {
	ssd1306_send_start();
     900:	0e 94 73 04 	call	0x8e6	; 0x8e6 <ssd1306_send_start()>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:57
	ssd1306_send_byte(SSD1306_DATA);
     904:	80 e4       	ldi	r24, 0x40	; 64
     906:	0e 94 6e 04 	call	0x8dc	; 0x8dc <ssd1306_send_byte(unsigned char)>
ssd1306_send_data_byte():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:72

static void ssd1306_send_data_byte(uint8_t byte) {
	if (ssd1306_send_byte(byte^invertedOutput) == 0) {
		ssd1306_send_stop();
		ssd1306_send_data_start();
		ssd1306_send_byte(byte^invertedOutput);
     90a:	8c 2f       	mov	r24, r28
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:74
	}
}
     90c:	cf 91       	pop	r28
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:72

static void ssd1306_send_data_byte(uint8_t byte) {
	if (ssd1306_send_byte(byte^invertedOutput) == 0) {
		ssd1306_send_stop();
		ssd1306_send_data_start();
		ssd1306_send_byte(byte^invertedOutput);
     90e:	0c 94 6e 04 	jmp	0x8dc	; 0x8dc <ssd1306_send_byte(unsigned char)>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:74
	}
}
     912:	cf 91       	pop	r28
     914:	08 95       	ret

00000916 <ssd1306_send_command_start()>:
ssd1306_send_command_start():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:51
static void ssd1306_send_stop(void) {
	wireEndTransmissionFn();
}

static void ssd1306_send_command_start(void) {
	ssd1306_send_start();
     916:	0e 94 73 04 	call	0x8e6	; 0x8e6 <ssd1306_send_start()>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:52
	ssd1306_send_byte(SSD1306_COMMAND);
     91a:	80 e0       	ldi	r24, 0x00	; 0
     91c:	0c 94 6e 04 	jmp	0x8dc	; 0x8dc <ssd1306_send_byte(unsigned char)>

00000920 <SSD1306Device::setCursor(unsigned char, unsigned char) [clone .constprop.31]>:
setCursor():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:183

void SSD1306Device::setFont(const DCfont *font) {
	oledFont = font;
}

void SSD1306Device::setCursor(uint8_t x, uint8_t y) {
     920:	1f 93       	push	r17
     922:	cf 93       	push	r28
     924:	df 93       	push	r29
     926:	c8 2f       	mov	r28, r24
     928:	16 2f       	mov	r17, r22
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:184
	ssd1306_send_command3(renderingFrame | ((y + oledOffsetY) & 0x07), 0x10 | (((x + oledOffsetX) & 0xf0) >> 4), (x + oledOffsetX) & 0x0f);
     92a:	d6 2f       	mov	r29, r22
     92c:	d7 70       	andi	r29, 0x07	; 7
     92e:	80 91 07 38 	lds	r24, 0x3807	; 0x803807 <renderingFrame>
     932:	d8 2b       	or	r29, r24
ssd1306_send_command3():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:90
	ssd1306_send_byte(command2);
	ssd1306_send_stop();
}

static void ssd1306_send_command3(uint8_t command1, uint8_t command2, uint8_t command3) {
	ssd1306_send_command_start();
     934:	0e 94 8b 04 	call	0x916	; 0x916 <ssd1306_send_command_start()>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:91
	ssd1306_send_byte(command1);
     938:	8d 2f       	mov	r24, r29
     93a:	0e 94 6e 04 	call	0x8dc	; 0x8dc <ssd1306_send_byte(unsigned char)>
setCursor():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:184
void SSD1306Device::setFont(const DCfont *font) {
	oledFont = font;
}

void SSD1306Device::setCursor(uint8_t x, uint8_t y) {
	ssd1306_send_command3(renderingFrame | ((y + oledOffsetY) & 0x07), 0x10 | (((x + oledOffsetX) & 0xf0) >> 4), (x + oledOffsetX) & 0x0f);
     93e:	8c 2f       	mov	r24, r28
     940:	82 95       	swap	r24
     942:	8f 70       	andi	r24, 0x0F	; 15
ssd1306_send_command3():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:92
}

static void ssd1306_send_command3(uint8_t command1, uint8_t command2, uint8_t command3) {
	ssd1306_send_command_start();
	ssd1306_send_byte(command1);
	ssd1306_send_byte(command2);
     944:	80 61       	ori	r24, 0x10	; 16
     946:	0e 94 6e 04 	call	0x8dc	; 0x8dc <ssd1306_send_byte(unsigned char)>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:93
	ssd1306_send_byte(command3);
     94a:	8c 2f       	mov	r24, r28
     94c:	8f 70       	andi	r24, 0x0F	; 15
     94e:	0e 94 6e 04 	call	0x8dc	; 0x8dc <ssd1306_send_byte(unsigned char)>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:94
	ssd1306_send_stop();
     952:	0e 94 69 04 	call	0x8d2	; 0x8d2 <ssd1306_send_stop()>
setCursor():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:185
	oledFont = font;
}

void SSD1306Device::setCursor(uint8_t x, uint8_t y) {
	ssd1306_send_command3(renderingFrame | ((y + oledOffsetY) & 0x07), 0x10 | (((x + oledOffsetX) & 0xf0) >> 4), (x + oledOffsetX) & 0x0f);
	oledX = x;
     956:	c0 93 6d 38 	sts	0x386D, r28	; 0x80386d <oledX>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:186
	oledY = y;
     95a:	10 93 6c 38 	sts	0x386C, r17	; 0x80386c <oledY>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:187
}
     95e:	df 91       	pop	r29
     960:	cf 91       	pop	r28
     962:	1f 91       	pop	r17
     964:	08 95       	ret

00000966 <SSD1306Device::fill(unsigned char) [clone .constprop.18]>:
fill():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:193

void SSD1306Device::clear(void) {
	fill(0x00);
}

void SSD1306Device::fill(uint8_t fill) {
     966:	0f 93       	push	r16
     968:	1f 93       	push	r17
     96a:	cf 93       	push	r28
     96c:	df 93       	push	r29
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:194
	for (uint8_t m = 0; m < oledPages; m++) {
     96e:	c0 e0       	ldi	r28, 0x00	; 0
fillToEOL():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:276
void SSD1306Device::clearToEOL(void) {
	fillToEOL(0x00);
}

void SSD1306Device::fillToEOL(uint8_t fill) {
	fillLength(fill, oledWidth - oledX);
     970:	10 e8       	ldi	r17, 0x80	; 128
fill():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:195
	fill(0x00);
}

void SSD1306Device::fill(uint8_t fill) {
	for (uint8_t m = 0; m < oledPages; m++) {
		setCursor(0, m);
     972:	6c 2f       	mov	r22, r28
     974:	80 e0       	ldi	r24, 0x00	; 0
     976:	0e 94 90 04 	call	0x920	; 0x920 <SSD1306Device::setCursor(unsigned char, unsigned char) [clone .constprop.31]>
fillToEOL():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:276
void SSD1306Device::clearToEOL(void) {
	fillToEOL(0x00);
}

void SSD1306Device::fillToEOL(uint8_t fill) {
	fillLength(fill, oledWidth - oledX);
     97a:	80 91 6d 38 	lds	r24, 0x386D	; 0x80386d <oledX>
     97e:	01 2f       	mov	r16, r17
     980:	08 1b       	sub	r16, r24
fillLength():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:280
}

void SSD1306Device::fillLength(uint8_t fill, uint8_t length) {
	if (length == 0) return;
     982:	81 f0       	breq	.+32     	; 0x9a4 <SSD1306Device::fill(unsigned char) [clone .constprop.18]+0x3e>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:281
	oledX += length;
     984:	10 93 6d 38 	sts	0x386D, r17	; 0x80386d <oledX>
ssd1306_send_data_start():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:56
	ssd1306_send_start();
	ssd1306_send_byte(SSD1306_COMMAND);
}

static void ssd1306_send_data_start(void) {
	ssd1306_send_start();
     988:	0e 94 73 04 	call	0x8e6	; 0x8e6 <ssd1306_send_start()>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:57
	ssd1306_send_byte(SSD1306_DATA);
     98c:	80 e4       	ldi	r24, 0x40	; 64
     98e:	0e 94 6e 04 	call	0x8dc	; 0x8dc <ssd1306_send_byte(unsigned char)>
fill():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:296
void SSD1306Device::sendData(const uint8_t data) {
	ssd1306_send_data_byte(data);
}

void SSD1306Device::repeatData(uint8_t data, uint8_t length) {
	for (uint8_t x = 0; x < length; x++) {
     992:	d0 e0       	ldi	r29, 0x00	; 0
repeatData():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:297
		ssd1306_send_data_byte(data);
     994:	80 e0       	ldi	r24, 0x00	; 0
     996:	0e 94 78 04 	call	0x8f0	; 0x8f0 <ssd1306_send_data_byte(unsigned char)>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:296
void SSD1306Device::sendData(const uint8_t data) {
	ssd1306_send_data_byte(data);
}

void SSD1306Device::repeatData(uint8_t data, uint8_t length) {
	for (uint8_t x = 0; x < length; x++) {
     99a:	df 5f       	subi	r29, 0xFF	; 255
     99c:	0d 13       	cpse	r16, r29
     99e:	fa cf       	rjmp	.-12     	; 0x994 <SSD1306Device::fill(unsigned char) [clone .constprop.18]+0x2e>
fillLength():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:284
void SSD1306Device::fillLength(uint8_t fill, uint8_t length) {
	if (length == 0) return;
	oledX += length;
	ssd1306_send_data_start();
	repeatData(fill, length);
	ssd1306_send_stop();
     9a0:	0e 94 69 04 	call	0x8d2	; 0x8d2 <ssd1306_send_stop()>
fill():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:194
void SSD1306Device::clear(void) {
	fill(0x00);
}

void SSD1306Device::fill(uint8_t fill) {
	for (uint8_t m = 0; m < oledPages; m++) {
     9a4:	cf 5f       	subi	r28, 0xFF	; 255
     9a6:	c4 30       	cpi	r28, 0x04	; 4
     9a8:	21 f7       	brne	.-56     	; 0x972 <SSD1306Device::fill(unsigned char) [clone .constprop.18]+0xc>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:198
		setCursor(0, m);
		fillToEOL(fill);
	}
	setCursor(0, 0);
     9aa:	60 e0       	ldi	r22, 0x00	; 0
     9ac:	80 e0       	ldi	r24, 0x00	; 0
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:199
}
     9ae:	df 91       	pop	r29
     9b0:	cf 91       	pop	r28
     9b2:	1f 91       	pop	r17
     9b4:	0f 91       	pop	r16
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:198
void SSD1306Device::fill(uint8_t fill) {
	for (uint8_t m = 0; m < oledPages; m++) {
		setCursor(0, m);
		fillToEOL(fill);
	}
	setCursor(0, 0);
     9b6:	0c 94 90 04 	jmp	0x920	; 0x920 <SSD1306Device::setCursor(unsigned char, unsigned char) [clone .constprop.31]>

000009ba <SSD1306Device::newLine(unsigned char)>:
newLine():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:202
}

void SSD1306Device::newLine(uint8_t fontHeight) {
	oledY+=fontHeight;
     9ba:	80 91 6c 38 	lds	r24, 0x386C	; 0x80386c <oledY>
     9be:	86 0f       	add	r24, r22
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:203
	if (oledY > oledPages - fontHeight) {
     9c0:	24 e0       	ldi	r18, 0x04	; 4
     9c2:	30 e0       	ldi	r19, 0x00	; 0
     9c4:	26 1b       	sub	r18, r22
     9c6:	31 09       	sbc	r19, r1
     9c8:	82 17       	cp	r24, r18
     9ca:	13 06       	cpc	r1, r19
     9cc:	09 f0       	breq	.+2      	; 0x9d0 <SSD1306Device::newLine(unsigned char)+0x16>
     9ce:	3c f4       	brge	.+14     	; 0x9de <SSD1306Device::newLine(unsigned char)+0x24>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:204
		oledY = oledPages - fontHeight;
     9d0:	80 93 6c 38 	sts	0x386C, r24	; 0x80386c <oledY>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:206
	}
	setCursor(0, oledY);
     9d4:	60 91 6c 38 	lds	r22, 0x386C	; 0x80386c <oledY>
     9d8:	80 e0       	ldi	r24, 0x00	; 0
     9da:	0c 94 90 04 	jmp	0x920	; 0x920 <SSD1306Device::setCursor(unsigned char, unsigned char) [clone .constprop.31]>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:204
}

void SSD1306Device::newLine(uint8_t fontHeight) {
	oledY+=fontHeight;
	if (oledY > oledPages - fontHeight) {
		oledY = oledPages - fontHeight;
     9de:	84 e0       	ldi	r24, 0x04	; 4
     9e0:	86 1b       	sub	r24, r22
     9e2:	f6 cf       	rjmp	.-20     	; 0x9d0 <SSD1306Device::newLine(unsigned char)+0x16>

000009e4 <SSD1306Device::write(unsigned char)>:
write():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:213

void SSD1306Device::newLine(void) {
	newLine(oledFont->height);
}

size_t SSD1306Device::write(byte c) {
     9e4:	bf 92       	push	r11
     9e6:	cf 92       	push	r12
     9e8:	df 92       	push	r13
     9ea:	ef 92       	push	r14
     9ec:	ff 92       	push	r15
     9ee:	0f 93       	push	r16
     9f0:	1f 93       	push	r17
     9f2:	cf 93       	push	r28
     9f4:	df 93       	push	r29
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:214
	if (!oledFont)
     9f6:	e0 91 52 38 	lds	r30, 0x3852	; 0x803852 <oledFont>
     9fa:	f0 91 53 38 	lds	r31, 0x3853	; 0x803853 <oledFont+0x1>
     9fe:	30 97       	sbiw	r30, 0x00	; 0
     a00:	49 f0       	breq	.+18     	; 0xa14 <SSD1306Device::write(unsigned char)+0x30>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:217
		return 1;

	if (c == '\r')
     a02:	6d 30       	cpi	r22, 0x0D	; 13
     a04:	39 f0       	breq	.+14     	; 0xa14 <SSD1306Device::write(unsigned char)+0x30>
     a06:	16 2f       	mov	r17, r22
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:220
		return 1;
	
	uint8_t h = oledFont->height;
     a08:	c3 81       	ldd	r28, Z+3	; 0x03
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:222

	if (c == '\n') {
     a0a:	6a 30       	cpi	r22, 0x0A	; 10
     a0c:	79 f4       	brne	.+30     	; 0xa2c <SSD1306Device::write(unsigned char)+0x48>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:223
		newLine(h);
     a0e:	6c 2f       	mov	r22, r28
     a10:	0e 94 dd 04 	call	0x9ba	; 0x9ba <SSD1306Device::newLine(unsigned char)>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:256
			}
		}
	}
	while (--line);
	return 1;
}
     a14:	81 e0       	ldi	r24, 0x01	; 1
     a16:	90 e0       	ldi	r25, 0x00	; 0
     a18:	df 91       	pop	r29
     a1a:	cf 91       	pop	r28
     a1c:	1f 91       	pop	r17
     a1e:	0f 91       	pop	r16
     a20:	ff 90       	pop	r15
     a22:	ef 90       	pop	r14
     a24:	df 90       	pop	r13
     a26:	cf 90       	pop	r12
     a28:	bf 90       	pop	r11
     a2a:	08 95       	ret
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:227
	if (c == '\n') {
		newLine(h);
		return 1;
	}

	uint8_t w = oledFont->width;
     a2c:	d2 81       	ldd	r29, Z+2	; 0x02
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:229

	if (oledX > ((uint8_t)oledWidth - w)) {
     a2e:	40 91 6d 38 	lds	r20, 0x386D	; 0x80386d <oledX>
     a32:	ed 2e       	mov	r14, r29
     a34:	f1 2c       	mov	r15, r1
     a36:	20 e8       	ldi	r18, 0x80	; 128
     a38:	30 e0       	ldi	r19, 0x00	; 0
     a3a:	2e 19       	sub	r18, r14
     a3c:	3f 09       	sbc	r19, r15
     a3e:	42 17       	cp	r20, r18
     a40:	13 06       	cpc	r1, r19
     a42:	21 f0       	breq	.+8      	; 0xa4c <SSD1306Device::write(unsigned char)+0x68>
     a44:	1c f0       	brlt	.+6      	; 0xa4c <SSD1306Device::write(unsigned char)+0x68>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:230
		newLine(h);
     a46:	6c 2f       	mov	r22, r28
     a48:	0e 94 dd 04 	call	0x9ba	; 0x9ba <SSD1306Device::newLine(unsigned char)>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:233
	}

	uint16_t offset = ((uint16_t)c - oledFont->first) * w * h;
     a4c:	e0 91 52 38 	lds	r30, 0x3852	; 0x803852 <oledFont>
     a50:	f0 91 53 38 	lds	r31, 0x3853	; 0x803853 <oledFont+0x1>
     a54:	84 81       	ldd	r24, Z+4	; 0x04
     a56:	21 2f       	mov	r18, r17
     a58:	28 1b       	sub	r18, r24
     a5a:	33 0b       	sbc	r19, r19
     a5c:	dc 9f       	mul	r29, r28
     a5e:	c0 01       	movw	r24, r0
     a60:	11 24       	eor	r1, r1
     a62:	28 9f       	mul	r18, r24
     a64:	80 01       	movw	r16, r0
     a66:	29 9f       	mul	r18, r25
     a68:	10 0d       	add	r17, r0
     a6a:	38 9f       	mul	r19, r24
     a6c:	10 0d       	add	r17, r0
     a6e:	11 24       	eor	r1, r1
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:220
		return 1;

	if (c == '\r')
		return 1;
	
	uint8_t h = oledFont->height;
     a70:	bc 2e       	mov	r11, r28
ssd1306_send_data_start():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:56
	ssd1306_send_start();
	ssd1306_send_byte(SSD1306_COMMAND);
}

static void ssd1306_send_data_start(void) {
	ssd1306_send_start();
     a72:	0e 94 73 04 	call	0x8e6	; 0x8e6 <ssd1306_send_start()>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:57
	ssd1306_send_byte(SSD1306_DATA);
     a76:	80 e4       	ldi	r24, 0x40	; 64
     a78:	0e 94 6e 04 	call	0x8dc	; 0x8dc <ssd1306_send_byte(unsigned char)>
     a7c:	c8 01       	movw	r24, r16
write():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:238
	uint16_t offset = ((uint16_t)c - oledFont->first) * w * h;
	uint8_t line = h;
	do
	{
		ssd1306_send_data_start();
		for (uint8_t i = 0; i < w; i++) {
     a7e:	28 2f       	mov	r18, r24
     a80:	20 1b       	sub	r18, r16
     a82:	2d 17       	cp	r18, r29
     a84:	90 f4       	brcc	.+36     	; 0xaaa <SSD1306Device::write(unsigned char)+0xc6>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:239
			ssd1306_send_data_byte(pgm_read_byte(&(oledFont->bitmap[offset++])));
     a86:	6c 01       	movw	r12, r24
     a88:	3f ef       	ldi	r19, 0xFF	; 255
     a8a:	c3 1a       	sub	r12, r19
     a8c:	d3 0a       	sbc	r13, r19
     a8e:	e0 91 52 38 	lds	r30, 0x3852	; 0x803852 <oledFont>
     a92:	f0 91 53 38 	lds	r31, 0x3853	; 0x803853 <oledFont+0x1>
     a96:	01 90       	ld	r0, Z+
     a98:	f0 81       	ld	r31, Z
     a9a:	e0 2d       	mov	r30, r0
     a9c:	e8 0f       	add	r30, r24
     a9e:	f9 1f       	adc	r31, r25
     aa0:	84 91       	lpm	r24, Z
     aa2:	0e 94 78 04 	call	0x8f0	; 0x8f0 <ssd1306_send_data_byte(unsigned char)>
     aa6:	c6 01       	movw	r24, r12
     aa8:	ea cf       	rjmp	.-44     	; 0xa7e <SSD1306Device::write(unsigned char)+0x9a>
     aaa:	0e 0d       	add	r16, r14
     aac:	1f 1d       	adc	r17, r15
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:241
		}
		ssd1306_send_stop();
     aae:	0e 94 69 04 	call	0x8d2	; 0x8d2 <ssd1306_send_stop()>
     ab2:	80 91 6d 38 	lds	r24, 0x386D	; 0x80386d <oledX>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:242
		if (h == 1) {
     ab6:	c1 30       	cpi	r28, 0x01	; 1
     ab8:	39 f4       	brne	.+14     	; 0xac8 <SSD1306Device::write(unsigned char)+0xe4>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:243
			oledX+=w;
     aba:	8d 0f       	add	r24, r29
     abc:	80 93 6d 38 	sts	0x386D, r24	; 0x80386d <oledX>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:254
			else {
				setCursor(oledX + w, oledY - (h - 1));
			}
		}
	}
	while (--line);
     ac0:	ba 94       	dec	r11
     ac2:	b1 10       	cpse	r11, r1
     ac4:	d6 cf       	rjmp	.-84     	; 0xa72 <SSD1306Device::write(unsigned char)+0x8e>
     ac6:	a6 cf       	rjmp	.-180    	; 0xa14 <SSD1306Device::write(unsigned char)+0x30>
     ac8:	60 91 6c 38 	lds	r22, 0x386C	; 0x80386c <oledY>
     acc:	6f 5f       	subi	r22, 0xFF	; 255
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:246
		ssd1306_send_stop();
		if (h == 1) {
			oledX+=w;
		}
		else {
			if (line > 1) {
     ace:	91 e0       	ldi	r25, 0x01	; 1
     ad0:	9b 15       	cp	r25, r11
     ad2:	18 f4       	brcc	.+6      	; 0xada <SSD1306Device::write(unsigned char)+0xf6>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:250
				setCursor(oledX, oledY + 1);
			}
			else {
				setCursor(oledX + w, oledY - (h - 1));
     ad4:	0e 94 90 04 	call	0x920	; 0x920 <SSD1306Device::setCursor(unsigned char, unsigned char) [clone .constprop.31]>
     ad8:	f3 cf       	rjmp	.-26     	; 0xac0 <SSD1306Device::write(unsigned char)+0xdc>
     ada:	6c 1b       	sub	r22, r28
     adc:	8d 0f       	add	r24, r29
     ade:	fa cf       	rjmp	.-12     	; 0xad4 <SSD1306Device::write(unsigned char)+0xf0>

00000ae0 <tiny4koled_beginTransmission_wire()>:
beginTransmission():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:256

void TwoWire::beginTransmission(uint8_t address) {
  // indicate that we are transmitting
  transmitting = 1;
  // set address of targeted slave
  txAddress = address;
     ae0:	8c e3       	ldi	r24, 0x3C	; 60
     ae2:	80 93 09 38 	sts	0x3809, r24	; 0x803809 <TwoWire::txAddress>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:258
  // reset tx buffer iterator vars
  txBufferIndex = 0;
     ae6:	10 92 32 38 	sts	0x3832, r1	; 0x803832 <TwoWire::txBufferIndex>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:259
  txBufferLength = 0;
     aea:	10 92 33 38 	sts	0x3833, r1	; 0x803833 <TwoWire::txBufferLength>
tiny4koled_beginTransmission_wire():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED_Wire.h:38
#endif

static bool tiny4koled_beginTransmission_wire(void) {
	Wire.beginTransmission(SSD1306);
	return true;
}
     aee:	81 e0       	ldi	r24, 0x01	; 1
     af0:	08 95       	ret

00000af2 <datacute_endTransmission_wire()>:
TWI_MasterWriteRead():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:325
uint8_t TWI_MasterWriteRead(uint8_t slave_address,
                            uint8_t *write_data,
                            uint8_t bytes_to_write,
                            uint8_t bytes_to_read,
                            uint8_t send_stop) {
  if (twi_mode != TWI_MODE_MASTER) {
     af2:	90 91 40 38 	lds	r25, 0x3840	; 0x803840 <twi_mode>
     af6:	91 30       	cpi	r25, 0x01	; 1
     af8:	09 f0       	breq	.+2      	; 0xafc <datacute_endTransmission_wire()+0xa>
     afa:	5a c0       	rjmp	.+180    	; 0xbb0 <datacute_endTransmission_wire()+0xbe>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:330
    return false;
  }

  /*Initiate transaction if bus is ready. */
  if (master_trans_status == TWIM_STATUS_READY) {
     afc:	80 91 41 38 	lds	r24, 0x3841	; 0x803841 <master_trans_status>
     b00:	81 11       	cpse	r24, r1
     b02:	5c c0       	rjmp	.+184    	; 0xbbc <datacute_endTransmission_wire()+0xca>
endTransmission():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:281
//  no call to endTransmission(true) is made. Some I2C
//  devices will behave oddly if they do not see a STOP.
//
uint8_t TwoWire::endTransmission(bool sendStop) {
  // transmit buffer (blocking)
  uint8_t status = TWI_MasterWrite(txAddress, txBuffer, txBufferLength, sendStop);
     b04:	20 91 33 38 	lds	r18, 0x3833	; 0x803833 <TwoWire::txBufferLength>
     b08:	80 91 09 38 	lds	r24, 0x3809	; 0x803809 <TwoWire::txAddress>
TWI_MasterWriteRead():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:332

    master_trans_status = TWIM_STATUS_BUSY;
     b0c:	90 93 41 38 	sts	0x3841, r25	; 0x803841 <master_trans_status>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:333
    master_result = TWIM_RESULT_UNKNOWN;
     b10:	10 92 42 38 	sts	0x3842, r1	; 0x803842 <master_result>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:335

    master_writeData = write_data;
     b14:	42 e1       	ldi	r20, 0x12	; 18
     b16:	58 e3       	ldi	r21, 0x38	; 56
     b18:	40 93 39 38 	sts	0x3839, r20	; 0x803839 <master_writeData>
     b1c:	50 93 3a 38 	sts	0x383A, r21	; 0x80383a <master_writeData+0x1>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:337

    master_bytesToWrite = bytes_to_write;
     b20:	20 93 3c 38 	sts	0x383C, r18	; 0x80383c <master_bytesToWrite>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:338
    master_bytesToRead = bytes_to_read;
     b24:	10 92 3e 38 	sts	0x383E, r1	; 0x80383e <master_bytesToRead>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:339
    master_bytesWritten = 0;
     b28:	10 92 3b 38 	sts	0x383B, r1	; 0x80383b <master_bytesWritten>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:340
    master_bytesRead = 0;
     b2c:	10 92 3f 38 	sts	0x383F, r1	; 0x80383f <master_bytesRead>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:341
    master_sendStop = send_stop;
     b30:	90 93 3d 38 	sts	0x383D, r25	; 0x80383d <master_sendStop>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:342
    master_slaveAddress = slave_address << 1;
     b34:	88 0f       	add	r24, r24
     b36:	80 93 38 38 	sts	0x3838, r24	; 0x803838 <master_slaveAddress>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:365
      uint8_t readAddress = ADD_READ_BIT(master_slaveAddress);
      TWI0.MADDR = readAddress;
    }

    else if (master_bytesToWrite == 0 && master_bytesToRead == 0) {
      twi_mode = TWI_MODE_MASTER_TRANSMIT;
     b3a:	93 e0       	ldi	r25, 0x03	; 3
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:359

    /* If read command, send the START condition + Address +
       'R/_W = 1'
    */
    else if (master_bytesToRead > 0) {
      twi_mode = TWI_MODE_MASTER_RECEIVE;
     b3c:	24 e0       	ldi	r18, 0x04	; 4
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:349
  trigger_action:

    /* If write command, send the START condition + Address +
       'R/_W = 0'
    */
    if (master_bytesToWrite > 0) {
     b3e:	80 91 3c 38 	lds	r24, 0x383C	; 0x80383c <master_bytesToWrite>
     b42:	88 23       	and	r24, r24
     b44:	31 f0       	breq	.+12     	; 0xb52 <datacute_endTransmission_wire()+0x60>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:365
      uint8_t readAddress = ADD_READ_BIT(master_slaveAddress);
      TWI0.MADDR = readAddress;
    }

    else if (master_bytesToWrite == 0 && master_bytesToRead == 0) {
      twi_mode = TWI_MODE_MASTER_TRANSMIT;
     b46:	90 93 40 38 	sts	0x3840, r25	; 0x803840 <twi_mode>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:366
      uint8_t writeAddress = ADD_WRITE_BIT(master_slaveAddress);
     b4a:	80 91 38 38 	lds	r24, 0x3838	; 0x803838 <master_slaveAddress>
     b4e:	8e 7f       	andi	r24, 0xFE	; 254
     b50:	09 c0       	rjmp	.+18     	; 0xb64 <datacute_endTransmission_wire()+0x72>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:358
    }

    /* If read command, send the START condition + Address +
       'R/_W = 1'
    */
    else if (master_bytesToRead > 0) {
     b52:	80 91 3e 38 	lds	r24, 0x383E	; 0x80383e <master_bytesToRead>
     b56:	88 23       	and	r24, r24
     b58:	41 f0       	breq	.+16     	; 0xb6a <datacute_endTransmission_wire()+0x78>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:359
      twi_mode = TWI_MODE_MASTER_RECEIVE;
     b5a:	20 93 40 38 	sts	0x3840, r18	; 0x803840 <twi_mode>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:360
      uint8_t readAddress = ADD_READ_BIT(master_slaveAddress);
     b5e:	80 91 38 38 	lds	r24, 0x3838	; 0x803838 <master_slaveAddress>
     b62:	81 60       	ori	r24, 0x01	; 1
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:367
    }

    else if (master_bytesToWrite == 0 && master_bytesToRead == 0) {
      twi_mode = TWI_MODE_MASTER_TRANSMIT;
      uint8_t writeAddress = ADD_WRITE_BIT(master_slaveAddress);
      TWI0.MADDR = writeAddress;
     b64:	80 93 17 08 	sts	0x0817, r24	; 0x800817 <vtable for SSD1306Device+0x7f6ed3>
     b68:	08 c0       	rjmp	.+16     	; 0xb7a <datacute_endTransmission_wire()+0x88>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:364
      twi_mode = TWI_MODE_MASTER_RECEIVE;
      uint8_t readAddress = ADD_READ_BIT(master_slaveAddress);
      TWI0.MADDR = readAddress;
    }

    else if (master_bytesToWrite == 0 && master_bytesToRead == 0) {
     b6a:	80 91 3c 38 	lds	r24, 0x383C	; 0x80383c <master_bytesToWrite>
     b6e:	81 11       	cpse	r24, r1
     b70:	04 c0       	rjmp	.+8      	; 0xb7a <datacute_endTransmission_wire()+0x88>
     b72:	80 91 3e 38 	lds	r24, 0x383E	; 0x80383e <master_bytesToRead>
     b76:	88 23       	and	r24, r24
     b78:	31 f3       	breq	.-52     	; 0xb46 <datacute_endTransmission_wire()+0x54>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:371
      uint8_t writeAddress = ADD_WRITE_BIT(master_slaveAddress);
      TWI0.MADDR = writeAddress;
    }

    /* Arduino requires blocking function */
    while (master_result == TWIM_RESULT_UNKNOWN) {}
     b7a:	80 91 42 38 	lds	r24, 0x3842	; 0x803842 <master_result>
     b7e:	88 23       	and	r24, r24
     b80:	e1 f3       	breq	.-8      	; 0xb7a <datacute_endTransmission_wire()+0x88>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:374

    // in case of arbitration lost, retry sending
    if (master_result == TWIM_RESULT_ARBITRATION_LOST) {
     b82:	80 91 42 38 	lds	r24, 0x3842	; 0x803842 <master_result>
     b86:	83 30       	cpi	r24, 0x03	; 3
     b88:	d1 f2       	breq	.-76     	; 0xb3e <datacute_endTransmission_wire()+0x4c>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:379
      goto trigger_action;
    }

    uint8_t ret = 0;
    if (master_bytesToRead > 0) {
     b8a:	80 91 3e 38 	lds	r24, 0x383E	; 0x80383e <master_bytesToRead>
     b8e:	88 23       	and	r24, r24
     b90:	39 f0       	breq	.+14     	; 0xba0 <datacute_endTransmission_wire()+0xae>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:381
      // return bytes really read
      ret = master_bytesRead;
     b92:	80 91 3f 38 	lds	r24, 0x383F	; 0x80383f <master_bytesRead>
endTransmission():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:284

  // reset tx buffer iterator vars
  txBufferIndex = 0;
     b96:	10 92 32 38 	sts	0x3832, r1	; 0x803832 <TwoWire::txBufferIndex>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:285
  txBufferLength = 0;
     b9a:	10 92 33 38 	sts	0x3833, r1	; 0x803833 <TwoWire::txBufferLength>
datacute_endTransmission_wire():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED_Wire.h:31
static void datacute_end_read_wire(void) __attribute__((unused));
static void datacute_end_read_wire(void) {}

static uint8_t datacute_endTransmission_wire(void) {
	return Wire.endTransmission();
}
     b9e:	08 95       	ret
TWI_MasterWriteRead():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:384
    } else {
      // return 0 if success, >0 otherwise (follow classic AVR conventions)
      switch (master_result) {
     ba0:	80 91 42 38 	lds	r24, 0x3842	; 0x803842 <master_result>
     ba4:	82 30       	cpi	r24, 0x02	; 2
     ba6:	51 f0       	breq	.+20     	; 0xbbc <datacute_endTransmission_wire()+0xca>
     ba8:	85 30       	cpi	r24, 0x05	; 5
     baa:	21 f0       	breq	.+8      	; 0xbb4 <datacute_endTransmission_wire()+0xc2>
     bac:	81 30       	cpi	r24, 0x01	; 1
     bae:	21 f4       	brne	.+8      	; 0xbb8 <datacute_endTransmission_wire()+0xc6>
datacute_endTransmission_wire():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:386
        case TWIM_RESULT_OK:
          ret = 0;
     bb0:	80 e0       	ldi	r24, 0x00	; 0
     bb2:	f1 cf       	rjmp	.-30     	; 0xb96 <datacute_endTransmission_wire()+0xa4>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:392
          break;
        case TWIM_RESULT_BUFFER_OVERFLOW:
          ret = 1;
          break;
        case TWIM_RESULT_NACK_RECEIVED:
          ret = 3;
     bb4:	83 e0       	ldi	r24, 0x03	; 3
     bb6:	ef cf       	rjmp	.-34     	; 0xb96 <datacute_endTransmission_wire()+0xa4>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:395
          break;
        default:
          ret = 4;
     bb8:	84 e0       	ldi	r24, 0x04	; 4
     bba:	ed cf       	rjmp	.-38     	; 0xb96 <datacute_endTransmission_wire()+0xa4>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:402
      }
    }

    return ret;
  } else {
    return 1;
     bbc:	81 e0       	ldi	r24, 0x01	; 1
     bbe:	eb cf       	rjmp	.-42     	; 0xb96 <datacute_endTransmission_wire()+0xa4>

00000bc0 <tiny4koled_begin_wire()>:
tiny4koled_begin_wire():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED_Wire.h:48
	tiny4koled_beginTransmission_wire();
	return (datacute_endTransmission_wire()==noError);
}
#endif

static void tiny4koled_begin_wire(void) {
     bc0:	cf 92       	push	r12
     bc2:	df 92       	push	r13
     bc4:	ef 92       	push	r14
     bc6:	ff 92       	push	r15
begin():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:169
    #endif
  #endif
}

void TwoWire::begin(void) {
  rxBufferIndex = 0;
     bc8:	10 92 35 38 	sts	0x3835, r1	; 0x803835 <TwoWire::rxBufferIndex>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:170
  rxBufferLength = 0;
     bcc:	10 92 34 38 	sts	0x3834, r1	; 0x803834 <TwoWire::rxBufferLength>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:172

  txBufferIndex = 0;
     bd0:	10 92 32 38 	sts	0x3832, r1	; 0x803832 <TwoWire::txBufferIndex>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:173
  txBufferLength = 0;
     bd4:	10 92 33 38 	sts	0x3833, r1	; 0x803833 <TwoWire::txBufferLength>
TWI_MasterInit():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:64
    Remember to enable interrupts globally from the main application.

    \param frequency            The required baud.
*/
void TWI_MasterInit(uint32_t frequency) {
  if (twi_mode != TWI_MODE_UNKNOWN) {
     bd8:	80 91 40 38 	lds	r24, 0x3840	; 0x803840 <twi_mode>
     bdc:	81 11       	cpse	r24, r1
     bde:	1a c0       	rjmp	.+52     	; 0xc14 <tiny4koled_begin_wire()+0x54>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:77
  } else {
    PORTA.OUTCLR=0x0C; //bits 2 and 3
  }
  #else // megaTinyCore
    #if defined(PORTMUX_TWI0_bm)
      if ((PORTMUX.CTRLB & PORTMUX_TWI0_bm)) {
     be0:	80 91 01 02 	lds	r24, 0x0201	; 0x800201 <vtable for SSD1306Device+0x7f68bd>
     be4:	84 ff       	sbrs	r24, 4
     be6:	3c c0       	rjmp	.+120    	; 0xc60 <tiny4koled_begin_wire()+0xa0>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:80
        // make sure we don't get errata'ed - make sure their bits in the
        // PORTx.OUT registers are 0.
        PORTA.OUTCLR=0x06; // if swapped it's on PA1, PA2
     be8:	86 e0       	ldi	r24, 0x06	; 6
     bea:	80 93 06 04 	sts	0x0406, r24	; 0x800406 <vtable for SSD1306Device+0x7f6ac2>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:91
    #else
      PORTB.OUTCLR=0x03; // else, zero series, no remapping, it's on PB0, PB1
    #endif
  #endif

  twi_mode = TWI_MODE_MASTER;
     bee:	81 e0       	ldi	r24, 0x01	; 1
     bf0:	80 93 40 38 	sts	0x3840, r24	; 0x803840 <twi_mode>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:93

  master_bytesRead = 0;
     bf4:	10 92 3f 38 	sts	0x383F, r1	; 0x80383f <master_bytesRead>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:94
  master_bytesWritten = 0;
     bf8:	10 92 3b 38 	sts	0x383B, r1	; 0x80383b <master_bytesWritten>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:95
  master_trans_status = TWIM_STATUS_READY;
     bfc:	10 92 41 38 	sts	0x3841, r1	; 0x803841 <master_trans_status>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:96
  master_result = TWIM_RESULT_UNKNOWN;
     c00:	10 92 42 38 	sts	0x3842, r1	; 0x803842 <master_result>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:98

  TWI0.MCTRLA = TWI_RIEN_bm | TWI_WIEN_bm | TWI_ENABLE_bm;
     c04:	91 ec       	ldi	r25, 0xC1	; 193
     c06:	90 93 13 08 	sts	0x0813, r25	; 0x800813 <vtable for SSD1306Device+0x7f6ecf>
TWI_MasterSetBaud():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:246
    frequency = 100000;
    t_rise    = 1000;
  }

  uint32_t baud = (F_CPU / frequency - F_CPU / 1000 / 1000 * t_rise / 1000 - 10) / 2;
  TWI0.MBAUD = (uint8_t)baud;
     c0a:	95 e5       	ldi	r25, 0x55	; 85
     c0c:	90 93 16 08 	sts	0x0816, r25	; 0x800816 <vtable for SSD1306Device+0x7f6ed2>
TWI_MasterInit():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:100
  master_trans_status = TWIM_STATUS_READY;
  master_result = TWIM_RESULT_UNKNOWN;

  TWI0.MCTRLA = TWI_RIEN_bm | TWI_WIEN_bm | TWI_ENABLE_bm;
  TWI_MasterSetBaud(frequency);
  TWI0.MSTATUS = TWI_BUSSTATE_IDLE_gc;
     c10:	80 93 15 08 	sts	0x0815, r24	; 0x800815 <vtable for SSD1306Device+0x7f6ed1>
tiny4koled_check_wire():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED_Wire.h:43
}

#ifndef TINY4KOLED_QUICK_BEGIN
inline static bool tiny4koled_check_wire(void) {
	const uint8_t noError = 0x00;
	tiny4koled_beginTransmission_wire();
     c14:	0e 94 70 05 	call	0xae0	; 0xae0 <tiny4koled_beginTransmission_wire()>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED_Wire.h:44
	return (datacute_endTransmission_wire()==noError);
     c18:	0e 94 79 05 	call	0xaf2	; 0xaf2 <datacute_endTransmission_wire()>
tiny4koled_begin_wire():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED_Wire.h:51
#endif

static void tiny4koled_begin_wire(void) {
	Wire.begin();
#ifndef TINY4KOLED_QUICK_BEGIN
	while (!tiny4koled_check_wire()) {
     c1c:	88 23       	and	r24, r24
     c1e:	21 f1       	breq	.+72     	; 0xc68 <tiny4koled_begin_wire()+0xa8>
delay():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:316

#endif //end of non-MILLIS_USE_TIMERNONE code

#if !(defined(MILLIS_USE_TIMERNONE) || defined(MILLIS_USE_TIMERRTC)) //delay implementation when we do have micros()
void delay(unsigned long ms) {
  uint32_t start_time = micros(), delay_time = 1000 * ms;
     c20:	0e 94 92 03 	call	0x724	; 0x724 <micros>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:319

  /* Calculate future time to return */
  uint32_t return_time = start_time + delay_time;
     c24:	6b 01       	movw	r12, r22
     c26:	7c 01       	movw	r14, r24
     c28:	20 e1       	ldi	r18, 0x10	; 16
     c2a:	c2 0e       	add	r12, r18
     c2c:	27 e2       	ldi	r18, 0x27	; 39
     c2e:	d2 1e       	adc	r13, r18
     c30:	e1 1c       	adc	r14, r1
     c32:	f1 1c       	adc	r15, r1
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:322

  /* If return time overflows */
  if (return_time < delay_time) {
     c34:	80 e1       	ldi	r24, 0x10	; 16
     c36:	c8 16       	cp	r12, r24
     c38:	87 e2       	ldi	r24, 0x27	; 39
     c3a:	d8 06       	cpc	r13, r24
     c3c:	e1 04       	cpc	r14, r1
     c3e:	f1 04       	cpc	r15, r1
     c40:	38 f4       	brcc	.+14     	; 0xc50 <tiny4koled_begin_wire()+0x90>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:324
    /* Wait until micros overflows */
    while (micros() > return_time);
     c42:	0e 94 92 03 	call	0x724	; 0x724 <micros>
     c46:	c6 16       	cp	r12, r22
     c48:	d7 06       	cpc	r13, r23
     c4a:	e8 06       	cpc	r14, r24
     c4c:	f9 06       	cpc	r15, r25
     c4e:	c8 f3       	brcs	.-14     	; 0xc42 <tiny4koled_begin_wire()+0x82>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:328
  }

  /* Wait until return time */
  while (micros() < return_time);
     c50:	0e 94 92 03 	call	0x724	; 0x724 <micros>
     c54:	6c 15       	cp	r22, r12
     c56:	7d 05       	cpc	r23, r13
     c58:	8e 05       	cpc	r24, r14
     c5a:	9f 05       	cpc	r25, r15
     c5c:	c8 f3       	brcs	.-14     	; 0xc50 <tiny4koled_begin_wire()+0x90>
     c5e:	da cf       	rjmp	.-76     	; 0xc14 <tiny4koled_begin_wire()+0x54>
TWI_MasterInit():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:82
      if ((PORTMUX.CTRLB & PORTMUX_TWI0_bm)) {
        // make sure we don't get errata'ed - make sure their bits in the
        // PORTx.OUT registers are 0.
        PORTA.OUTCLR=0x06; // if swapped it's on PA1, PA2
      } else {
        PORTB.OUTCLR=0x03; // else PB0, PB1
     c60:	83 e0       	ldi	r24, 0x03	; 3
     c62:	80 93 26 04 	sts	0x0426, r24	; 0x800426 <vtable for SSD1306Device+0x7f6ae2>
     c66:	c3 cf       	rjmp	.-122    	; 0xbee <tiny4koled_begin_wire()+0x2e>
tiny4koled_begin_wire():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED_Wire.h:55
		delay(10);
	}
#endif
}
     c68:	ff 90       	pop	r15
     c6a:	ef 90       	pop	r14
     c6c:	df 90       	pop	r13
     c6e:	cf 90       	pop	r12
     c70:	08 95       	ret

00000c72 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.28]>:
printNumber():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:215
  return vfprintf_P(&f, (const char *)format, ap);
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base) {
     c72:	8f 92       	push	r8
     c74:	9f 92       	push	r9
     c76:	af 92       	push	r10
     c78:	bf 92       	push	r11
     c7a:	0f 93       	push	r16
     c7c:	1f 93       	push	r17
     c7e:	cf 93       	push	r28
     c80:	df 93       	push	r29
     c82:	cd b7       	in	r28, 0x3d	; 61
     c84:	de b7       	in	r29, 0x3e	; 62
     c86:	a1 97       	sbiw	r28, 0x21	; 33
     c88:	cd bf       	out	0x3d, r28	; 61
     c8a:	de bf       	out	0x3e, r29	; 62
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:219
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
     c8c:	19 a2       	std	Y+33, r1	; 0x21
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:222

  // prevent crash if called with base == 1
  if (base < 2) {
     c8e:	42 30       	cpi	r20, 0x02	; 2
     c90:	08 f4       	brcc	.+2      	; 0xc94 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.28]+0x22>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:223
    base = 10;
     c92:	4a e0       	ldi	r20, 0x0A	; 10
     c94:	8e 01       	movw	r16, r28
     c96:	0f 5d       	subi	r16, 0xDF	; 223
     c98:	1f 4f       	sbci	r17, 0xFF	; 255
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:227
  }

  do {
    char c = n % base;
     c9a:	84 2e       	mov	r8, r20
     c9c:	91 2c       	mov	r9, r1
     c9e:	b1 2c       	mov	r11, r1
     ca0:	a1 2c       	mov	r10, r1
     ca2:	a5 01       	movw	r20, r10
     ca4:	94 01       	movw	r18, r8
     ca6:	0e 94 88 0b 	call	0x1710	; 0x1710 <__udivmodsi4>
     caa:	e6 2f       	mov	r30, r22
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:228
    n /= base;
     cac:	b9 01       	movw	r22, r18
     cae:	ca 01       	movw	r24, r20
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:230

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
     cb0:	ea 30       	cpi	r30, 0x0A	; 10
     cb2:	2c f5       	brge	.+74     	; 0xcfe <Print::printNumber(unsigned long, unsigned char) [clone .constprop.28]+0x8c>
     cb4:	e0 5d       	subi	r30, 0xD0	; 208
     cb6:	d8 01       	movw	r26, r16
     cb8:	ee 93       	st	-X, r30
     cba:	8d 01       	movw	r16, r26
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:231
  } while (n);
     cbc:	23 2b       	or	r18, r19
     cbe:	24 2b       	or	r18, r20
     cc0:	25 2b       	or	r18, r21
     cc2:	79 f7       	brne	.-34     	; 0xca2 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.28]+0x30>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.h:54
    }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) {
        return 0;
     cc4:	90 e0       	ldi	r25, 0x00	; 0
     cc6:	80 e0       	ldi	r24, 0x00	; 0
write():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.h:53
      setWriteError(0);
    }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) {
     cc8:	10 97       	sbiw	r26, 0x00	; 0
     cca:	69 f0       	breq	.+26     	; 0xce6 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.28]+0x74>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.h:56
        return 0;
      }
      return write((const uint8_t *)str, strlen(str));
     ccc:	fd 01       	movw	r30, r26
     cce:	01 90       	ld	r0, Z+
     cd0:	00 20       	and	r0, r0
     cd2:	e9 f7       	brne	.-6      	; 0xcce <Print::printNumber(unsigned long, unsigned char) [clone .constprop.28]+0x5c>
     cd4:	31 97       	sbiw	r30, 0x01	; 1
     cd6:	af 01       	movw	r20, r30
     cd8:	4a 1b       	sub	r20, r26
     cda:	5b 0b       	sbc	r21, r27
     cdc:	bd 01       	movw	r22, r26
     cde:	82 e8       	ldi	r24, 0x82	; 130
     ce0:	98 e3       	ldi	r25, 0x38	; 56
     ce2:	0e 94 65 03 	call	0x6ca	; 0x6ca <Print::write(unsigned char const*, unsigned int)>
printNumber():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:234

  return write(str);
}
     ce6:	a1 96       	adiw	r28, 0x21	; 33
     ce8:	cd bf       	out	0x3d, r28	; 61
     cea:	de bf       	out	0x3e, r29	; 62
     cec:	df 91       	pop	r29
     cee:	cf 91       	pop	r28
     cf0:	1f 91       	pop	r17
     cf2:	0f 91       	pop	r16
     cf4:	bf 90       	pop	r11
     cf6:	af 90       	pop	r10
     cf8:	9f 90       	pop	r9
     cfa:	8f 90       	pop	r8
     cfc:	08 95       	ret
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:230

  do {
    char c = n % base;
    n /= base;

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
     cfe:	e9 5c       	subi	r30, 0xC9	; 201
     d00:	da cf       	rjmp	.-76     	; 0xcb6 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.28]+0x44>

00000d02 <digitalWrite.constprop.3>:
digitalWrite():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:221
  that the value of the port was set correctly when it was
  changed to an output. Code in the wild relies on this behavior.
  */

  if (val == LOW) { /* If LOW */
    port->OUTCLR = bit_mask;
     d02:	90 e4       	ldi	r25, 0x40	; 64
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:220
  you could digitalWrite() a pin while it's an input, to ensure
  that the value of the port was set correctly when it was
  changed to an output. Code in the wild relies on this behavior.
  */

  if (val == LOW) { /* If LOW */
     d04:	81 11       	cpse	r24, r1
     d06:	13 c0       	rjmp	.+38     	; 0xd2e <digitalWrite.constprop.3+0x2c>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:221
    port->OUTCLR = bit_mask;
     d08:	90 93 06 04 	sts	0x0406, r25	; 0x800406 <vtable for SSD1306Device+0x7f6ac2>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:238
  } else {
    port->OUTSET = bit_mask;
  }

  /* Input direction */
  if (!(port->DIR & bit_mask)) {
     d0c:	90 91 00 04 	lds	r25, 0x0400	; 0x800400 <vtable for SSD1306Device+0x7f6abc>
     d10:	96 fd       	sbrc	r25, 6
     d12:	0a c0       	rjmp	.+20     	; 0xd28 <digitalWrite.constprop.3+0x26>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:251

    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);

    /* Save system status and disable interrupts */
    uint8_t status = SREG;
     d14:	9f b7       	in	r25, 0x3f	; 63
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:252
    cli();
     d16:	f8 94       	cli
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:254

    if (val == LOW) {
     d18:	81 11       	cpse	r24, r1
     d1a:	0c c0       	rjmp	.+24     	; 0xd34 <digitalWrite.constprop.3+0x32>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:256
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
     d1c:	80 91 16 04 	lds	r24, 0x0416	; 0x800416 <vtable for SSD1306Device+0x7f6ad2>
     d20:	87 7f       	andi	r24, 0xF7	; 247
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:259
    } else {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
     d22:	80 93 16 04 	sts	0x0416, r24	; 0x800416 <vtable for SSD1306Device+0x7f6ad2>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:263
    }

    /* Restore system status */
    SREG = status;
     d26:	9f bf       	out	0x3f, r25	; 63
turnOffPWM():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:150
    /* we don't need the type b timers as this core does not use them for PWM      */

    // 1-series parts have a DAC that we can use...
    #if defined(DAC0)
      case DACOUT:
        DAC0.CTRLA = 0x00;
     d28:	10 92 a0 06 	sts	0x06A0, r1	; 0x8006a0 <vtable for SSD1306Device+0x7f6d5c>
digitalWrite():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:270
  /* Turn off PWM if applicable */
  // If the pin supports PWM output, we need to turn it off
  // Better to do so AFTER we have set PORTx.OUT to what we want it to be when we're done
  // The glitch would be super short, of course, but why make a glitch we don't have to?
  turnOffPWM(pin);
}
     d2c:	08 95       	ret
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:234
    // val will now be 0 (LOW) if the toggling made it LOW
    // or bit_mask if not. And further down, we only need to
    // know if it's
  /* If HIGH OR  > TOGGLE  */
  } else {
    port->OUTSET = bit_mask;
     d2e:	90 93 05 04 	sts	0x0405, r25	; 0x800405 <vtable for SSD1306Device+0x7f6ac1>
     d32:	ec cf       	rjmp	.-40     	; 0xd0c <digitalWrite.constprop.3+0xa>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:259
    if (val == LOW) {
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
    } else {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
     d34:	80 91 16 04 	lds	r24, 0x0416	; 0x800416 <vtable for SSD1306Device+0x7f6ad2>
     d38:	88 60       	ori	r24, 0x08	; 8
     d3a:	f3 cf       	rjmp	.-26     	; 0xd22 <digitalWrite.constprop.3+0x20>

00000d3c <pinMode>:
pinMode():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:41
    // taking shortcuts we disapprove of, but to call out things that are virtually guaranteed to be a bug.
    // Passing -1/255/NOT_A_PIN to the digital I/O functions is most likely intentional.
      badArg("Digital pin is constant, but not a valid pin");
}

void pinMode(uint8_t pin, uint8_t mode) {
     d3c:	cf 93       	push	r28
     d3e:	df 93       	push	r29
check_valid_digital_pin():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:32
#include "pins_arduino.h"


inline __attribute__((always_inline)) void check_valid_digital_pin(pin_size_t pin)
{
  if(__builtin_constant_p(pin))
     d40:	90 e0       	ldi	r25, 0x00	; 0
pinMode():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:44
}

void pinMode(uint8_t pin, uint8_t mode) {
  check_valid_digital_pin(pin);

  uint8_t bit_mask = digitalPinToBitMask(pin);
     d42:	fc 01       	movw	r30, r24
     d44:	ee 5d       	subi	r30, 0xDE	; 222
     d46:	f6 46       	sbci	r31, 0x66	; 102
     d48:	20 81       	ld	r18, Z
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:46

  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
     d4a:	2f 3f       	cpi	r18, 0xFF	; 255
     d4c:	61 f0       	breq	.+24     	; 0xd66 <pinMode+0x2a>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:50
    return;
  }

  PORT_t *port = digitalPinToPortStruct(pin);
     d4e:	fc 01       	movw	r30, r24
     d50:	e0 5f       	subi	r30, 0xF0	; 240
     d52:	f6 46       	sbci	r31, 0x66	; 102
     d54:	e0 81       	ld	r30, Z
     d56:	30 e2       	ldi	r19, 0x20	; 32
     d58:	e3 9f       	mul	r30, r19
     d5a:	f0 01       	movw	r30, r0
     d5c:	11 24       	eor	r1, r1
     d5e:	fc 5f       	subi	r31, 0xFC	; 252
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:55
  if (port == NULL) {
    return;
  }

  if (mode == OUTPUT) {
     d60:	61 30       	cpi	r22, 0x01	; 1
     d62:	21 f4       	brne	.+8      	; 0xd6c <pinMode+0x30>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:58

    /* Configure direction as output */
    port->DIRSET = bit_mask;
     d64:	21 83       	std	Z+1, r18	; 0x01
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:95
    }

    /* Restore state */
    SREG = status;
  }
}
     d66:	df 91       	pop	r29
     d68:	cf 91       	pop	r28
     d6a:	08 95       	ret
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:62
    /* Configure direction as output */
    port->DIRSET = bit_mask;

  } else { /* mode == INPUT or INPUT_PULLUP */

    uint8_t bit_pos = digitalPinToBitPosition(pin);
     d6c:	82 50       	subi	r24, 0x02	; 2
     d6e:	97 46       	sbci	r25, 0x67	; 103
     d70:	ec 01       	movw	r28, r24
     d72:	a8 81       	ld	r26, Y
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:64
    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
     d74:	af 3f       	cpi	r26, 0xFF	; 255
     d76:	71 f0       	breq	.+28     	; 0xd94 <pinMode+0x58>
     d78:	cf 01       	movw	r24, r30
     d7a:	40 96       	adiw	r24, 0x10	; 16
     d7c:	a8 0f       	add	r26, r24
     d7e:	b9 2f       	mov	r27, r25
     d80:	b1 1d       	adc	r27, r1
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:67

    /* Save state */
    uint8_t status = SREG;
     d82:	9f b7       	in	r25, 0x3f	; 63
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:68
    cli();
     d84:	f8 94       	cli
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:71

    /* Configure direction as input */
    port->DIRCLR = bit_mask;
     d86:	22 83       	std	Z+2, r18	; 0x02
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:77

    /* Configure pull-up resistor */
    if (mode == INPUT_PULLUP) {

      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
     d88:	8c 91       	ld	r24, X
     d8a:	88 60       	ori	r24, 0x08	; 8
     d8c:	8c 93       	st	X, r24
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:82
      /* Considered this, it was in some 2.2.0 releases. This is debatable - it actually broke Wire...
       * though only because of errata effecting Wire that wasn't explicitly accounted for.
       */
      // emulate setting of the port output register on classic AVR
      port->OUTSET=bit_mask;
     d8e:	25 83       	std	Z+5, r18	; 0x05
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:93
      port->OUTCLR=bit_mask;

    }

    /* Restore state */
    SREG = status;
     d90:	9f bf       	out	0x3f, r25	; 63
     d92:	e9 cf       	rjmp	.-46     	; 0xd66 <pinMode+0x2a>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:64

  } else { /* mode == INPUT or INPUT_PULLUP */

    uint8_t bit_pos = digitalPinToBitPosition(pin);
    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
     d94:	b0 e0       	ldi	r27, 0x00	; 0
     d96:	a0 e0       	ldi	r26, 0x00	; 0
     d98:	f4 cf       	rjmp	.-24     	; 0xd82 <pinMode+0x46>

00000d9a <__vector_15>:
__vector_15():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:139
#elif defined(MILLIS_USE_TIMERB1)
  ISR(TCB1_INT_vect)
#else
  #error "No millis timer selected, but not disabled - cannot determine millis vector"
#endif
{
     d9a:	1f 92       	push	r1
     d9c:	0f 92       	push	r0
     d9e:	0f b6       	in	r0, 0x3f	; 63
     da0:	0f 92       	push	r0
     da2:	11 24       	eor	r1, r1
     da4:	2f 93       	push	r18
     da6:	3f 93       	push	r19
     da8:	4f 93       	push	r20
     daa:	5f 93       	push	r21
     dac:	6f 93       	push	r22
     dae:	8f 93       	push	r24
     db0:	9f 93       	push	r25
     db2:	af 93       	push	r26
     db4:	bf 93       	push	r27
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:151
  #else
  timer_millis += 2;
  #endif
  #else
  #if !defined(MILLIS_USE_TIMERRTC) //TCA0 or TCD0
  uint32_t m = timer_millis;
     db6:	80 91 4a 38 	lds	r24, 0x384A	; 0x80384a <timer_millis>
     dba:	90 91 4b 38 	lds	r25, 0x384B	; 0x80384b <timer_millis+0x1>
     dbe:	a0 91 4c 38 	lds	r26, 0x384C	; 0x80384c <timer_millis+0x2>
     dc2:	b0 91 4d 38 	lds	r27, 0x384D	; 0x80384d <timer_millis+0x3>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:152
  uint16_t f = timer_fract;
     dc6:	40 91 48 38 	lds	r20, 0x3848	; 0x803848 <timer_fract>
     dca:	50 91 49 38 	lds	r21, 0x3849	; 0x803849 <timer_fract+0x1>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:154
  m += MILLIS_INC;
  f += FRACT_INC;
     dce:	9a 01       	movw	r18, r20
     dd0:	20 5d       	subi	r18, 0xD0	; 208
     dd2:	3c 4f       	sbci	r19, 0xFC	; 252
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:155
  if (f >= FRACT_MAX) {
     dd4:	28 3e       	cpi	r18, 0xE8	; 232
     dd6:	63 e0       	ldi	r22, 0x03	; 3
     dd8:	36 07       	cpc	r19, r22
     dda:	28 f0       	brcs	.+10     	; 0xde6 <__vector_15+0x4c>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:157

    f -= FRACT_MAX;
     ddc:	28 5e       	subi	r18, 0xE8	; 232
     dde:	33 40       	sbci	r19, 0x03	; 3
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:158
    m += 1;
     de0:	01 96       	adiw	r24, 0x01	; 1
     de2:	a1 1d       	adc	r26, r1
     de4:	b1 1d       	adc	r27, r1
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:160
  }
  timer_fract = f;
     de6:	20 93 48 38 	sts	0x3848, r18	; 0x803848 <timer_fract>
     dea:	30 93 49 38 	sts	0x3849, r19	; 0x803849 <timer_fract+0x1>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:161
  timer_millis = m;
     dee:	80 93 4a 38 	sts	0x384A, r24	; 0x80384a <timer_millis>
     df2:	90 93 4b 38 	sts	0x384B, r25	; 0x80384b <timer_millis+0x1>
     df6:	a0 93 4c 38 	sts	0x384C, r26	; 0x80384c <timer_millis+0x2>
     dfa:	b0 93 4d 38 	sts	0x384D, r27	; 0x80384d <timer_millis+0x3>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:164
  #endif
  //if RTC is used as timer, we only increment the overflow count
  timer_overflow_count++;
     dfe:	80 91 4e 38 	lds	r24, 0x384E	; 0x80384e <timer_overflow_count>
     e02:	90 91 4f 38 	lds	r25, 0x384F	; 0x80384f <timer_overflow_count+0x1>
     e06:	a0 91 50 38 	lds	r26, 0x3850	; 0x803850 <timer_overflow_count+0x2>
     e0a:	b0 91 51 38 	lds	r27, 0x3851	; 0x803851 <timer_overflow_count+0x3>
     e0e:	01 96       	adiw	r24, 0x01	; 1
     e10:	a1 1d       	adc	r26, r1
     e12:	b1 1d       	adc	r27, r1
     e14:	80 93 4e 38 	sts	0x384E, r24	; 0x80384e <timer_overflow_count>
     e18:	90 93 4f 38 	sts	0x384F, r25	; 0x80384f <timer_overflow_count+0x1>
     e1c:	a0 93 50 38 	sts	0x3850, r26	; 0x803850 <timer_overflow_count+0x2>
     e20:	b0 93 51 38 	sts	0x3851, r27	; 0x803851 <timer_overflow_count+0x3>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:170
  #endif
  /* Clear flag */
  #if defined(MILLIS_USE_TIMERA0)
  TCA0.SPLIT.INTFLAGS = TCA_SPLIT_HUNF_bm;
  #elif defined(MILLIS_USE_TIMERD0)
  TCD0.INTFLAGS = TCD_OVF_bm;
     e24:	81 e0       	ldi	r24, 0x01	; 1
     e26:	80 93 8d 0a 	sts	0x0A8D, r24	; 0x800a8d <vtable for SSD1306Device+0x7f7149>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:176
  #elif defined(MILLIS_USE_TIMERRTC)
  RTC.INTFLAGS = RTC_OVF_bm;
  #else //timerb
  _timer->INTFLAGS = TCB_CAPT_bm;
  #endif
}
     e2a:	bf 91       	pop	r27
     e2c:	af 91       	pop	r26
     e2e:	9f 91       	pop	r25
     e30:	8f 91       	pop	r24
     e32:	6f 91       	pop	r22
     e34:	5f 91       	pop	r21
     e36:	4f 91       	pop	r20
     e38:	3f 91       	pop	r19
     e3a:	2f 91       	pop	r18
     e3c:	0f 90       	pop	r0
     e3e:	0f be       	out	0x3f, r0	; 63
     e40:	0f 90       	pop	r0
     e42:	1f 90       	pop	r1
     e44:	18 95       	reti

00000e46 <__vector_24>:
__vector_24():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:818

ISR(TWI0_TWIM_vect) {
  TWI_MasterInterruptHandler();
}

ISR(TWI0_TWIS_vect) {
     e46:	1f 92       	push	r1
     e48:	0f 92       	push	r0
     e4a:	0f b6       	in	r0, 0x3f	; 63
     e4c:	0f 92       	push	r0
     e4e:	11 24       	eor	r1, r1
     e50:	2f 93       	push	r18
     e52:	3f 93       	push	r19
     e54:	4f 93       	push	r20
     e56:	5f 93       	push	r21
     e58:	6f 93       	push	r22
     e5a:	7f 93       	push	r23
     e5c:	8f 93       	push	r24
     e5e:	9f 93       	push	r25
     e60:	af 93       	push	r26
     e62:	bf 93       	push	r27
     e64:	cf 93       	push	r28
     e66:	ef 93       	push	r30
     e68:	ff 93       	push	r31
TWI_SlaveInterruptHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:581

    Check current status and calls the appropriate handler.

*/
void TWI_SlaveInterruptHandler() {
  uint8_t currentStatus = TWI0.SSTATUS;
     e6a:	c0 91 1b 08 	lds	r28, 0x081B	; 0x80081b <vtable for SSD1306Device+0x7f6ed7>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:584

  /* If bus error */
  if (currentStatus & TWI_BUSERR_bm) {
     e6e:	c2 ff       	sbrs	r28, 2
     e70:	0a c0       	rjmp	.+20     	; 0xe86 <__vector_24+0x40>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:585
    slave_bytesRead = 0;
     e72:	10 92 47 38 	sts	0x3847, r1	; 0x803847 <slave_bytesRead>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:586
    slave_bytesWritten = 0;
     e76:	10 92 46 38 	sts	0x3846, r1	; 0x803846 <slave_bytesWritten>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:587
    slave_bytesToWrite = 0;
     e7a:	10 92 45 38 	sts	0x3845, r1	; 0x803845 <slave_bytesToWrite>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:588
    TWI_SlaveTransactionFinished(TWIS_RESULT_BUS_ERROR);
     e7e:	84 e0       	ldi	r24, 0x04	; 4
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:642
    }
  }

  /* If unexpected state */
  else {
    TWI_SlaveTransactionFinished(TWIS_RESULT_FAIL);
     e80:	0e 94 cf 03 	call	0x79e	; 0x79e <TWI_SlaveTransactionFinished>
     e84:	12 c0       	rjmp	.+36     	; 0xeaa <__vector_24+0x64>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:592
    slave_bytesToWrite = 0;
    TWI_SlaveTransactionFinished(TWIS_RESULT_BUS_ERROR);
  }

  /* If Address or Stop */
  else if (currentStatus & TWI_APIF_bm) {
     e86:	c6 ff       	sbrs	r28, 6
     e88:	2d c0       	rjmp	.+90     	; 0xee4 <__vector_24+0x9e>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:597

    /* Call user onReceive function if end of Master Write/Slave Read.
       This should be hit when there is a STOP or REPSTART
    */
    if (slave_callUserReceive == 1) {
     e8a:	80 91 44 38 	lds	r24, 0x3844	; 0x803844 <slave_callUserReceive>
     e8e:	81 30       	cpi	r24, 0x01	; 1
     e90:	41 f4       	brne	.+16     	; 0xea2 <__vector_24+0x5c>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:598
      TWI_onSlaveReceive(slave_bytesRead);
     e92:	80 91 47 38 	lds	r24, 0x3847	; 0x803847 <slave_bytesRead>
     e96:	90 e0       	ldi	r25, 0x00	; 0
     e98:	f0 e0       	ldi	r31, 0x00	; 0
     e9a:	e0 e0       	ldi	r30, 0x00	; 0
     e9c:	09 95       	icall
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:599
      slave_callUserReceive = 0;
     e9e:	10 92 44 38 	sts	0x3844, r1	; 0x803844 <slave_callUserReceive>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:603
    }

    /* If address match */
    if (currentStatus & TWI_AP_bm) {
     ea2:	c0 ff       	sbrs	r28, 0
     ea4:	14 c0       	rjmp	.+40     	; 0xece <__vector_24+0x88>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:604
      TWI_SlaveAddressMatchHandler();
     ea6:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <TWI_SlaveAddressMatchHandler>
__vector_24():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:820
  TWI_MasterInterruptHandler();
}

ISR(TWI0_TWIS_vect) {
  TWI_SlaveInterruptHandler();
}
     eaa:	ff 91       	pop	r31
     eac:	ef 91       	pop	r30
     eae:	cf 91       	pop	r28
     eb0:	bf 91       	pop	r27
     eb2:	af 91       	pop	r26
     eb4:	9f 91       	pop	r25
     eb6:	8f 91       	pop	r24
     eb8:	7f 91       	pop	r23
     eba:	6f 91       	pop	r22
     ebc:	5f 91       	pop	r21
     ebe:	4f 91       	pop	r20
     ec0:	3f 91       	pop	r19
     ec2:	2f 91       	pop	r18
     ec4:	0f 90       	pop	r0
     ec6:	0f be       	out	0x3f, r0	; 63
     ec8:	0f 90       	pop	r0
     eca:	1f 90       	pop	r1
     ecc:	18 95       	reti
TWI_SlaveStopHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:682

*/
void TWI_SlaveStopHandler() {

  /* Clear APIF, don't ACK or NACK */
  TWI0.SSTATUS = TWI_APIF_bm;
     ece:	80 e4       	ldi	r24, 0x40	; 64
     ed0:	80 93 1b 08 	sts	0x081B, r24	; 0x80081b <vtable for SSD1306Device+0x7f6ed7>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:684

  TWI_SlaveTransactionFinished(TWIS_RESULT_OK);
     ed4:	81 e0       	ldi	r24, 0x01	; 1
     ed6:	0e 94 cf 03 	call	0x79e	; 0x79e <TWI_SlaveTransactionFinished>
TWI_SlaveInterruptHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:615

      /* If CLKHOLD is high, we have missed an address match
        from a fast start after stop.
        Because the flag is shared we need to handle this here.
      */
      if (TWI0.SSTATUS & TWI_CLKHOLD_bm) {
     eda:	80 91 1b 08 	lds	r24, 0x081B	; 0x80081b <vtable for SSD1306Device+0x7f6ed7>
     ede:	85 ff       	sbrs	r24, 5
     ee0:	e4 cf       	rjmp	.-56     	; 0xeaa <__vector_24+0x64>
     ee2:	e1 cf       	rjmp	.-62     	; 0xea6 <__vector_24+0x60>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:624
      }
    }
  }

  /* If Data Interrupt */
  else if (currentStatus & TWI_DIF_bm) {
     ee4:	c7 ff       	sbrs	r28, 7
     ee6:	50 c0       	rjmp	.+160    	; 0xf88 <__vector_24+0x142>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:627

    /* If collision flag is raised, slave transmit unsuccessful */
    if (currentStatus & TWI_COLL_bm) {
     ee8:	c3 ff       	sbrs	r28, 3
     eea:	08 c0       	rjmp	.+16     	; 0xefc <__vector_24+0xb6>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:628
      slave_bytesRead = 0;
     eec:	10 92 47 38 	sts	0x3847, r1	; 0x803847 <slave_bytesRead>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:629
      slave_bytesWritten = 0;
     ef0:	10 92 46 38 	sts	0x3846, r1	; 0x803846 <slave_bytesWritten>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:630
      slave_bytesToWrite = 0;
     ef4:	10 92 45 38 	sts	0x3845, r1	; 0x803845 <slave_bytesToWrite>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:631
      TWI_SlaveTransactionFinished(TWIS_RESULT_TRANSMIT_COLLISION);
     ef8:	83 e0       	ldi	r24, 0x03	; 3
     efa:	c2 cf       	rjmp	.-124    	; 0xe80 <__vector_24+0x3a>
TWI_SlaveDataHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:697

*/
void TWI_SlaveDataHandler() {

  /* Enable stop interrupt */
  TWI0.SCTRLA |= (TWI_APIEN_bm | TWI_PIEN_bm);
     efc:	80 91 19 08 	lds	r24, 0x0819	; 0x800819 <vtable for SSD1306Device+0x7f6ed5>
     f00:	80 66       	ori	r24, 0x60	; 96
     f02:	80 93 19 08 	sts	0x0819, r24	; 0x800819 <vtable for SSD1306Device+0x7f6ed5>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:700

  /* If Master Read/Slave Write */
  if (TWI0.SSTATUS & TWI_DIR_bm) {
     f06:	80 91 1b 08 	lds	r24, 0x081B	; 0x80081b <vtable for SSD1306Device+0x7f6ed7>
     f0a:	81 ff       	sbrs	r24, 1
     f0c:	26 c0       	rjmp	.+76     	; 0xf5a <__vector_24+0x114>
TWI_SlaveWriteHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:721

*/
void TWI_SlaveWriteHandler() {

  /* If NACK, slave write transaction finished */
  if ((slave_bytesWritten > 0) && (TWI0.SSTATUS & TWI_RXACK_bm)) {
     f0e:	80 91 46 38 	lds	r24, 0x3846	; 0x803846 <slave_bytesWritten>
     f12:	88 23       	and	r24, r24
     f14:	49 f0       	breq	.+18     	; 0xf28 <__vector_24+0xe2>
     f16:	80 91 1b 08 	lds	r24, 0x081B	; 0x80081b <vtable for SSD1306Device+0x7f6ed7>
     f1a:	84 ff       	sbrs	r24, 4
     f1c:	05 c0       	rjmp	.+10     	; 0xf28 <__vector_24+0xe2>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:723

    TWI0.SCTRLB = TWI_SCMD_COMPTRANS_gc;
     f1e:	82 e0       	ldi	r24, 0x02	; 2
     f20:	80 93 1a 08 	sts	0x081A, r24	; 0x80081a <vtable for SSD1306Device+0x7f6ed6>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:724
    TWI_SlaveTransactionFinished(TWIS_RESULT_OK);
     f24:	81 e0       	ldi	r24, 0x01	; 1
     f26:	ac cf       	rjmp	.-168    	; 0xe80 <__vector_24+0x3a>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:730
  }

  /* If ACK, master expects more data */
  else {

    if (slave_bytesWritten < slave_bytesToWrite) {
     f28:	90 91 46 38 	lds	r25, 0x3846	; 0x803846 <slave_bytesWritten>
     f2c:	80 91 45 38 	lds	r24, 0x3845	; 0x803845 <slave_bytesToWrite>
     f30:	98 17       	cp	r25, r24
     f32:	78 f4       	brcc	.+30     	; 0xf52 <__vector_24+0x10c>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:731
      uint8_t data = slave_writeData[slave_bytesWritten];
     f34:	e0 91 46 38 	lds	r30, 0x3846	; 0x803846 <slave_bytesWritten>
     f38:	f0 e0       	ldi	r31, 0x00	; 0
     f3a:	80 81       	ld	r24, Z
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:732
      TWI0.SDATA = data;
     f3c:	80 93 1d 08 	sts	0x081D, r24	; 0x80081d <vtable for SSD1306Device+0x7f6ed9>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:733
      slave_bytesWritten++;
     f40:	80 91 46 38 	lds	r24, 0x3846	; 0x803846 <slave_bytesWritten>
     f44:	8f 5f       	subi	r24, 0xFF	; 255
     f46:	80 93 46 38 	sts	0x3846, r24	; 0x803846 <slave_bytesWritten>
TWI_SlaveReadHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:767
    uint8_t data = TWI0.SDATA;
    slave_readData[slave_bytesRead] = data;
    slave_bytesRead++;

    /* Send ACK and wait for data interrupt */
    TWI0.SCTRLB = TWI_SCMD_RESPONSE_gc;
     f4a:	83 e0       	ldi	r24, 0x03	; 3
     f4c:	80 93 1a 08 	sts	0x081A, r24	; 0x80081a <vtable for SSD1306Device+0x7f6ed6>
     f50:	ac cf       	rjmp	.-168    	; 0xeaa <__vector_24+0x64>
TWI_SlaveWriteHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:742

    }

    /* If buffer overflow */
    else {
      TWI0.SCTRLB = TWI_SCMD_COMPTRANS_gc;
     f52:	82 e0       	ldi	r24, 0x02	; 2
     f54:	80 93 1a 08 	sts	0x081A, r24	; 0x80081a <vtable for SSD1306Device+0x7f6ed6>
     f58:	93 cf       	rjmp	.-218    	; 0xe80 <__vector_24+0x3a>
TWI_SlaveReadHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:759

*/
void TWI_SlaveReadHandler() {

  /* If free space in buffer */
  if (slave_bytesRead < slave_bytesToRead) {
     f5a:	90 91 47 38 	lds	r25, 0x3847	; 0x803847 <slave_bytesRead>
     f5e:	80 91 43 38 	lds	r24, 0x3843	; 0x803843 <slave_bytesToRead>
     f62:	98 17       	cp	r25, r24
     f64:	60 f4       	brcc	.+24     	; 0xf7e <__vector_24+0x138>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:762

    /* Fetch data */
    uint8_t data = TWI0.SDATA;
     f66:	80 91 1d 08 	lds	r24, 0x081D	; 0x80081d <vtable for SSD1306Device+0x7f6ed9>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:763
    slave_readData[slave_bytesRead] = data;
     f6a:	e0 91 47 38 	lds	r30, 0x3847	; 0x803847 <slave_bytesRead>
     f6e:	f0 e0       	ldi	r31, 0x00	; 0
     f70:	80 83       	st	Z, r24
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:764
    slave_bytesRead++;
     f72:	80 91 47 38 	lds	r24, 0x3847	; 0x803847 <slave_bytesRead>
     f76:	8f 5f       	subi	r24, 0xFF	; 255
     f78:	80 93 47 38 	sts	0x3847, r24	; 0x803847 <slave_bytesRead>
     f7c:	e6 cf       	rjmp	.-52     	; 0xf4a <__vector_24+0x104>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:772
    TWI0.SCTRLB = TWI_SCMD_RESPONSE_gc;
  }
  /* If buffer overflow, send NACK and wait for next START.
    Set result buffer overflow */
  else {
    TWI0.SCTRLB = TWI_ACKACT_bm | TWI_SCMD_COMPTRANS_gc;
     f7e:	86 e0       	ldi	r24, 0x06	; 6
     f80:	80 93 1a 08 	sts	0x081A, r24	; 0x80081a <vtable for SSD1306Device+0x7f6ed6>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:773
    TWI_SlaveTransactionFinished(TWIS_RESULT_BUFFER_OVERFLOW);
     f84:	82 e0       	ldi	r24, 0x02	; 2
     f86:	7c cf       	rjmp	.-264    	; 0xe80 <__vector_24+0x3a>
TWI_SlaveInterruptHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:642
    }
  }

  /* If unexpected state */
  else {
    TWI_SlaveTransactionFinished(TWIS_RESULT_FAIL);
     f88:	85 e0       	ldi	r24, 0x05	; 5
     f8a:	7a cf       	rjmp	.-268    	; 0xe80 <__vector_24+0x3a>

00000f8c <__vector_25>:
__vector_25():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:814
  twi_mode = TWI_MODE_SLAVE;
  slave_result = result;
  slave_trans_status = TWIM_STATUS_READY;
}

ISR(TWI0_TWIM_vect) {
     f8c:	1f 92       	push	r1
     f8e:	0f 92       	push	r0
     f90:	0f b6       	in	r0, 0x3f	; 63
     f92:	0f 92       	push	r0
     f94:	11 24       	eor	r1, r1
     f96:	2f 93       	push	r18
     f98:	8f 93       	push	r24
     f9a:	9f 93       	push	r25
     f9c:	ef 93       	push	r30
     f9e:	ff 93       	push	r31
TWI_MasterInterruptHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:413

    Check current status and calls the appropriate handler.

*/
void TWI_MasterInterruptHandler() {
  uint8_t currentStatus = TWI0.MSTATUS;
     fa0:	80 91 15 08 	lds	r24, 0x0815	; 0x800815 <vtable for SSD1306Device+0x7f6ed1>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:416

  /* If arbitration lost or bus error. */
  if ((currentStatus & TWI_ARBLOST_bm) ||
     fa4:	98 2f       	mov	r25, r24
     fa6:	9c 70       	andi	r25, 0x0C	; 12
     fa8:	c1 f0       	breq	.+48     	; 0xfda <__vector_25+0x4e>
TWI_MasterArbitrationLostBusErrorHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:444

    Handles TWI responses to lost arbitration and bus error.

*/
void TWI_MasterArbitrationLostBusErrorHandler() {
  uint8_t currentStatus = TWI0.MSTATUS;
     faa:	80 91 15 08 	lds	r24, 0x0815	; 0x800815 <vtable for SSD1306Device+0x7f6ed1>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:448

  /* If bus error. */
  if (currentStatus & TWI_BUSERR_bm) {
    master_result = TWIM_RESULT_BUS_ERROR;
     fae:	94 e0       	ldi	r25, 0x04	; 4
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:447
*/
void TWI_MasterArbitrationLostBusErrorHandler() {
  uint8_t currentStatus = TWI0.MSTATUS;

  /* If bus error. */
  if (currentStatus & TWI_BUSERR_bm) {
     fb0:	82 ff       	sbrs	r24, 2
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:452
    master_result = TWIM_RESULT_BUS_ERROR;
  }
  /* If arbitration lost. */
  else {
    master_result = TWIM_RESULT_ARBITRATION_LOST;
     fb2:	93 e0       	ldi	r25, 0x03	; 3
     fb4:	90 93 42 38 	sts	0x3842, r25	; 0x803842 <master_result>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:456
  }

  /* Clear all flags, abort operation */
  TWI0.MSTATUS = currentStatus;
     fb8:	80 93 15 08 	sts	0x0815, r24	; 0x800815 <vtable for SSD1306Device+0x7f6ed1>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:459

  /* Wait for a new operation */
  twi_mode = TWI_MODE_MASTER;
     fbc:	81 e0       	ldi	r24, 0x01	; 1
     fbe:	80 93 40 38 	sts	0x3840, r24	; 0x803840 <twi_mode>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:460
  master_trans_status = TWIM_STATUS_READY;
     fc2:	10 92 41 38 	sts	0x3841, r1	; 0x803841 <master_trans_status>
__vector_25():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:816
  slave_trans_status = TWIM_STATUS_READY;
}

ISR(TWI0_TWIM_vect) {
  TWI_MasterInterruptHandler();
}
     fc6:	ff 91       	pop	r31
     fc8:	ef 91       	pop	r30
     fca:	9f 91       	pop	r25
     fcc:	8f 91       	pop	r24
     fce:	2f 91       	pop	r18
     fd0:	0f 90       	pop	r0
     fd2:	0f be       	out	0x3f, r0	; 63
     fd4:	0f 90       	pop	r0
     fd6:	1f 90       	pop	r1
     fd8:	18 95       	reti
TWI_MasterInterruptHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:423

    TWI_MasterArbitrationLostBusErrorHandler();
  }

  /* If master write interrupt. */
  else if (currentStatus & TWI_WIF_bm) {
     fda:	86 ff       	sbrs	r24, 6
     fdc:	4c c0       	rjmp	.+152    	; 0x1076 <__vector_25+0xea>
TWI_MasterWriteHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:471
    Handles TWI transactions (master write) and responses to (N)ACK.

*/
void TWI_MasterWriteHandler() {
  /* Local variables used in if tests to avoid compiler warning. */
  uint8_t bytesToWrite  = master_bytesToWrite;
     fde:	20 91 3c 38 	lds	r18, 0x383C	; 0x80383c <master_bytesToWrite>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:472
  uint8_t bytesToRead   = master_bytesToRead;
     fe2:	90 91 3e 38 	lds	r25, 0x383E	; 0x80383e <master_bytesToRead>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:475

  /* If NOT acknowledged (NACK) by slave cancel the transaction. */
  if (TWI0.MSTATUS & TWI_RXACK_bm) {
     fe6:	80 91 15 08 	lds	r24, 0x0815	; 0x800815 <vtable for SSD1306Device+0x7f6ed1>
     fea:	84 ff       	sbrs	r24, 4
     fec:	10 c0       	rjmp	.+32     	; 0x100e <__vector_25+0x82>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:476
    if (master_sendStop) {
     fee:	80 91 3d 38 	lds	r24, 0x383D	; 0x80383d <master_sendStop>
     ff2:	88 23       	and	r24, r24
     ff4:	51 f0       	breq	.+20     	; 0x100a <__vector_25+0x7e>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:477
      TWI0.MCTRLB = TWI_MCMD_STOP_gc;
     ff6:	83 e0       	ldi	r24, 0x03	; 3
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:479
    } else {
      TWI0.MCTRLB = TWI_MCMD_REPSTART_gc;
     ff8:	80 93 14 08 	sts	0x0814, r24	; 0x800814 <vtable for SSD1306Device+0x7f6ed0>
TWI_MasterTransactionFinished():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:569
    Prepares module for new transaction.

    \param result  The result of the operation.
*/
void TWI_MasterTransactionFinished(uint8_t result) {
  master_result = result;
     ffc:	85 e0       	ldi	r24, 0x05	; 5
     ffe:	80 93 42 38 	sts	0x3842, r24	; 0x803842 <master_result>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:570
  master_trans_status = TWIM_STATUS_READY;
    1002:	10 92 41 38 	sts	0x3841, r1	; 0x803841 <master_trans_status>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:571
  twi_mode = TWI_MODE_MASTER;
    1006:	81 e0       	ldi	r24, 0x01	; 1
    1008:	31 c0       	rjmp	.+98     	; 0x106c <__vector_25+0xe0>
TWI_MasterWriteHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:479
  /* If NOT acknowledged (NACK) by slave cancel the transaction. */
  if (TWI0.MSTATUS & TWI_RXACK_bm) {
    if (master_sendStop) {
      TWI0.MCTRLB = TWI_MCMD_STOP_gc;
    } else {
      TWI0.MCTRLB = TWI_MCMD_REPSTART_gc;
    100a:	81 e0       	ldi	r24, 0x01	; 1
    100c:	f5 cf       	rjmp	.-22     	; 0xff8 <__vector_25+0x6c>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:486
    }
    TWI_MasterTransactionFinished(TWIM_RESULT_NACK_RECEIVED);
  }

  /* If more bytes to write, send data. */
  else if (master_bytesWritten < bytesToWrite) {
    100e:	80 91 3b 38 	lds	r24, 0x383B	; 0x80383b <master_bytesWritten>
    1012:	82 17       	cp	r24, r18
    1014:	90 f4       	brcc	.+36     	; 0x103a <__vector_25+0xae>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:487
    uint8_t data = master_writeData[master_bytesWritten];
    1016:	e0 91 3b 38 	lds	r30, 0x383B	; 0x80383b <master_bytesWritten>
    101a:	80 91 39 38 	lds	r24, 0x3839	; 0x803839 <master_writeData>
    101e:	90 91 3a 38 	lds	r25, 0x383A	; 0x80383a <master_writeData+0x1>
    1022:	e8 0f       	add	r30, r24
    1024:	f9 2f       	mov	r31, r25
    1026:	f1 1d       	adc	r31, r1
    1028:	80 81       	ld	r24, Z
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:488
    TWI0.MDATA = data;
    102a:	80 93 18 08 	sts	0x0818, r24	; 0x800818 <vtable for SSD1306Device+0x7f6ed4>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:489
    master_bytesWritten++;
    102e:	80 91 3b 38 	lds	r24, 0x383B	; 0x80383b <master_bytesWritten>
    1032:	8f 5f       	subi	r24, 0xFF	; 255
    1034:	80 93 3b 38 	sts	0x383B, r24	; 0x80383b <master_bytesWritten>
    1038:	c6 cf       	rjmp	.-116    	; 0xfc6 <__vector_25+0x3a>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:495
  }

  /* If bytes to read, send START condition + Address +
     'R/_W = 1'
  */
  else if (master_bytesRead < bytesToRead) {
    103a:	80 91 3f 38 	lds	r24, 0x383F	; 0x80383f <master_bytesRead>
    103e:	89 17       	cp	r24, r25
    1040:	48 f4       	brcc	.+18     	; 0x1054 <__vector_25+0xc8>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:496
    twi_mode = TWI_MODE_MASTER_RECEIVE;
    1042:	84 e0       	ldi	r24, 0x04	; 4
    1044:	80 93 40 38 	sts	0x3840, r24	; 0x803840 <twi_mode>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:497
    uint8_t readAddress = ADD_READ_BIT(master_slaveAddress);
    1048:	80 91 38 38 	lds	r24, 0x3838	; 0x803838 <master_slaveAddress>
    104c:	81 60       	ori	r24, 0x01	; 1
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:498
    TWI0.MADDR = readAddress;
    104e:	80 93 17 08 	sts	0x0817, r24	; 0x800817 <vtable for SSD1306Device+0x7f6ed3>
    1052:	b9 cf       	rjmp	.-142    	; 0xfc6 <__vector_25+0x3a>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:503
  }

  /* If transaction finished, send ACK/STOP condition if instructed and set RESULT OK. */
  else {
    if (master_sendStop) {
    1054:	80 91 3d 38 	lds	r24, 0x383D	; 0x80383d <master_sendStop>
    1058:	88 23       	and	r24, r24
    105a:	59 f0       	breq	.+22     	; 0x1072 <__vector_25+0xe6>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:504
      TWI0.MCTRLB = TWI_MCMD_STOP_gc;
    105c:	83 e0       	ldi	r24, 0x03	; 3
TWI_MasterReadHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:554
  /* If transaction finished, issue NACK and STOP condition if instructed. */
  else {
    if (master_sendStop) {
      TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_STOP_gc;
    } else {
      TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_REPSTART_gc;
    105e:	80 93 14 08 	sts	0x0814, r24	; 0x800814 <vtable for SSD1306Device+0x7f6ed0>
TWI_MasterTransactionFinished():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:569
    Prepares module for new transaction.

    \param result  The result of the operation.
*/
void TWI_MasterTransactionFinished(uint8_t result) {
  master_result = result;
    1062:	81 e0       	ldi	r24, 0x01	; 1
    1064:	80 93 42 38 	sts	0x3842, r24	; 0x803842 <master_result>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:570
  master_trans_status = TWIM_STATUS_READY;
    1068:	10 92 41 38 	sts	0x3841, r1	; 0x803841 <master_trans_status>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:571
  twi_mode = TWI_MODE_MASTER;
    106c:	80 93 40 38 	sts	0x3840, r24	; 0x803840 <twi_mode>
    1070:	aa cf       	rjmp	.-172    	; 0xfc6 <__vector_25+0x3a>
TWI_MasterWriteHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:506
  /* If transaction finished, send ACK/STOP condition if instructed and set RESULT OK. */
  else {
    if (master_sendStop) {
      TWI0.MCTRLB = TWI_MCMD_STOP_gc;
    } else {
      TWI0.MCTRLB = TWI_MCMD_REPSTART_gc;
    1072:	81 e0       	ldi	r24, 0x01	; 1
    1074:	f4 cf       	rjmp	.-24     	; 0x105e <__vector_25+0xd2>
TWI_MasterInterruptHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:428
  else if (currentStatus & TWI_WIF_bm) {
    TWI_MasterWriteHandler();
  }

  /* If master read interrupt. */
  else if (currentStatus & TWI_RIF_bm) {
    1076:	87 ff       	sbrs	r24, 7
    1078:	37 c0       	rjmp	.+110    	; 0x10e8 <__vector_25+0x15c>
TWI_MasterReadHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:522

    \param twi The TWI_Master_t struct instance.
*/
void TWI_MasterReadHandler() {
  /* Fetch data if bytes to be read. */
  if (master_bytesRead < master_bytesToRead) {
    107a:	90 91 3f 38 	lds	r25, 0x383F	; 0x80383f <master_bytesRead>
    107e:	80 91 3e 38 	lds	r24, 0x383E	; 0x80383e <master_bytesToRead>
    1082:	98 17       	cp	r25, r24
    1084:	a8 f4       	brcc	.+42     	; 0x10b0 <__vector_25+0x124>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:523
    uint8_t data = TWI0.MDATA;
    1086:	80 91 18 08 	lds	r24, 0x0818	; 0x800818 <vtable for SSD1306Device+0x7f6ed4>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:524
    master_readData[master_bytesRead] = data;
    108a:	e0 91 3f 38 	lds	r30, 0x383F	; 0x80383f <master_bytesRead>
    108e:	f0 e0       	ldi	r31, 0x00	; 0
    1090:	80 83       	st	Z, r24
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:525
    master_bytesRead++;
    1092:	80 91 3f 38 	lds	r24, 0x383F	; 0x80383f <master_bytesRead>
    1096:	8f 5f       	subi	r24, 0xFF	; 255
    1098:	80 93 3f 38 	sts	0x383F, r24	; 0x80383f <master_bytesRead>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:542
    master_bytesToRead = 0;
    return;
  }

  /* Local variable used in if test to avoid compiler warning. */
  uint8_t bytesToRead = master_bytesToRead;
    109c:	90 91 3e 38 	lds	r25, 0x383E	; 0x80383e <master_bytesToRead>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:545

  /* If more bytes to read, issue ACK and start a byte read. */
  if (master_bytesRead < bytesToRead) {
    10a0:	80 91 3f 38 	lds	r24, 0x383F	; 0x80383f <master_bytesRead>
    10a4:	89 17       	cp	r24, r25
    10a6:	c0 f4       	brcc	.+48     	; 0x10d8 <__vector_25+0x14c>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:546
    TWI0.MCTRLB = TWI_MCMD_RECVTRANS_gc;
    10a8:	82 e0       	ldi	r24, 0x02	; 2
    10aa:	80 93 14 08 	sts	0x0814, r24	; 0x800814 <vtable for SSD1306Device+0x7f6ed0>
    10ae:	8b cf       	rjmp	.-234    	; 0xfc6 <__vector_25+0x3a>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:530
    master_bytesRead++;
  }

  /* If buffer overflow, issue NACK/STOP and BUFFER_OVERFLOW condition. */
  else {
    if (master_sendStop) {
    10b0:	80 91 3d 38 	lds	r24, 0x383D	; 0x80383d <master_sendStop>
    10b4:	88 23       	and	r24, r24
    10b6:	71 f0       	breq	.+28     	; 0x10d4 <__vector_25+0x148>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:531
      TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_STOP_gc;
    10b8:	87 e0       	ldi	r24, 0x07	; 7
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:533
    } else {
      TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_REPSTART_gc;
    10ba:	80 93 14 08 	sts	0x0814, r24	; 0x800814 <vtable for SSD1306Device+0x7f6ed0>
TWI_MasterTransactionFinished():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:569
    Prepares module for new transaction.

    \param result  The result of the operation.
*/
void TWI_MasterTransactionFinished(uint8_t result) {
  master_result = result;
    10be:	82 e0       	ldi	r24, 0x02	; 2
    10c0:	80 93 42 38 	sts	0x3842, r24	; 0x803842 <master_result>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:570
  master_trans_status = TWIM_STATUS_READY;
    10c4:	10 92 41 38 	sts	0x3841, r1	; 0x803841 <master_trans_status>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:571
  twi_mode = TWI_MODE_MASTER;
    10c8:	81 e0       	ldi	r24, 0x01	; 1
    10ca:	80 93 40 38 	sts	0x3840, r24	; 0x803840 <twi_mode>
TWI_MasterReadHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:537
    } else {
      TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_REPSTART_gc;
    }

    TWI_MasterTransactionFinished(TWIM_RESULT_BUFFER_OVERFLOW);
    master_bytesToRead = 0;
    10ce:	10 92 3e 38 	sts	0x383E, r1	; 0x80383e <master_bytesToRead>
    10d2:	79 cf       	rjmp	.-270    	; 0xfc6 <__vector_25+0x3a>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:533
  /* If buffer overflow, issue NACK/STOP and BUFFER_OVERFLOW condition. */
  else {
    if (master_sendStop) {
      TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_STOP_gc;
    } else {
      TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_REPSTART_gc;
    10d4:	85 e0       	ldi	r24, 0x05	; 5
    10d6:	f1 cf       	rjmp	.-30     	; 0x10ba <__vector_25+0x12e>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:551
    TWI0.MCTRLB = TWI_MCMD_RECVTRANS_gc;
  }

  /* If transaction finished, issue NACK and STOP condition if instructed. */
  else {
    if (master_sendStop) {
    10d8:	80 91 3d 38 	lds	r24, 0x383D	; 0x80383d <master_sendStop>
    10dc:	88 23       	and	r24, r24
    10de:	11 f0       	breq	.+4      	; 0x10e4 <__vector_25+0x158>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:552
      TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_STOP_gc;
    10e0:	87 e0       	ldi	r24, 0x07	; 7
    10e2:	bd cf       	rjmp	.-134    	; 0x105e <__vector_25+0xd2>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:554
    } else {
      TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_REPSTART_gc;
    10e4:	85 e0       	ldi	r24, 0x05	; 5
    10e6:	bb cf       	rjmp	.-138    	; 0x105e <__vector_25+0xd2>
TWI_MasterTransactionFinished():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:569
    Prepares module for new transaction.

    \param result  The result of the operation.
*/
void TWI_MasterTransactionFinished(uint8_t result) {
  master_result = result;
    10e8:	86 e0       	ldi	r24, 0x06	; 6
    10ea:	89 cf       	rjmp	.-238    	; 0xffe <__vector_25+0x72>

000010ec <__vector_8>:
__vector_8():
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:259
    }

    return delta;
}

ISR(TCA0_OVF_vect) {
    10ec:	1f 92       	push	r1
    10ee:	0f 92       	push	r0
    10f0:	0f b6       	in	r0, 0x3f	; 63
    10f2:	0f 92       	push	r0
    10f4:	11 24       	eor	r1, r1
    10f6:	cf 92       	push	r12
    10f8:	df 92       	push	r13
    10fa:	ef 92       	push	r14
    10fc:	ff 92       	push	r15
    10fe:	0f 93       	push	r16
    1100:	1f 93       	push	r17
    1102:	2f 93       	push	r18
    1104:	3f 93       	push	r19
    1106:	4f 93       	push	r20
    1108:	5f 93       	push	r21
    110a:	6f 93       	push	r22
    110c:	7f 93       	push	r23
    110e:	8f 93       	push	r24
    1110:	9f 93       	push	r25
    1112:	af 93       	push	r26
    1114:	bf 93       	push	r27
    1116:	ef 93       	push	r30
    1118:	ff 93       	push	r31
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:263

    //digitalWriteFast(LED_PIN, true);

    ++tick;
    111a:	80 91 59 38 	lds	r24, 0x3859	; 0x803859 <tick>
    111e:	90 91 5a 38 	lds	r25, 0x385A	; 0x80385a <tick+0x1>
    1122:	a0 91 5b 38 	lds	r26, 0x385B	; 0x80385b <tick+0x2>
    1126:	b0 91 5c 38 	lds	r27, 0x385C	; 0x80385c <tick+0x3>
    112a:	01 96       	adiw	r24, 0x01	; 1
    112c:	a1 1d       	adc	r26, r1
    112e:	b1 1d       	adc	r27, r1
    1130:	80 93 59 38 	sts	0x3859, r24	; 0x803859 <tick>
    1134:	90 93 5a 38 	sts	0x385A, r25	; 0x80385a <tick+0x1>
    1138:	a0 93 5b 38 	sts	0x385B, r26	; 0x80385b <tick+0x2>
    113c:	b0 93 5c 38 	sts	0x385C, r27	; 0x80385c <tick+0x3>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:265

    if (jump == -1) {
    1140:	80 91 61 38 	lds	r24, 0x3861	; 0x803861 <jump>
    1144:	90 91 62 38 	lds	r25, 0x3862	; 0x803862 <jump+0x1>
    1148:	a0 91 63 38 	lds	r26, 0x3863	; 0x803863 <jump+0x2>
    114c:	b0 91 64 38 	lds	r27, 0x3864	; 0x803864 <jump+0x3>
    1150:	8f 3f       	cpi	r24, 0xFF	; 255
    1152:	9f 4f       	sbci	r25, 0xFF	; 255
    1154:	af 4f       	sbci	r26, 0xFF	; 255
    1156:	bf 4f       	sbci	r27, 0xFF	; 255
    1158:	09 f0       	breq	.+2      	; 0x115c <__vector_8+0x70>
    115a:	69 c0       	rjmp	.+210    	; 0x122e <__vector_8+0x142>
digitalWriteFast():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:294
    vport->OUT &= ~mask;
  else // CHANGE
    vport->IN = mask;
*/
  if (val == LOW)
    vport->OUT &= ~mask;
    115c:	0d 98       	cbi	0x01, 5	; 1
__vector_8():
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:273
    else {
        digitalWriteFast(ENABLE_PIN, true); // on before next sample
    }

    // write the previously calculated sample first so the timing is reliable no matter how long it takes to calculate the next sample
    analogWrite(DAC_PIN, sample);
    115e:	10 91 04 38 	lds	r17, 0x3804	; 0x803804 <sample>
analogWrite():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_analog.c:217
  uint8_t bit_mask  = digitalPinToBitMask(pin);
  if (bit_mask == NOT_A_PIN) {
    return;
  }
  // Set pin output because that's what Arduino does
  pinMode(pin, OUTPUT);
    1162:	61 e0       	ldi	r22, 0x01	; 1
    1164:	82 e0       	ldi	r24, 0x02	; 2
    1166:	0e 94 9e 06 	call	0xd3c	; 0xd3c <pinMode>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_analog.c:263
      // End of TCA case

  #if defined(DAC0)
    case DACOUT:
    {
      DAC0.DATA = val;
    116a:	10 93 a1 06 	sts	0x06A1, r17	; 0x8006a1 <vtable for SSD1306Device+0x7f6d5d>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_analog.c:264
      DAC0.CTRLA = 0x41; //OUTEN=1, ENABLE=1
    116e:	81 e4       	ldi	r24, 0x41	; 65
    1170:	80 93 a0 06 	sts	0x06A0, r24	; 0x8006a0 <vtable for SSD1306Device+0x7f6d5c>
nextSample():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/waveforms.cpp:55

uint8_t nextSample() {

    uint8_t sample;

    if (jump == -1) {
    1174:	80 91 61 38 	lds	r24, 0x3861	; 0x803861 <jump>
    1178:	90 91 62 38 	lds	r25, 0x3862	; 0x803862 <jump+0x1>
    117c:	a0 91 63 38 	lds	r26, 0x3863	; 0x803863 <jump+0x2>
    1180:	b0 91 64 38 	lds	r27, 0x3864	; 0x803864 <jump+0x3>
    1184:	8f 3f       	cpi	r24, 0xFF	; 255
    1186:	9f 4f       	sbci	r25, 0xFF	; 255
    1188:	af 4f       	sbci	r26, 0xFF	; 255
    118a:	bf 4f       	sbci	r27, 0xFF	; 255
    118c:	09 f4       	brne	.+2      	; 0x1190 <__vector_8+0xa4>
    118e:	91 c0       	rjmp	.+290    	; 0x12b2 <__vector_8+0x1c6>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/waveforms.cpp:59
        sample = 127; // middle value
    }
    else {
        phase = phase + jump;
    1190:	00 91 61 38 	lds	r16, 0x3861	; 0x803861 <jump>
    1194:	10 91 62 38 	lds	r17, 0x3862	; 0x803862 <jump+0x1>
    1198:	20 91 63 38 	lds	r18, 0x3863	; 0x803863 <jump+0x2>
    119c:	30 91 64 38 	lds	r19, 0x3864	; 0x803864 <jump+0x3>
    11a0:	80 91 0e 38 	lds	r24, 0x380E	; 0x80380e <phase>
    11a4:	90 91 0f 38 	lds	r25, 0x380F	; 0x80380f <phase+0x1>
    11a8:	a0 91 10 38 	lds	r26, 0x3810	; 0x803810 <phase+0x2>
    11ac:	b0 91 11 38 	lds	r27, 0x3811	; 0x803811 <phase+0x3>
    11b0:	08 0f       	add	r16, r24
    11b2:	19 1f       	adc	r17, r25
    11b4:	2a 1f       	adc	r18, r26
    11b6:	3b 1f       	adc	r19, r27
    11b8:	00 93 0e 38 	sts	0x380E, r16	; 0x80380e <phase>
    11bc:	10 93 0f 38 	sts	0x380F, r17	; 0x80380f <phase+0x1>
    11c0:	20 93 10 38 	sts	0x3810, r18	; 0x803810 <phase+0x2>
    11c4:	30 93 11 38 	sts	0x3811, r19	; 0x803811 <phase+0x3>
pulseSample():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/waveforms.cpp:14
int32_t pulseAmount = 42949;

uint8_t pulseSample() {

    // forwards/backwards
    if (pulseAmount > 0) {
    11c8:	80 91 00 38 	lds	r24, 0x3800	; 0x803800 <__DATA_REGION_ORIGIN__>
    11cc:	90 91 01 38 	lds	r25, 0x3801	; 0x803801 <__DATA_REGION_ORIGIN__+0x1>
    11d0:	a0 91 02 38 	lds	r26, 0x3802	; 0x803802 <__DATA_REGION_ORIGIN__+0x2>
    11d4:	b0 91 03 38 	lds	r27, 0x3803	; 0x803803 <__DATA_REGION_ORIGIN__+0x3>
    11d8:	40 91 0a 38 	lds	r20, 0x380A	; 0x80380a <pulse>
    11dc:	50 91 0b 38 	lds	r21, 0x380B	; 0x80380b <pulse+0x1>
    11e0:	60 91 0c 38 	lds	r22, 0x380C	; 0x80380c <pulse+0x2>
    11e4:	70 91 0d 38 	lds	r23, 0x380D	; 0x80380d <pulse+0x3>
    11e8:	6c 01       	movw	r12, r24
    11ea:	7d 01       	movw	r14, r26
    11ec:	c4 0e       	add	r12, r20
    11ee:	d5 1e       	adc	r13, r21
    11f0:	e6 1e       	adc	r14, r22
    11f2:	f7 1e       	adc	r15, r23
    11f4:	18 16       	cp	r1, r24
    11f6:	19 06       	cpc	r1, r25
    11f8:	1a 06       	cpc	r1, r26
    11fa:	1b 06       	cpc	r1, r27
    11fc:	d4 f4       	brge	.+52     	; 0x1232 <__vector_8+0x146>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/waveforms.cpp:15
        if (pulse + pulseAmount > MAX_PULSE) {
    11fe:	e8 e6       	ldi	r30, 0x68	; 104
    1200:	ce 16       	cp	r12, r30
    1202:	e6 e6       	ldi	r30, 0x66	; 102
    1204:	de 06       	cpc	r13, r30
    1206:	ee 06       	cpc	r14, r30
    1208:	e6 ee       	ldi	r30, 0xE6	; 230
    120a:	fe 06       	cpc	r15, r30
    120c:	c8 f0       	brcs	.+50     	; 0x1240 <__vector_8+0x154>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/waveforms.cpp:21
            pulseAmount = -pulseAmount;
        }
    }
    else  {
        if (pulse + pulseAmount < MIN_PULSE) {
            pulseAmount = -pulseAmount;
    120e:	b0 95       	com	r27
    1210:	a0 95       	com	r26
    1212:	90 95       	com	r25
    1214:	81 95       	neg	r24
    1216:	9f 4f       	sbci	r25, 0xFF	; 255
    1218:	af 4f       	sbci	r26, 0xFF	; 255
    121a:	bf 4f       	sbci	r27, 0xFF	; 255
    121c:	80 93 00 38 	sts	0x3800, r24	; 0x803800 <__DATA_REGION_ORIGIN__>
    1220:	90 93 01 38 	sts	0x3801, r25	; 0x803801 <__DATA_REGION_ORIGIN__+0x1>
    1224:	a0 93 02 38 	sts	0x3802, r26	; 0x803802 <__DATA_REGION_ORIGIN__+0x2>
    1228:	b0 93 03 38 	sts	0x3803, r27	; 0x803803 <__DATA_REGION_ORIGIN__+0x3>
    122c:	09 c0       	rjmp	.+18     	; 0x1240 <__vector_8+0x154>
digitalWriteFast():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:298
  else if (val == CHANGE)
    vport->IN  |= mask;
  else // HIGH
    vport->OUT |= mask;
    122e:	0d 9a       	sbi	0x01, 5	; 1
    1230:	96 cf       	rjmp	.-212    	; 0x115e <__vector_8+0x72>
pulseSample():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/waveforms.cpp:20
        if (pulse + pulseAmount > MAX_PULSE) {
            pulseAmount = -pulseAmount;
        }
    }
    else  {
        if (pulse + pulseAmount < MIN_PULSE) {
    1232:	e9 e9       	ldi	r30, 0x99	; 153
    1234:	ce 16       	cp	r12, r30
    1236:	de 06       	cpc	r13, r30
    1238:	ee 06       	cpc	r14, r30
    123a:	e9 e1       	ldi	r30, 0x19	; 25
    123c:	fe 06       	cpc	r15, r30
    123e:	38 f3       	brcs	.-50     	; 0x120e <__vector_8+0x122>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/waveforms.cpp:26
            pulseAmount = -pulseAmount;
        }
    }

    // TODO: this will drift because the last one won't make it to the end before bouncing back
    pulse += pulseAmount;
    1240:	80 91 00 38 	lds	r24, 0x3800	; 0x803800 <__DATA_REGION_ORIGIN__>
    1244:	90 91 01 38 	lds	r25, 0x3801	; 0x803801 <__DATA_REGION_ORIGIN__+0x1>
    1248:	a0 91 02 38 	lds	r26, 0x3802	; 0x803802 <__DATA_REGION_ORIGIN__+0x2>
    124c:	b0 91 03 38 	lds	r27, 0x3803	; 0x803803 <__DATA_REGION_ORIGIN__+0x3>
    1250:	84 0f       	add	r24, r20
    1252:	95 1f       	adc	r25, r21
    1254:	a6 1f       	adc	r26, r22
    1256:	b7 1f       	adc	r27, r23
    1258:	80 93 0a 38 	sts	0x380A, r24	; 0x80380a <pulse>
    125c:	90 93 0b 38 	sts	0x380B, r25	; 0x80380b <pulse+0x1>
    1260:	a0 93 0c 38 	sts	0x380C, r26	; 0x80380c <pulse+0x2>
    1264:	b0 93 0d 38 	sts	0x380D, r27	; 0x80380d <pulse+0x3>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/waveforms.cpp:29

    // funny how we're using a DAC and right now we're only using it to make a square wave :)
    if (phase < pulse) {
    1268:	41 e0       	ldi	r20, 0x01	; 1
    126a:	08 17       	cp	r16, r24
    126c:	19 07       	cpc	r17, r25
    126e:	2a 07       	cpc	r18, r26
    1270:	3b 07       	cpc	r19, r27
    1272:	08 f0       	brcs	.+2      	; 0x1276 <__vector_8+0x18a>
    1274:	40 e0       	ldi	r20, 0x00	; 0
    1276:	84 2f       	mov	r24, r20
    1278:	81 95       	neg	r24
__vector_8():
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:276

    // calculate the sample for next time
    sample = nextSample();
    127a:	80 93 04 38 	sts	0x3804, r24	; 0x803804 <sample>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:281

    //digitalWriteFast(LED_PIN, false);

    // The interrupt flag has to be cleared manually
    TCA0.SINGLE.INTFLAGS = TCA_SINGLE_OVF_bm;
    127e:	81 e0       	ldi	r24, 0x01	; 1
    1280:	80 93 0b 0a 	sts	0x0A0B, r24	; 0x800a0b <vtable for SSD1306Device+0x7f70c7>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:282
}
    1284:	ff 91       	pop	r31
    1286:	ef 91       	pop	r30
    1288:	bf 91       	pop	r27
    128a:	af 91       	pop	r26
    128c:	9f 91       	pop	r25
    128e:	8f 91       	pop	r24
    1290:	7f 91       	pop	r23
    1292:	6f 91       	pop	r22
    1294:	5f 91       	pop	r21
    1296:	4f 91       	pop	r20
    1298:	3f 91       	pop	r19
    129a:	2f 91       	pop	r18
    129c:	1f 91       	pop	r17
    129e:	0f 91       	pop	r16
    12a0:	ff 90       	pop	r15
    12a2:	ef 90       	pop	r14
    12a4:	df 90       	pop	r13
    12a6:	cf 90       	pop	r12
    12a8:	0f 90       	pop	r0
    12aa:	0f be       	out	0x3f, r0	; 63
    12ac:	0f 90       	pop	r0
    12ae:	1f 90       	pop	r1
    12b0:	18 95       	reti
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/waveforms.cpp:56
uint8_t nextSample() {

    uint8_t sample;

    if (jump == -1) {
        sample = 127; // middle value
    12b2:	8f e7       	ldi	r24, 0x7F	; 127
    12b4:	e2 cf       	rjmp	.-60     	; 0x127a <__vector_8+0x18e>

000012b6 <global constructors keyed to 65535_0_minor_1.ino.cpp.o.2975>:
_GLOBAL__I_65535_0_minor_1.ino.cpp.o.2975():
    12b6:	ee e6       	ldi	r30, 0x6E	; 110
    12b8:	f8 e3       	ldi	r31, 0x38	; 56
    12ba:	12 82       	std	Z+2, r1	; 0x02
    12bc:	13 82       	std	Z+3, r1	; 0x03
    12be:	88 ee       	ldi	r24, 0xE8	; 232
    12c0:	93 e0       	ldi	r25, 0x03	; 3
    12c2:	a0 e0       	ldi	r26, 0x00	; 0
    12c4:	b0 e0       	ldi	r27, 0x00	; 0
    12c6:	84 83       	std	Z+4, r24	; 0x04
    12c8:	95 83       	std	Z+5, r25	; 0x05
    12ca:	a6 83       	std	Z+6, r26	; 0x06
    12cc:	b7 83       	std	Z+7, r27	; 0x07
    12ce:	88 e3       	ldi	r24, 0x38	; 56
    12d0:	99 e9       	ldi	r25, 0x99	; 153
    12d2:	80 83       	st	Z, r24
    12d4:	91 83       	std	Z+1, r25	; 0x01
    12d6:	e2 e8       	ldi	r30, 0x82	; 130
    12d8:	f8 e3       	ldi	r31, 0x38	; 56
    12da:	12 82       	std	Z+2, r1	; 0x02
    12dc:	13 82       	std	Z+3, r1	; 0x03
    12de:	88 e4       	ldi	r24, 0x48	; 72
    12e0:	99 e9       	ldi	r25, 0x99	; 153
    12e2:	80 83       	st	Z, r24
    12e4:	91 83       	std	Z+1, r25	; 0x01
    12e6:	80 ee       	ldi	r24, 0xE0	; 224
    12e8:	95 e0       	ldi	r25, 0x05	; 5
    12ea:	80 93 80 38 	sts	0x3880, r24	; 0x803880 <wireBeginFn>
    12ee:	90 93 81 38 	sts	0x3881, r25	; 0x803881 <wireBeginFn+0x1>
    12f2:	80 e7       	ldi	r24, 0x70	; 112
    12f4:	95 e0       	ldi	r25, 0x05	; 5
    12f6:	80 93 7e 38 	sts	0x387E, r24	; 0x80387e <wireBeginTransmissionFn>
    12fa:	90 93 7f 38 	sts	0x387F, r25	; 0x80387f <wireBeginTransmissionFn+0x1>
    12fe:	8e e5       	ldi	r24, 0x5E	; 94
    1300:	94 e0       	ldi	r25, 0x04	; 4
    1302:	80 93 7c 38 	sts	0x387C, r24	; 0x80387c <wireWriteFn>
    1306:	90 93 7d 38 	sts	0x387D, r25	; 0x80387d <wireWriteFn+0x1>
    130a:	89 e7       	ldi	r24, 0x79	; 121
    130c:	95 e0       	ldi	r25, 0x05	; 5
    130e:	80 93 7a 38 	sts	0x387A, r24	; 0x80387a <wireEndTransmissionFn>
    1312:	90 93 7b 38 	sts	0x387B, r25	; 0x80387b <wireEndTransmissionFn+0x1>
    1316:	08 95       	ret

00001318 <main>:
init():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:601

  /******************************** CLOCK STUFF *********************************/
  #if (CLOCK_SOURCE==0)
  #if (F_CPU == 20000000)
  /* No division on clock */
  _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, 0x00);
    1318:	88 ed       	ldi	r24, 0xD8	; 216
    131a:	90 e0       	ldi	r25, 0x00	; 0
    131c:	84 bf       	out	0x34, r24	; 52
    131e:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <vtable for SSD1306Device+0x7f671d>
init_ADC0():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:669
    be connected to the pin for longer, though the datasheet does not explicitly
    state that this is the case. However, we can use the SAMPLEN register to
    compensate for this! */

  #if F_CPU >= 12000000 // 16 MHz / 16 = 1 MHz,  20 MHz / 16 = 1.25 MHz
  ADC0.CTRLC = ADC_PRESC_DIV16_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;;
    1322:	83 e5       	ldi	r24, 0x53	; 83
    1324:	80 93 02 06 	sts	0x0602, r24	; 0x800602 <vtable for SSD1306Device+0x7f6cbe>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:677
  #elif F_CPU >= 3000000 // 4 MHz / 32 = 1 MHz, 5 MHz / 32 = 1.25 MHz
  ADC0.CTRLC = ADC_PRESC_DIV4_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;;
  #else  // 1 MHz / 2 = 500 kHz - the lowest setting
  ADC0.CTRLC = ADC_PRESC_DIV2_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;;
  #endif
  ADC0.SAMPCTRL = 14; //16 ADC clock sampling time - should be about the same amount of *time* as originally?
    1328:	8e e0       	ldi	r24, 0x0E	; 14
    132a:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <vtable for SSD1306Device+0x7f6cc1>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:694
  ADC0.CTRLC = ADC_PRESC_DIV8_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;;
  #else // 128 kHz / 2 = 64 kHz -> This is the closest you can get, the prescaler is 2
  ADC0.CTRLC = ADC_PRESC_DIV2_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;;
  #endif
  #endif
  ADC0.CTRLD = ADC_INITDLY_DLY16_gc;
    132e:	80 e2       	ldi	r24, 0x20	; 32
    1330:	80 93 03 06 	sts	0x0603, r24	; 0x800603 <vtable for SSD1306Device+0x7f6cbf>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:696
  /* Enable ADC */
  ADC0.CTRLA |= ADC_ENABLE_bm;
    1334:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <vtable for SSD1306Device+0x7f6cbc>
    1338:	81 60       	ori	r24, 0x01	; 1
    133a:	80 93 00 06 	sts	0x0600, r24	; 0x800600 <vtable for SSD1306Device+0x7f6cbc>
init_TCA0():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:776

  /* PORTMUX setting for TCA - don't need to set because using default */
  //PORTMUX.CTRLA = PORTMUX_TCA00_DEFAULT_gc;

  /* Enable Split Mode */
  TCA0.SPLIT.CTRLD = TCA_SPLIT_SPLITM_bm;
    133e:	81 e0       	ldi	r24, 0x01	; 1
    1340:	80 93 03 0a 	sts	0x0A03, r24	; 0x800a03 <vtable for SSD1306Device+0x7f70bf>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:781

  //Only 1 WGM so no need to specifically set up.

  /* Period setting, 8-bit register in SPLIT mode */
  TCA0.SPLIT.LPER    = PWM_TIMER_PERIOD;
    1344:	9e ef       	ldi	r25, 0xFE	; 254
    1346:	90 93 26 0a 	sts	0x0A26, r25	; 0x800a26 <vtable for SSD1306Device+0x7f70e2>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:782
  TCA0.SPLIT.HPER    = PWM_TIMER_PERIOD;
    134a:	90 93 27 0a 	sts	0x0A27, r25	; 0x800a27 <vtable for SSD1306Device+0x7f70e3>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:799

  /* Use prescale appropriate for system clock speed */
  #if (F_CPU > 25000000) //   use 256 divider when clocked over 25 MHz - probably not terribly relevant - though they might be viable at 30 or 32, and are viable at 24/25 MHz.
    TCA0.SPLIT.CTRLA   = (TCA_SPLIT_CLKSEL_DIV256_gc) | (TCA_SPLIT_ENABLE_bm);
  #elif (F_CPU > 5000000) //  use 64 divider
    TCA0.SPLIT.CTRLA   =  (TCA_SPLIT_CLKSEL_DIV64_gc) | (TCA_SPLIT_ENABLE_bm);
    134e:	9b e0       	ldi	r25, 0x0B	; 11
    1350:	90 93 00 0a 	sts	0x0A00, r25	; 0x800a00 <vtable for SSD1306Device+0x7f70bc>
init_millis():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:541
    #if defined(MILLIS_USE_TIMERA0)
      TCA0.SPLIT.INTCTRL |= TCA_SPLIT_HUNF_bm;
    #elif defined(MILLIS_USE_TIMERA1)
      TCA1.SPLIT.INTCTRL |= TCA_SPLIT_HUNF_bm;
    #elif defined(MILLIS_USE_TIMERD0)
      TCD0.CMPBCLR        = TIME_TRACKING_TIMER_PERIOD; //essentially, this is TOP
    1354:	2d ef       	ldi	r18, 0xFD	; 253
    1356:	31 e0       	ldi	r19, 0x01	; 1
    1358:	20 93 ae 0a 	sts	0x0AAE, r18	; 0x800aae <vtable for SSD1306Device+0x7f716a>
    135c:	30 93 af 0a 	sts	0x0AAF, r19	; 0x800aaf <vtable for SSD1306Device+0x7f716b>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:542
      TCD0.INTCTRL        = 0x01;//enable interrupt
    1360:	80 93 8c 0a 	sts	0x0A8C, r24	; 0x800a8c <vtable for SSD1306Device+0x7f7148>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:543
      TCD0.CTRLB          = 0x00; //oneramp mode
    1364:	10 92 81 0a 	sts	0x0A81, r1	; 0x800a81 <vtable for SSD1306Device+0x7f713d>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:544
      TCD0.CTRLC          = 0x80;
    1368:	90 e8       	ldi	r25, 0x80	; 128
    136a:	90 93 82 0a 	sts	0x0A82, r25	; 0x800a82 <vtable for SSD1306Device+0x7f713e>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:545
      TCD0.CTRLA          = TIMERD0_PRESCALER | 0x01; //set clock source and enable!
    136e:	91 e1       	ldi	r25, 0x11	; 17
    1370:	90 93 80 0a 	sts	0x0A80, r25	; 0x800a80 <vtable for SSD1306Device+0x7f713c>
init():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:651
  #ifndef MILLIS_USE_TIMERNONE
  init_millis();
  #endif //end #ifndef MILLIS_USE_TIMERNONE
  /*************************** ENABLE GLOBAL INTERRUPTS *************************/

  sei();
    1374:	78 94       	sei
DACReference():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_analog.c:134

#ifdef DAC0
void DACReference(uint8_t mode) {
  check_valid_dac_ref(mode);
  if (mode < 5) {
    VREF.CTRLA = mode | (VREF.CTRLA & (~VREF_DAC0REFSEL_gm));
    1376:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <vtable for SSD1306Device+0x7f675c>
    137a:	98 7f       	andi	r25, 0xF8	; 248
    137c:	90 93 a0 00 	sts	0x00A0, r25	; 0x8000a0 <vtable for SSD1306Device+0x7f675c>
setup():
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:50

    DACReference(INTERNAL0V55);

    // setup a timer overflow interrupt to fire at 25khz
    // system clock is 20Mhz. Prescaler is 16. Period is 49 (so it will be 49+1 = 50)
    TCA0.SINGLE.INTCTRL = 0 << TCA_SINGLE_CMP0_bp   /* Compare 0 Interrupt: disabled */
    1380:	80 93 0a 0a 	sts	0x0A0A, r24	; 0x800a0a <vtable for SSD1306Device+0x7f70c6>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:55
                          | 0 << TCA_SINGLE_CMP1_bp /* Compare 1 Interrupt: disabled */
                          | 0 << TCA_SINGLE_CMP2_bp /* Compare 2 Interrupt: disabled */
                          | 1 << TCA_SINGLE_OVF_bp; /* Overflow Interrupt: enabled */

    TCA0.SINGLE.PER = 49; /* 49 + 1 == 50 */
    1384:	81 e3       	ldi	r24, 0x31	; 49
    1386:	90 e0       	ldi	r25, 0x00	; 0
    1388:	80 93 26 0a 	sts	0x0A26, r24	; 0x800a26 <vtable for SSD1306Device+0x7f70e2>
    138c:	90 93 27 0a 	sts	0x0A27, r25	; 0x800a27 <vtable for SSD1306Device+0x7f70e3>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:57

    TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV16_gc /* System Clock / 16 */
    1390:	89 e0       	ldi	r24, 0x09	; 9
    1392:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <vtable for SSD1306Device+0x7f70bc>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:64

    // TODO: set up the sleep stuff

    // presumably we don't have to configure DAC_PIN, KEYS_PIN, serial or i2c pins

    pinMode(LED_PIN, OUTPUT);
    1396:	61 e0       	ldi	r22, 0x01	; 1
    1398:	80 e1       	ldi	r24, 0x10	; 16
    139a:	0e 94 9e 06 	call	0xd3c	; 0xd3c <pinMode>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:65
    pinMode(DAC_PIN, OUTPUT);
    139e:	61 e0       	ldi	r22, 0x01	; 1
    13a0:	82 e0       	ldi	r24, 0x02	; 2
    13a2:	0e 94 9e 06 	call	0xd3c	; 0xd3c <pinMode>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:66
    pinMode(ENABLE_PIN, OUTPUT);
    13a6:	61 e0       	ldi	r22, 0x01	; 1
    13a8:	81 e0       	ldi	r24, 0x01	; 1
    13aa:	0e 94 9e 06 	call	0xd3c	; 0xd3c <pinMode>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:67
    pinMode(BUTTON_DOWN_PIN, INPUT_PULLUP);
    13ae:	62 e0       	ldi	r22, 0x02	; 2
    13b0:	8a e0       	ldi	r24, 0x0A	; 10
    13b2:	0e 94 9e 06 	call	0xd3c	; 0xd3c <pinMode>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:68
    pinMode(BUTTON_UP_PIN, INPUT_PULLUP);
    13b6:	62 e0       	ldi	r22, 0x02	; 2
    13b8:	8b e0       	ldi	r24, 0x0B	; 11
    13ba:	0e 94 9e 06 	call	0xd3c	; 0xd3c <pinMode>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:69
    pinMode(BUTTON_SELECT_PIN, INPUT_PULLUP);
    13be:	62 e0       	ldi	r22, 0x02	; 2
    13c0:	8c e0       	ldi	r24, 0x0C	; 12
    13c2:	0e 94 9e 06 	call	0xd3c	; 0xd3c <pinMode>
ssd1306_begin():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:35
static bool (*wireBeginTransmissionFn)(void);
static bool (*wireWriteFn)(uint8_t byte);
static uint8_t (*wireEndTransmissionFn)(void);

static void ssd1306_begin(void) {
	wireBeginFn();
    13c6:	e0 91 80 38 	lds	r30, 0x3880	; 0x803880 <wireBeginFn>
    13ca:	f0 91 81 38 	lds	r31, 0x3881	; 0x803881 <wireBeginFn+0x1>
    13ce:	09 95       	icall
begin():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:134
}

void SSD1306Device::begin(uint8_t init_sequence_length, const uint8_t init_sequence []) {
	ssd1306_begin();

	ssd1306_send_command_start();
    13d0:	0e 94 8b 04 	call	0x916	; 0x916 <ssd1306_send_command_start()>
    13d4:	cc e6       	ldi	r28, 0x6C	; 108
    13d6:	d6 e0       	ldi	r29, 0x06	; 6
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:136
	for (uint8_t i = 0; i < init_sequence_length; i++) {
		ssd1306_send_command_byte(pgm_read_byte(&init_sequence[i]));
    13d8:	fe 01       	movw	r30, r28
    13da:	14 91       	lpm	r17, Z
ssd1306_send_command_byte():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:61
	ssd1306_send_start();
	ssd1306_send_byte(SSD1306_DATA);
}

static void ssd1306_send_command_byte(uint8_t byte) {
	if (ssd1306_send_byte(byte) == 0) {
    13dc:	81 2f       	mov	r24, r17
    13de:	0e 94 6e 04 	call	0x8dc	; 0x8dc <ssd1306_send_byte(unsigned char)>
    13e2:	81 11       	cpse	r24, r1
    13e4:	07 c0       	rjmp	.+14     	; 0x13f4 <main+0xdc>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:62
		ssd1306_send_stop();
    13e6:	0e 94 69 04 	call	0x8d2	; 0x8d2 <ssd1306_send_stop()>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:63
		ssd1306_send_command_start();
    13ea:	0e 94 8b 04 	call	0x916	; 0x916 <ssd1306_send_command_start()>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:64
		ssd1306_send_byte(byte);
    13ee:	81 2f       	mov	r24, r17
    13f0:	0e 94 6e 04 	call	0x8dc	; 0x8dc <ssd1306_send_byte(unsigned char)>
    13f4:	21 96       	adiw	r28, 0x01	; 1
begin():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:135

void SSD1306Device::begin(uint8_t init_sequence_length, const uint8_t init_sequence []) {
	ssd1306_begin();

	ssd1306_send_command_start();
	for (uint8_t i = 0; i < init_sequence_length; i++) {
    13f6:	f6 e0       	ldi	r31, 0x06	; 6
    13f8:	c4 37       	cpi	r28, 0x74	; 116
    13fa:	df 07       	cpc	r29, r31
    13fc:	69 f7       	brne	.-38     	; 0x13d8 <main+0xc0>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:138
		ssd1306_send_command_byte(pgm_read_byte(&init_sequence[i]));
	}
	ssd1306_send_stop();
    13fe:	0e 94 69 04 	call	0x8d2	; 0x8d2 <ssd1306_send_stop()>
setFont():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:180
	uint8_t rotationBit = (rotation & 0x01);
	ssd1306_send_command2(0xC0 | (rotationBit << 3), 0xA0 | rotationBit);
}

void SSD1306Device::setFont(const DCfont *font) {
	oledFont = font;
    1402:	88 e9       	ldi	r24, 0x98	; 152
    1404:	97 e9       	ldi	r25, 0x97	; 151
    1406:	80 93 52 38 	sts	0x3852, r24	; 0x803852 <oledFont>
    140a:	90 93 53 38 	sts	0x3853, r25	; 0x803853 <oledFont+0x1>
clear():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:190
	oledX = x;
	oledY = y;
}

void SSD1306Device::clear(void) {
	fill(0x00);
    140e:	0e 94 b3 04 	call	0x966	; 0x966 <SSD1306Device::fill(unsigned char) [clone .constprop.18]>
switchRenderFrame():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:356
}

// Double Buffering Commands

void SSD1306Device::switchRenderFrame(void) {
	renderingFrame ^= 0x04;
    1412:	80 91 07 38 	lds	r24, 0x3807	; 0x803807 <renderingFrame>
    1416:	d4 e0       	ldi	r29, 0x04	; 4
    1418:	8d 27       	eor	r24, r29
    141a:	80 93 07 38 	sts	0x3807, r24	; 0x803807 <renderingFrame>
clear():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:190
	oledX = x;
	oledY = y;
}

void SSD1306Device::clear(void) {
	fill(0x00);
    141e:	0e 94 b3 04 	call	0x966	; 0x966 <SSD1306Device::fill(unsigned char) [clone .constprop.18]>
switchDisplayFrame():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:360
void SSD1306Device::switchRenderFrame(void) {
	renderingFrame ^= 0x04;
}

void SSD1306Device::switchDisplayFrame(void) {
	drawingFrame ^= 0x20;
    1422:	c0 91 05 38 	lds	r28, 0x3805	; 0x803805 <drawingFrame>
    1426:	80 e2       	ldi	r24, 0x20	; 32
    1428:	c8 27       	eor	r28, r24
    142a:	c0 93 05 38 	sts	0x3805, r28	; 0x803805 <drawingFrame>
ssd1306_send_command():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:77
		ssd1306_send_byte(byte^invertedOutput);
	}
}

static void ssd1306_send_command(uint8_t command) {
	ssd1306_send_command_start();
    142e:	0e 94 8b 04 	call	0x916	; 0x916 <ssd1306_send_command_start()>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:78
	ssd1306_send_byte(command);
    1432:	8c 2f       	mov	r24, r28
    1434:	0e 94 6e 04 	call	0x8dc	; 0x8dc <ssd1306_send_byte(unsigned char)>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:79
	ssd1306_send_stop();
    1438:	0e 94 69 04 	call	0x8d2	; 0x8d2 <ssd1306_send_stop()>
switchRenderFrame():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:356
}

// Double Buffering Commands

void SSD1306Device::switchRenderFrame(void) {
	renderingFrame ^= 0x04;
    143c:	80 91 07 38 	lds	r24, 0x3807	; 0x803807 <renderingFrame>
    1440:	8d 27       	eor	r24, r29
    1442:	80 93 07 38 	sts	0x3807, r24	; 0x803807 <renderingFrame>
ssd1306_send_command():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:77
		ssd1306_send_byte(byte^invertedOutput);
	}
}

static void ssd1306_send_command(uint8_t command) {
	ssd1306_send_command_start();
    1446:	0e 94 8b 04 	call	0x916	; 0x916 <ssd1306_send_command_start()>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:78
	ssd1306_send_byte(command);
    144a:	8f ea       	ldi	r24, 0xAF	; 175
    144c:	0e 94 6e 04 	call	0x8dc	; 0x8dc <ssd1306_send_byte(unsigned char)>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:79
	ssd1306_send_stop();
    1450:	0e 94 69 04 	call	0x8d2	; 0x8d2 <ssd1306_send_stop()>
checkUpDown():
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:252
    bounce = DEBOUNCE_TICKS;
    if (repeating) {
        repeat = REPEAT_TICKS2;
    }
    else {
        repeating = true;
    1454:	d1 e0       	ldi	r29, 0x01	; 1
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:249

    // This only applies if a button was pressed

    bounce = DEBOUNCE_TICKS;
    if (repeating) {
        repeat = REPEAT_TICKS2;
    1456:	30 ed       	ldi	r19, 0xD0	; 208
    1458:	63 2e       	mov	r6, r19
    145a:	37 e0       	ldi	r19, 0x07	; 7
    145c:	73 2e       	mov	r7, r19
analogRead():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_analog.c:166
    }
  }

  /* Reference should be already set up */
  /* Select channel */
  ADC0.MUXPOS = (pin << ADC_MUXPOS_gp);
    145e:	c4 e0       	ldi	r28, 0x04	; 4
loop():
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:106
        if (keyADC < 740) {
            jump = -1;
        }
    }
    else {
        jump = notes[3 + (octave * 12) + key];
    1460:	0c e0       	ldi	r16, 0x0C	; 12
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:102
    key = getKey(keyADC);

    if (key == -1) {
        // Prefer to keep the previous note if it looks like something was pressed because the most likely explanation is that two keys are held down and it is _just_ barely putting us out of range of either of them.
        if (keyADC < 740) {
            jump = -1;
    1462:	cc 24       	eor	r12, r12
    1464:	ca 94       	dec	r12
    1466:	dc 2c       	mov	r13, r12
    1468:	76 01       	movw	r14, r12
switchDisplayFrame():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:360
void SSD1306Device::switchRenderFrame(void) {
	renderingFrame ^= 0x04;
}

void SSD1306Device::switchDisplayFrame(void) {
	drawingFrame ^= 0x20;
    146a:	10 e2       	ldi	r17, 0x20	; 32
loop():
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:82
}


void loop() {

    ++frame;
    146c:	80 90 68 38 	lds	r8, 0x3868	; 0x803868 <frame>
    1470:	90 90 69 38 	lds	r9, 0x3869	; 0x803869 <frame+0x1>
    1474:	a0 90 6a 38 	lds	r10, 0x386A	; 0x80386a <frame+0x2>
    1478:	b0 90 6b 38 	lds	r11, 0x386B	; 0x80386b <frame+0x3>
    147c:	2f ef       	ldi	r18, 0xFF	; 255
    147e:	82 1a       	sub	r8, r18
    1480:	92 0a       	sbc	r9, r18
    1482:	a2 0a       	sbc	r10, r18
    1484:	b2 0a       	sbc	r11, r18
    1486:	80 92 68 38 	sts	0x3868, r8	; 0x803868 <frame>
    148a:	90 92 69 38 	sts	0x3869, r9	; 0x803869 <frame+0x1>
    148e:	a0 92 6a 38 	sts	0x386A, r10	; 0x80386a <frame+0x2>
    1492:	b0 92 6b 38 	sts	0x386B, r11	; 0x80386b <frame+0x3>
checkUpDown():
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:199


int8_t checkUpDown() {

    // tick wraps about once every 2 days :)
    if (lastTick > tick) {
    1496:	80 91 59 38 	lds	r24, 0x3859	; 0x803859 <tick>
    149a:	90 91 5a 38 	lds	r25, 0x385A	; 0x80385a <tick+0x1>
    149e:	a0 91 5b 38 	lds	r26, 0x385B	; 0x80385b <tick+0x2>
    14a2:	b0 91 5c 38 	lds	r27, 0x385C	; 0x80385c <tick+0x3>
    14a6:	40 91 5d 38 	lds	r20, 0x385D	; 0x80385d <lastTick>
    14aa:	50 91 5e 38 	lds	r21, 0x385E	; 0x80385e <lastTick+0x1>
    14ae:	60 91 5f 38 	lds	r22, 0x385F	; 0x80385f <lastTick+0x2>
    14b2:	70 91 60 38 	lds	r23, 0x3860	; 0x803860 <lastTick+0x3>
    14b6:	84 17       	cp	r24, r20
    14b8:	95 07       	cpc	r25, r21
    14ba:	a6 07       	cpc	r26, r22
    14bc:	b7 07       	cpc	r27, r23
    14be:	40 f4       	brcc	.+16     	; 0x14d0 <main+0x1b8>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:200
        lastTick = 0;
    14c0:	10 92 5d 38 	sts	0x385D, r1	; 0x80385d <lastTick>
    14c4:	10 92 5e 38 	sts	0x385E, r1	; 0x80385e <lastTick+0x1>
    14c8:	10 92 5f 38 	sts	0x385F, r1	; 0x80385f <lastTick+0x2>
    14cc:	10 92 60 38 	sts	0x3860, r1	; 0x803860 <lastTick+0x3>
    14d0:	40 91 5d 38 	lds	r20, 0x385D	; 0x80385d <lastTick>
    14d4:	50 91 5e 38 	lds	r21, 0x385E	; 0x80385e <lastTick+0x1>
    14d8:	60 91 5f 38 	lds	r22, 0x385F	; 0x80385f <lastTick+0x2>
    14dc:	70 91 60 38 	lds	r23, 0x3860	; 0x803860 <lastTick+0x3>
    14e0:	20 91 57 38 	lds	r18, 0x3857	; 0x803857 <bounce>
    14e4:	30 91 58 38 	lds	r19, 0x3858	; 0x803858 <bounce+0x1>
    14e8:	80 91 55 38 	lds	r24, 0x3855	; 0x803855 <repeat>
    14ec:	90 91 56 38 	lds	r25, 0x3856	; 0x803856 <repeat+0x1>
    14f0:	e0 91 54 38 	lds	r30, 0x3854	; 0x803854 <repeating>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:203
    }

    while (lastTick < tick) {
    14f4:	20 90 59 38 	lds	r2, 0x3859	; 0x803859 <tick>
    14f8:	30 90 5a 38 	lds	r3, 0x385A	; 0x80385a <tick+0x1>
    14fc:	40 90 5b 38 	lds	r4, 0x385B	; 0x80385b <tick+0x2>
    1500:	50 90 5c 38 	lds	r5, 0x385C	; 0x80385c <tick+0x3>
    1504:	42 15       	cp	r20, r2
    1506:	53 05       	cpc	r21, r3
    1508:	64 05       	cpc	r22, r4
    150a:	75 05       	cpc	r23, r5
    150c:	c8 f4       	brcc	.+50     	; 0x1540 <main+0x228>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:207
        ++lastTick;

        // don't bother checking if the buttons are released if we're not bouncing or repeating
        if (bounce > 0 || repeat > 0) {
    150e:	21 15       	cp	r18, r1
    1510:	31 05       	cpc	r19, r1
    1512:	61 f4       	brne	.+24     	; 0x152c <main+0x214>
    1514:	00 97       	sbiw	r24, 0x00	; 0
    1516:	61 f4       	brne	.+24     	; 0x1530 <main+0x218>
    1518:	9c 01       	movw	r18, r24
    151a:	03 c0       	rjmp	.+6      	; 0x1522 <main+0x20a>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:216
            }

            if (digitalReadFast(BUTTON_DOWN_PIN) == true && digitalReadFast(BUTTON_UP_PIN) == true) {
                // immediately clear repeat if the button is lifted
                repeat = 0;
                repeating = false;
    151c:	e0 e0       	ldi	r30, 0x00	; 0
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:215
                --bounce;
            }

            if (digitalReadFast(BUTTON_DOWN_PIN) == true && digitalReadFast(BUTTON_UP_PIN) == true) {
                // immediately clear repeat if the button is lifted
                repeat = 0;
    151e:	90 e0       	ldi	r25, 0x00	; 0
    1520:	80 e0       	ldi	r24, 0x00	; 0
    1522:	4f 5f       	subi	r20, 0xFF	; 255
    1524:	5f 4f       	sbci	r21, 0xFF	; 255
    1526:	6f 4f       	sbci	r22, 0xFF	; 255
    1528:	7f 4f       	sbci	r23, 0xFF	; 255
    152a:	e4 cf       	rjmp	.-56     	; 0x14f4 <main+0x1dc>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:210

        // don't bother checking if the buttons are released if we're not bouncing or repeating
        if (bounce > 0 || repeat > 0) {
            // always count down bounce regardless of whether a button is held down or not
            if (bounce > 0) {
                --bounce;
    152c:	21 50       	subi	r18, 0x01	; 1
    152e:	31 09       	sbc	r19, r1
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:213
            }

            if (digitalReadFast(BUTTON_DOWN_PIN) == true && digitalReadFast(BUTTON_UP_PIN) == true) {
    1530:	50 9b       	sbis	0x0a, 0	; 10
    1532:	02 c0       	rjmp	.+4      	; 0x1538 <main+0x220>
    1534:	51 99       	sbic	0x0a, 1	; 10
    1536:	f2 cf       	rjmp	.-28     	; 0x151c <main+0x204>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:220
                repeat = 0;
                repeating = false;
            }
            else {
                // count down repeat while a button is held down
                if (repeat > 0) {
    1538:	00 97       	sbiw	r24, 0x00	; 0
    153a:	99 f3       	breq	.-26     	; 0x1522 <main+0x20a>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:221
                    --repeat;
    153c:	01 97       	sbiw	r24, 0x01	; 1
    153e:	f1 cf       	rjmp	.-30     	; 0x1522 <main+0x20a>
    1540:	20 93 57 38 	sts	0x3857, r18	; 0x803857 <bounce>
    1544:	30 93 58 38 	sts	0x3858, r19	; 0x803858 <bounce+0x1>
    1548:	80 93 55 38 	sts	0x3855, r24	; 0x803855 <repeat>
    154c:	90 93 56 38 	sts	0x3856, r25	; 0x803856 <repeat+0x1>
    1550:	e0 93 54 38 	sts	0x3854, r30	; 0x803854 <repeating>
    1554:	40 93 5d 38 	sts	0x385D, r20	; 0x80385d <lastTick>
    1558:	50 93 5e 38 	sts	0x385E, r21	; 0x80385e <lastTick+0x1>
    155c:	60 93 5f 38 	sts	0x385F, r22	; 0x80385f <lastTick+0x2>
    1560:	70 93 60 38 	sts	0x3860, r23	; 0x803860 <lastTick+0x3>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:228
            }
        }
    }

    // if we're still bouncing or repeating, ignore all presses
    if (bounce != 0 || repeat != 0) {
    1564:	23 2b       	or	r18, r19
    1566:	09 f5       	brne	.+66     	; 0x15aa <main+0x292>
    1568:	89 2b       	or	r24, r25
    156a:	f9 f4       	brne	.+62     	; 0x15aa <main+0x292>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:234
        return 0;
    }

    int8_t delta = 0;

    if (digitalReadFast(BUTTON_DOWN_PIN) == false) {
    156c:	50 9b       	sbis	0x0a, 0	; 10
    156e:	55 c0       	rjmp	.+170    	; 0x161a <main+0x302>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:237
        delta = -1;
    }
    else if (digitalReadFast(BUTTON_UP_PIN) == false) {
    1570:	51 99       	sbic	0x0a, 1	; 10
    1572:	1b c0       	rjmp	.+54     	; 0x15aa <main+0x292>
main():
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:238
        delta = 1;
    1574:	21 e0       	ldi	r18, 0x01	; 1
checkUpDown():
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:247
        return 0;
    }

    // This only applies if a button was pressed

    bounce = DEBOUNCE_TICKS;
    1576:	82 ee       	ldi	r24, 0xE2	; 226
    1578:	94 e0       	ldi	r25, 0x04	; 4
    157a:	80 93 57 38 	sts	0x3857, r24	; 0x803857 <bounce>
    157e:	90 93 58 38 	sts	0x3858, r25	; 0x803858 <bounce+0x1>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:248
    if (repeating) {
    1582:	ee 23       	and	r30, r30
    1584:	09 f4       	brne	.+2      	; 0x1588 <main+0x270>
    1586:	4b c0       	rjmp	.+150    	; 0x161e <main+0x306>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:249
        repeat = REPEAT_TICKS2;
    1588:	60 92 55 38 	sts	0x3855, r6	; 0x803855 <repeat>
    158c:	70 92 56 38 	sts	0x3856, r7	; 0x803856 <repeat+0x1>
loop():
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:89
    // UP/DOWN

    int8_t delta = checkUpDown();

    if (delta != 0) {
        if (octave + delta >= 0 && octave + delta <= 7) {
    1590:	30 91 06 38 	lds	r19, 0x3806	; 0x803806 <octave>
    1594:	82 2f       	mov	r24, r18
    1596:	02 2e       	mov	r0, r18
    1598:	00 0c       	add	r0, r0
    159a:	99 0b       	sbc	r25, r25
    159c:	83 0f       	add	r24, r19
    159e:	91 1d       	adc	r25, r1
    15a0:	08 97       	sbiw	r24, 0x08	; 8
    15a2:	18 f4       	brcc	.+6      	; 0x15aa <main+0x292>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:90
            octave += delta;
    15a4:	23 0f       	add	r18, r19
    15a6:	20 93 06 38 	sts	0x3806, r18	; 0x803806 <octave>
analogRead():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_analog.c:166
    15aa:	c0 93 06 06 	sts	0x0606, r28	; 0x800606 <vtable for SSD1306Device+0x7f6cc2>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_analog.c:169

  /* Start conversion */
  ADC0.COMMAND = ADC_STCONV_bm;
    15ae:	d0 93 08 06 	sts	0x0608, r29	; 0x800608 <vtable for SSD1306Device+0x7f6cc4>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_analog.c:172

  /* Wait for result ready */
  while (!(ADC0.INTFLAGS & ADC_RESRDY_bm));
    15b2:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <vtable for SSD1306Device+0x7f6cc7>
    15b6:	80 ff       	sbrs	r24, 0
    15b8:	fc cf       	rjmp	.-8      	; 0x15b2 <main+0x29a>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_analog.c:175

  /* Combine two bytes */
  return ADC0.RES;
    15ba:	80 91 10 06 	lds	r24, 0x0610	; 0x800610 <vtable for SSD1306Device+0x7f6ccc>
    15be:	90 91 11 06 	lds	r25, 0x0611	; 0x800611 <vtable for SSD1306Device+0x7f6ccd>
loop():
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:96
        }
    }

    // KEYBOARD

    keyADC = analogRead(KEYS_PIN);
    15c2:	80 93 66 38 	sts	0x3866, r24	; 0x803866 <keyADC>
    15c6:	90 93 67 38 	sts	0x3867, r25	; 0x803867 <keyADC+0x1>
    15ca:	29 ee       	ldi	r18, 0xE9	; 233
    15cc:	32 e0       	ldi	r19, 0x02	; 2
main():
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:137

    // TODO: subtract 10, use as start, check > that and < that plus 20. Should be faster.
    unsigned int midpoint = 755;
    int8_t key = -1;

    for (int8_t i=0; i<13; ++i) {
    15ce:	e0 e0       	ldi	r30, 0x00	; 0
    15d0:	a9 01       	movw	r20, r18
    15d2:	4c 5e       	subi	r20, 0xEC	; 236
    15d4:	5f 4f       	sbci	r21, 0xFF	; 255
getKey():
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:138
        if (value > (midpoint - 10) && value < (midpoint + 10)) {
    15d6:	28 17       	cp	r18, r24
    15d8:	39 07       	cpc	r19, r25
    15da:	18 f4       	brcc	.+6      	; 0x15e2 <main+0x2ca>
    15dc:	84 17       	cp	r24, r20
    15de:	95 07       	cpc	r25, r21
    15e0:	30 f0       	brcs	.+12     	; 0x15ee <main+0x2d6>
    15e2:	ef 5f       	subi	r30, 0xFF	; 255
    15e4:	9a 01       	movw	r18, r20
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:137

    // TODO: subtract 10, use as start, check > that and < that plus 20. Should be faster.
    unsigned int midpoint = 755;
    int8_t key = -1;

    for (int8_t i=0; i<13; ++i) {
    15e6:	4d 3e       	cpi	r20, 0xED	; 237
    15e8:	53 40       	sbci	r21, 0x03	; 3
    15ea:	91 f7       	brne	.-28     	; 0x15d0 <main+0x2b8>
main():
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:135

int8_t getKey(uint16_t value) {

    // TODO: subtract 10, use as start, check > that and < that plus 20. Should be faster.
    unsigned int midpoint = 755;
    int8_t key = -1;
    15ec:	ef ef       	ldi	r30, 0xFF	; 255
loop():
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:97
    }

    // KEYBOARD

    keyADC = analogRead(KEYS_PIN);
    key = getKey(keyADC);
    15ee:	e0 93 65 38 	sts	0x3865, r30	; 0x803865 <key>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:99

    if (key == -1) {
    15f2:	ef 3f       	cpi	r30, 0xFF	; 255
    15f4:	e9 f4       	brne	.+58     	; 0x1630 <main+0x318>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:101
        // Prefer to keep the previous note if it looks like something was pressed because the most likely explanation is that two keys are held down and it is _just_ barely putting us out of range of either of them.
        if (keyADC < 740) {
    15f6:	84 3e       	cpi	r24, 0xE4	; 228
    15f8:	22 e0       	ldi	r18, 0x02	; 2
    15fa:	92 07       	cpc	r25, r18
    15fc:	40 f4       	brcc	.+16     	; 0x160e <main+0x2f6>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:102
            jump = -1;
    15fe:	c0 92 61 38 	sts	0x3861, r12	; 0x803861 <jump>
    1602:	d0 92 62 38 	sts	0x3862, r13	; 0x803862 <jump+0x1>
    1606:	e0 92 63 38 	sts	0x3863, r14	; 0x803863 <jump+0x2>
    160a:	f0 92 64 38 	sts	0x3864, r15	; 0x803864 <jump+0x3>
updateDisplay():
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:151
}


void updateDisplay() {

    uint8_t step = frame % 4;
    160e:	28 2d       	mov	r18, r8
    1610:	23 70       	andi	r18, 0x03	; 3
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:153

    if (step == 0) {
    1612:	51 f5       	brne	.+84     	; 0x1668 <main+0x350>
clear():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:190
	oledX = x;
	oledY = y;
}

void SSD1306Device::clear(void) {
	fill(0x00);
    1614:	0e 94 b3 04 	call	0x966	; 0x966 <SSD1306Device::fill(unsigned char) [clone .constprop.18]>
    1618:	29 cf       	rjmp	.-430    	; 0x146c <main+0x154>
main():
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:235
    }

    int8_t delta = 0;

    if (digitalReadFast(BUTTON_DOWN_PIN) == false) {
        delta = -1;
    161a:	2f ef       	ldi	r18, 0xFF	; 255
    161c:	ac cf       	rjmp	.-168    	; 0x1576 <main+0x25e>
checkUpDown():
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:252
    bounce = DEBOUNCE_TICKS;
    if (repeating) {
        repeat = REPEAT_TICKS2;
    }
    else {
        repeating = true;
    161e:	d0 93 54 38 	sts	0x3854, r29	; 0x803854 <repeating>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:253
        repeat = REPEAT_TICKS1;
    1622:	e0 e7       	ldi	r30, 0x70	; 112
    1624:	f7 e1       	ldi	r31, 0x17	; 23
    1626:	e0 93 55 38 	sts	0x3855, r30	; 0x803855 <repeat>
    162a:	f0 93 56 38 	sts	0x3856, r31	; 0x803856 <repeat+0x1>
    162e:	b0 cf       	rjmp	.-160    	; 0x1590 <main+0x278>
loop():
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:106
        if (keyADC < 740) {
            jump = -1;
        }
    }
    else {
        jump = notes[3 + (octave * 12) + key];
    1630:	20 91 06 38 	lds	r18, 0x3806	; 0x803806 <octave>
    1634:	0e 2e       	mov	r0, r30
    1636:	00 0c       	add	r0, r0
    1638:	ff 0b       	sbc	r31, r31
    163a:	20 9f       	mul	r18, r16
    163c:	e0 0d       	add	r30, r0
    163e:	f1 1d       	adc	r31, r1
    1640:	11 24       	eor	r1, r1
    1642:	ee 0f       	add	r30, r30
    1644:	ff 1f       	adc	r31, r31
    1646:	ee 0f       	add	r30, r30
    1648:	ff 1f       	adc	r31, r31
    164a:	e6 55       	subi	r30, 0x56	; 86
    164c:	f8 46       	sbci	r31, 0x68	; 104
    164e:	40 81       	ld	r20, Z
    1650:	51 81       	ldd	r21, Z+1	; 0x01
    1652:	62 81       	ldd	r22, Z+2	; 0x02
    1654:	73 81       	ldd	r23, Z+3	; 0x03
    1656:	40 93 61 38 	sts	0x3861, r20	; 0x803861 <jump>
    165a:	50 93 62 38 	sts	0x3862, r21	; 0x803862 <jump+0x1>
    165e:	60 93 63 38 	sts	0x3863, r22	; 0x803863 <jump+0x2>
    1662:	70 93 64 38 	sts	0x3864, r23	; 0x803864 <jump+0x3>
    1666:	d3 cf       	rjmp	.-90     	; 0x160e <main+0x2f6>
updateDisplay():
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:166
        // In order to keep the library size small, text can only be positioned
        // with the top of the font aligned with one of the four 8 bit high RAM pages.
        // The Y value therefore can only have the value 0, 1, 2, or 3.
        // usage: oled.setCursor(X IN PIXELS, Y IN ROWS OF 8 PIXELS STARTING WITH 0);

        if (keyADC < 740) {
    1668:	84 3e       	cpi	r24, 0xE4	; 228
    166a:	92 40       	sbci	r25, 0x02	; 2
    166c:	08 f4       	brcc	.+2      	; 0x1670 <main+0x358>
    166e:	fe ce       	rjmp	.-516    	; 0x146c <main+0x154>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:171
            // save the screen if nothing is pressed
            return;
        }

        if (step == 1) {
    1670:	21 30       	cpi	r18, 0x01	; 1
    1672:	81 f4       	brne	.+32     	; 0x1694 <main+0x37c>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:172
            oled.setCursor(0, 0); // x then y
    1674:	60 e0       	ldi	r22, 0x00	; 0
    1676:	80 e0       	ldi	r24, 0x00	; 0
    1678:	0e 94 90 04 	call	0x920	; 0x920 <SSD1306Device::setCursor(unsigned char, unsigned char) [clone .constprop.31]>
print():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:105

size_t Print::print(unsigned long n, int base) {
  if (base == 0) {
    return write(n);
  } else {
    return printNumber(n, base);
    167c:	60 91 68 38 	lds	r22, 0x3868	; 0x803868 <frame>
    1680:	70 91 69 38 	lds	r23, 0x3869	; 0x803869 <frame+0x1>
    1684:	80 91 6a 38 	lds	r24, 0x386A	; 0x80386a <frame+0x2>
    1688:	90 91 6b 38 	lds	r25, 0x386B	; 0x80386b <frame+0x3>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:93
    return write(n);
  } else if (base == 10) {
    if (n < 0) {
      int t = print('-');
      n = -n;
      return printNumber(n, 10) + t;
    168c:	4a e0       	ldi	r20, 0x0A	; 10
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:95
    }
    return printNumber(n, 10);
    168e:	0e 94 39 06 	call	0xc72	; 0xc72 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.28]>
    1692:	ec ce       	rjmp	.-552    	; 0x146c <main+0x154>
updateDisplay():
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:176
            oled.print(frame);
        }

        else if (step == 2) {
    1694:	22 30       	cpi	r18, 0x02	; 2
    1696:	51 f5       	brne	.+84     	; 0x16ec <main+0x3d4>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:177
            oled.setCursor(0, 2);
    1698:	62 e0       	ldi	r22, 0x02	; 2
    169a:	80 e0       	ldi	r24, 0x00	; 0
    169c:	0e 94 90 04 	call	0x920	; 0x920 <SSD1306Device::setCursor(unsigned char, unsigned char) [clone .constprop.31]>
print():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:75
size_t Print::print(char c) {
  return write(c);
}

size_t Print::print(unsigned char b, int base) {
  return print((unsigned long) b, base);
    16a0:	60 91 06 38 	lds	r22, 0x3806	; 0x803806 <octave>
    16a4:	70 e0       	ldi	r23, 0x00	; 0
    16a6:	90 e0       	ldi	r25, 0x00	; 0
    16a8:	80 e0       	ldi	r24, 0x00	; 0
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:105

size_t Print::print(unsigned long n, int base) {
  if (base == 0) {
    return write(n);
  } else {
    return printNumber(n, base);
    16aa:	4a e0       	ldi	r20, 0x0A	; 10
    16ac:	0e 94 39 06 	call	0xc72	; 0xc72 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.28]>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:71
size_t Print::print(const char str[]) {
  return write(str);
}

size_t Print::print(char c) {
  return write(c);
    16b0:	60 e2       	ldi	r22, 0x20	; 32
    16b2:	82 e8       	ldi	r24, 0x82	; 130
    16b4:	98 e3       	ldi	r25, 0x38	; 56
    16b6:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <SSD1306Device::write(unsigned char)>
updateDisplay():
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:180
            oled.print(octave);
            oled.print(' ');
            oled.print(key); // TODO: or key name and octave in one?
    16ba:	80 90 65 38 	lds	r8, 0x3865	; 0x803865 <key>
print():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:79
size_t Print::print(unsigned char b, int base) {
  return print((unsigned long) b, base);
}

size_t Print::print(int n, int base) {
  return print((long) n, base);
    16be:	08 2c       	mov	r0, r8
    16c0:	00 0c       	add	r0, r0
    16c2:	99 08       	sbc	r9, r9
    16c4:	aa 08       	sbc	r10, r10
    16c6:	bb 08       	sbc	r11, r11
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:95
    if (n < 0) {
      int t = print('-');
      n = -n;
      return printNumber(n, 10) + t;
    }
    return printNumber(n, 10);
    16c8:	4a e0       	ldi	r20, 0x0A	; 10
    16ca:	c5 01       	movw	r24, r10
    16cc:	b4 01       	movw	r22, r8
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:90

size_t Print::print(long n, int base) {
  if (base == 0) {
    return write(n);
  } else if (base == 10) {
    if (n < 0) {
    16ce:	b7 fe       	sbrs	r11, 7
    16d0:	de cf       	rjmp	.-68     	; 0x168e <main+0x376>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:71
size_t Print::print(const char str[]) {
  return write(str);
}

size_t Print::print(char c) {
  return write(c);
    16d2:	6d e2       	ldi	r22, 0x2D	; 45
    16d4:	82 e8       	ldi	r24, 0x82	; 130
    16d6:	98 e3       	ldi	r25, 0x38	; 56
    16d8:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <SSD1306Device::write(unsigned char)>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:92
  if (base == 0) {
    return write(n);
  } else if (base == 10) {
    if (n < 0) {
      int t = print('-');
      n = -n;
    16dc:	66 27       	eor	r22, r22
    16de:	77 27       	eor	r23, r23
    16e0:	cb 01       	movw	r24, r22
    16e2:	68 19       	sub	r22, r8
    16e4:	79 09       	sbc	r23, r9
    16e6:	8a 09       	sbc	r24, r10
    16e8:	9b 09       	sbc	r25, r11
    16ea:	d0 cf       	rjmp	.-96     	; 0x168c <main+0x374>
switchDisplayFrame():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:360
void SSD1306Device::switchRenderFrame(void) {
	renderingFrame ^= 0x04;
}

void SSD1306Device::switchDisplayFrame(void) {
	drawingFrame ^= 0x20;
    16ec:	b0 90 05 38 	lds	r11, 0x3805	; 0x803805 <drawingFrame>
    16f0:	b1 26       	eor	r11, r17
    16f2:	b0 92 05 38 	sts	0x3805, r11	; 0x803805 <drawingFrame>
ssd1306_send_command():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:77
		ssd1306_send_byte(byte^invertedOutput);
	}
}

static void ssd1306_send_command(uint8_t command) {
	ssd1306_send_command_start();
    16f6:	0e 94 8b 04 	call	0x916	; 0x916 <ssd1306_send_command_start()>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:78
	ssd1306_send_byte(command);
    16fa:	8b 2d       	mov	r24, r11
    16fc:	0e 94 6e 04 	call	0x8dc	; 0x8dc <ssd1306_send_byte(unsigned char)>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:79
	ssd1306_send_stop();
    1700:	0e 94 69 04 	call	0x8d2	; 0x8d2 <ssd1306_send_stop()>
switchRenderFrame():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:356
}

// Double Buffering Commands

void SSD1306Device::switchRenderFrame(void) {
	renderingFrame ^= 0x04;
    1704:	80 91 07 38 	lds	r24, 0x3807	; 0x803807 <renderingFrame>
    1708:	8c 27       	eor	r24, r28
    170a:	80 93 07 38 	sts	0x3807, r24	; 0x803807 <renderingFrame>
    170e:	ae ce       	rjmp	.-676    	; 0x146c <main+0x154>

00001710 <__udivmodsi4>:
__udivmodsi4():
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1638
    1710:	a1 e2       	ldi	r26, 0x21	; 33
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1639
    1712:	1a 2e       	mov	r1, r26
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1640
    1714:	aa 1b       	sub	r26, r26
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1641
    1716:	bb 1b       	sub	r27, r27
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1642
    1718:	fd 01       	movw	r30, r26
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1644
    171a:	0d c0       	rjmp	.+26     	; 0x1736 <__udivmodsi4_ep>

0000171c <__udivmodsi4_loop>:
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1646
    171c:	aa 1f       	adc	r26, r26
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1647
    171e:	bb 1f       	adc	r27, r27
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1648
    1720:	ee 1f       	adc	r30, r30
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1649
    1722:	ff 1f       	adc	r31, r31
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1650
    1724:	a2 17       	cp	r26, r18
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1651
    1726:	b3 07       	cpc	r27, r19
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1652
    1728:	e4 07       	cpc	r30, r20
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1653
    172a:	f5 07       	cpc	r31, r21
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1654
    172c:	20 f0       	brcs	.+8      	; 0x1736 <__udivmodsi4_ep>
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1655
    172e:	a2 1b       	sub	r26, r18
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1656
    1730:	b3 0b       	sbc	r27, r19
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1657
    1732:	e4 0b       	sbc	r30, r20
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1658
    1734:	f5 0b       	sbc	r31, r21

00001736 <__udivmodsi4_ep>:
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1660
    1736:	66 1f       	adc	r22, r22
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1661
    1738:	77 1f       	adc	r23, r23
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1662
    173a:	88 1f       	adc	r24, r24
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1663
    173c:	99 1f       	adc	r25, r25
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1664
    173e:	1a 94       	dec	r1
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1665
    1740:	69 f7       	brne	.-38     	; 0x171c <__udivmodsi4_loop>
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1667
    1742:	60 95       	com	r22
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1668
    1744:	70 95       	com	r23
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1669
    1746:	80 95       	com	r24
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1670
    1748:	90 95       	com	r25
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1672
    174a:	9b 01       	movw	r18, r22
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1674
    174c:	ac 01       	movw	r20, r24
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1676
    174e:	bd 01       	movw	r22, r26
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1678
    1750:	cf 01       	movw	r24, r30
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1680
    1752:	08 95       	ret

00001754 <__muluhisi3>:
__muluhisi3():
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:626
    1754:	0e 94 bb 0b 	call	0x1776	; 0x1776 <__umulhisi3>
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:627
    1758:	a5 9f       	mul	r26, r21
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:628
    175a:	90 0d       	add	r25, r0
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:629
    175c:	b4 9f       	mul	r27, r20
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:630
    175e:	90 0d       	add	r25, r0
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:631
    1760:	a4 9f       	mul	r26, r20
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:632
    1762:	80 0d       	add	r24, r0
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:633
    1764:	91 1d       	adc	r25, r1
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:634
    1766:	11 24       	eor	r1, r1
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:635
    1768:	08 95       	ret

0000176a <__tablejump2__>:
__tablejump2__():
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
    176a:	ee 0f       	add	r30, r30
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
    176c:	ff 1f       	adc	r31, r31
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2328
    176e:	05 90       	lpm	r0, Z+
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2329
    1770:	f4 91       	lpm	r31, Z
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2330
    1772:	e0 2d       	mov	r30, r0
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2331
    1774:	09 94       	ijmp

00001776 <__umulhisi3>:
__umulhisi3():
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:564
    1776:	a2 9f       	mul	r26, r18
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:565
    1778:	b0 01       	movw	r22, r0
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:566
    177a:	b3 9f       	mul	r27, r19
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:567
    177c:	c0 01       	movw	r24, r0
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:568
    177e:	a3 9f       	mul	r26, r19
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:573
    1780:	70 0d       	add	r23, r0
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:574
    1782:	81 1d       	adc	r24, r1
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:575
    1784:	11 24       	eor	r1, r1
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:576
    1786:	91 1d       	adc	r25, r1
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:580
    1788:	b2 9f       	mul	r27, r18
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:581
    178a:	70 0d       	add	r23, r0
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:582
    178c:	81 1d       	adc	r24, r1
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:583
    178e:	11 24       	eor	r1, r1
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:584
    1790:	91 1d       	adc	r25, r1
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:585
    1792:	08 95       	ret

00001794 <_exit>:
exit():
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
    1794:	f8 94       	cli

00001796 <__stop_program>:
__stop_program():
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
    1796:	ff cf       	rjmp	.-2      	; 0x1796 <__stop_program>
