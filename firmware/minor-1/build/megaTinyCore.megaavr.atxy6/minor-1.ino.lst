
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/minor-1.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
../../../../crt1/gcrt1.S:61
       0:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__ctors_end>
../../../../crt1/gcrt1.S:67
       4:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:68
       8:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:69
       c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:70
      10:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:71
      14:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:72
      18:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:73
      1c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:74
      20:	0c 94 9e 06 	jmp	0xd3c	; 0xd3c <__vector_8>
../../../../crt1/gcrt1.S:75
      24:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:76
      28:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:77
      2c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:78
      30:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:79
      34:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:80
      38:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:81
      3c:	0c 94 f5 04 	jmp	0x9ea	; 0x9ea <__vector_15>
../../../../crt1/gcrt1.S:82
      40:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:83
      44:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:84
      48:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:85
      4c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:86
      50:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:87
      54:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:88
      58:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:89
      5c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:90
      60:	0c 94 4b 05 	jmp	0xa96	; 0xa96 <__vector_24>
../../../../crt1/gcrt1.S:91
      64:	0c 94 ee 05 	jmp	0xbdc	; 0xbdc <__vector_25>
../../../../crt1/gcrt1.S:92
      68:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:93
      6c:	0c 94 c7 04 	jmp	0x98e	; 0x98e <__vector_27>
../../../../crt1/gcrt1.S:94
      70:	0c 94 a1 04 	jmp	0x942	; 0x942 <__vector_28>
../../../../crt1/gcrt1.S:95
      74:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
../../../../crt1/gcrt1.S:96
      78:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>

0000007c <__ctors_start>:
__trampolines_start():
      7c:	91 07       	cpc	r25, r17

0000007e <__ctors_end>:
__dtors_end():
../../../../crt1/gcrt1.S:230
      7e:	11 24       	eor	r1, r1
../../../../crt1/gcrt1.S:231
      80:	1f be       	out	0x3f, r1	; 63
../../../../crt1/gcrt1.S:232
      82:	cf ef       	ldi	r28, 0xFF	; 255
../../../../crt1/gcrt1.S:234
      84:	cd bf       	out	0x3d, r28	; 61
../../../../crt1/gcrt1.S:236
      86:	df e3       	ldi	r29, 0x3F	; 63
../../../../crt1/gcrt1.S:237
      88:	de bf       	out	0x3e, r29	; 62

0000008a <__do_copy_data>:
__do_copy_data():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2409
      8a:	18 e3       	ldi	r17, 0x38	; 56
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2410
      8c:	a0 e0       	ldi	r26, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2411
      8e:	b8 e3       	ldi	r27, 0x38	; 56
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2412
      90:	ec e5       	ldi	r30, 0x5C	; 92
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2413
      92:	f6 e1       	ldi	r31, 0x16	; 22
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2414
      94:	02 c0       	rjmp	.+4      	; 0x9a <__do_copy_data+0x10>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2417
      96:	05 90       	lpm	r0, Z+
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2422
      98:	0d 92       	st	X+, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2424
      9a:	aa 33       	cpi	r26, 0x3A	; 58
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2425
      9c:	b1 07       	cpc	r27, r17
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2426
      9e:	d9 f7       	brne	.-10     	; 0x96 <__do_copy_data+0xc>

000000a0 <__do_clear_bss>:
__do_clear_bss():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
      a0:	29 e3       	ldi	r18, 0x39	; 57
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
      a2:	aa e3       	ldi	r26, 0x3A	; 58
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
      a4:	b8 e3       	ldi	r27, 0x38	; 56
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
      a6:	01 c0       	rjmp	.+2      	; 0xaa <.do_clear_bss_start>

000000a8 <.do_clear_bss_loop>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
      a8:	1d 92       	st	X+, r1

000000aa <.do_clear_bss_start>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
      aa:	a3 34       	cpi	r26, 0x43	; 67
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
      ac:	b2 07       	cpc	r27, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
      ae:	e1 f7       	brne	.-8      	; 0xa8 <.do_clear_bss_loop>

000000b0 <__do_global_ctors>:
__do_global_ctors():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
      b0:	10 e0       	ldi	r17, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
      b2:	cf e3       	ldi	r28, 0x3F	; 63
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
      b4:	d0 e0       	ldi	r29, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
      b6:	04 c0       	rjmp	.+8      	; 0xc0 <__do_global_ctors+0x10>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
      b8:	21 97       	sbiw	r28, 0x01	; 1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
      ba:	fe 01       	movw	r30, r28
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
      bc:	0e 94 33 0a 	call	0x1466	; 0x1466 <__tablejump2__>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
      c0:	ce 33       	cpi	r28, 0x3E	; 62
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
      c2:	d1 07       	cpc	r29, r17
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
      c4:	c9 f7       	brne	.-14     	; 0xb8 <__do_global_ctors+0x8>
../../../../crt1/gcrt1.S:314
      c6:	0e 94 df 07 	call	0xfbe	; 0xfbe <main>
../../../../crt1/gcrt1.S:315
      ca:	0c 94 48 0a 	jmp	0x1490	; 0x1490 <_exit>

000000ce <__bad_interrupt>:
__vector_22():
../../../../crt1/gcrt1.S:209
      ce:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d2 <UartClass::availableForWrite()>:
availableForWrite():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:323
int UartClass::availableForWrite(void) {
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
      d2:	fc 01       	movw	r30, r24
      d4:	50 8d       	ldd	r21, Z+24	; 0x18
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:324
    tail = _tx_buffer_tail;
      d6:	41 8d       	ldd	r20, Z+25	; 0x19
      d8:	25 2f       	mov	r18, r21
      da:	30 e0       	ldi	r19, 0x00	; 0
      dc:	84 2f       	mov	r24, r20
      de:	90 e0       	ldi	r25, 0x00	; 0
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:327
  }
  if (head >= tail) {
    return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
      e0:	82 1b       	sub	r24, r18
      e2:	93 0b       	sbc	r25, r19
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:326

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
    tail = _tx_buffer_tail;
  }
  if (head >= tail) {
      e4:	54 17       	cp	r21, r20
      e6:	10 f0       	brcs	.+4      	; 0xec <UartClass::availableForWrite()+0x1a>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:327
    return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
      e8:	cf 96       	adiw	r24, 0x3f	; 63
      ea:	08 95       	ret
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:329
  }
  return tail - head - 1;
      ec:	01 97       	sbiw	r24, 0x01	; 1
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:330
}
      ee:	08 95       	ret

000000f0 <UartClass::read()>:
read():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:307
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}

int UartClass::read(void) {
      f0:	fc 01       	movw	r30, r24
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:309
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
      f2:	96 89       	ldd	r25, Z+22	; 0x16
      f4:	87 89       	ldd	r24, Z+23	; 0x17
      f6:	98 17       	cp	r25, r24
      f8:	61 f0       	breq	.+24     	; 0x112 <__EEPROM_REGION_LENGTH__+0x12>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:312
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
      fa:	a7 89       	ldd	r26, Z+23	; 0x17
      fc:	ae 0f       	add	r26, r30
      fe:	bf 2f       	mov	r27, r31
     100:	b1 1d       	adc	r27, r1
     102:	5b 96       	adiw	r26, 0x1b	; 27
     104:	8c 91       	ld	r24, X
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:313
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) & (SERIAL_RX_BUFFER_SIZE-1); // % SERIAL_RX_BUFFER_SIZE;
     106:	97 89       	ldd	r25, Z+23	; 0x17
     108:	9f 5f       	subi	r25, 0xFF	; 255
     10a:	9f 73       	andi	r25, 0x3F	; 63
     10c:	97 8b       	std	Z+23, r25	; 0x17
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:314
    return c;
     10e:	90 e0       	ldi	r25, 0x00	; 0
     110:	08 95       	ret
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:310
}

int UartClass::read(void) {
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
     112:	8f ef       	ldi	r24, 0xFF	; 255
     114:	9f ef       	ldi	r25, 0xFF	; 255
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:316
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) & (SERIAL_RX_BUFFER_SIZE-1); // % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
     116:	08 95       	ret

00000118 <UartClass::peek()>:
peek():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:299

int UartClass::available(void) {
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE-1); //% SERIAL_RX_BUFFER_SIZE;
}

int UartClass::peek(void) {
     118:	fc 01       	movw	r30, r24
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:300
  if (_rx_buffer_head == _rx_buffer_tail) {
     11a:	96 89       	ldd	r25, Z+22	; 0x16
     11c:	87 89       	ldd	r24, Z+23	; 0x17
     11e:	98 17       	cp	r25, r24
     120:	31 f0       	breq	.+12     	; 0x12e <UartClass::peek()+0x16>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:303
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
     122:	87 89       	ldd	r24, Z+23	; 0x17
     124:	e8 0f       	add	r30, r24
     126:	f1 1d       	adc	r31, r1
     128:	83 8d       	ldd	r24, Z+27	; 0x1b
     12a:	90 e0       	ldi	r25, 0x00	; 0
     12c:	08 95       	ret
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:301
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE-1); //% SERIAL_RX_BUFFER_SIZE;
}

int UartClass::peek(void) {
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
     12e:	8f ef       	ldi	r24, 0xFF	; 255
     130:	9f ef       	ldi	r25, 0xFF	; 255
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:305
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
     132:	08 95       	ret

00000134 <UartClass::available()>:
available():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:295

  // Note: Does not change output pins
  _written = false;
}

int UartClass::available(void) {
     134:	fc 01       	movw	r30, r24
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:296
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE-1); //% SERIAL_RX_BUFFER_SIZE;
     136:	96 89       	ldd	r25, Z+22	; 0x16
     138:	27 89       	ldd	r18, Z+23	; 0x17
     13a:	89 2f       	mov	r24, r25
     13c:	90 e0       	ldi	r25, 0x00	; 0
     13e:	80 5c       	subi	r24, 0xC0	; 192
     140:	9f 4f       	sbci	r25, 0xFF	; 255
     142:	82 1b       	sub	r24, r18
     144:	91 09       	sbc	r25, r1
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:297
}
     146:	8f 73       	andi	r24, 0x3F	; 63
     148:	99 27       	eor	r25, r25
     14a:	08 95       	ret

0000014c <UartClass::end()>:
end():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:279

  // Restore SREG content
  SREG = oldSREG;
}

void UartClass::end() {
     14c:	cf 93       	push	r28
     14e:	df 93       	push	r29
     150:	ec 01       	movw	r28, r24
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:281
  // wait for transmission of outgoing data
  flush();
     152:	e8 81       	ld	r30, Y
     154:	f9 81       	ldd	r31, Y+1	; 0x01
     156:	02 84       	ldd	r0, Z+10	; 0x0a
     158:	f3 85       	ldd	r31, Z+11	; 0x0b
     15a:	e0 2d       	mov	r30, r0
     15c:	09 95       	icall
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:285

  // Disable receiver and transmitter as well as the RX complete and
  // data register empty interrupts.
  (*_hwserial_module).CTRLB &= ~(USART_RXEN_bm | USART_TXEN_bm);
     15e:	ec 85       	ldd	r30, Y+12	; 0x0c
     160:	fd 85       	ldd	r31, Y+13	; 0x0d
     162:	86 81       	ldd	r24, Z+6	; 0x06
     164:	8f 73       	andi	r24, 0x3F	; 63
     166:	86 83       	std	Z+6, r24	; 0x06
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:286
  (*_hwserial_module).CTRLA &= ~(USART_RXCIE_bm | USART_DREIE_bm);
     168:	ec 85       	ldd	r30, Y+12	; 0x0c
     16a:	fd 85       	ldd	r31, Y+13	; 0x0d
     16c:	85 81       	ldd	r24, Z+5	; 0x05
     16e:	8f 75       	andi	r24, 0x5F	; 95
     170:	85 83       	std	Z+5, r24	; 0x05
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:289

  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
     172:	8f 89       	ldd	r24, Y+23	; 0x17
     174:	8e 8b       	std	Y+22, r24	; 0x16
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:292

  // Note: Does not change output pins
  _written = false;
     176:	1d 8a       	std	Y+21, r1	; 0x15
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:293
}
     178:	df 91       	pop	r29
     17a:	cf 91       	pop	r28
     17c:	08 95       	ret

0000017e <UartClass::_tx_data_empty_irq()>:
_tx_data_empty_irq():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:96
  #define TX_BUFFER_ATOMIC
#endif

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void UartClass::_tx_data_empty_irq(void) {
     17e:	cf 93       	push	r28
     180:	df 93       	push	r29
     182:	fc 01       	movw	r30, r24
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:98
  // Check if tx buffer already empty.
  if (_tx_buffer_head == _tx_buffer_tail) {
     184:	90 8d       	ldd	r25, Z+24	; 0x18
     186:	81 8d       	ldd	r24, Z+25	; 0x19
     188:	c4 85       	ldd	r28, Z+12	; 0x0c
     18a:	d5 85       	ldd	r29, Z+13	; 0x0d
     18c:	98 13       	cpse	r25, r24
     18e:	06 c0       	rjmp	.+12     	; 0x19c <UartClass::_tx_data_empty_irq()+0x1e>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:100
    // Buffer empty, so disable "data register empty" interrupt
    (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
     190:	8d 81       	ldd	r24, Y+5	; 0x05
     192:	8f 7d       	andi	r24, 0xDF	; 223
     194:	8d 83       	std	Y+5, r24	; 0x05
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:120

  if (_tx_buffer_head == _tx_buffer_tail) {
    // Buffer empty, so disable "data register empty" interrupt
    (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
  }
}
     196:	df 91       	pop	r29
     198:	cf 91       	pop	r28
     19a:	08 95       	ret
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:106
    return;
  }

  // There must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
     19c:	a1 8d       	ldd	r26, Z+25	; 0x19
     19e:	ae 0f       	add	r26, r30
     1a0:	bf 2f       	mov	r27, r31
     1a2:	b1 1d       	adc	r27, r1
     1a4:	a5 5a       	subi	r26, 0xA5	; 165
     1a6:	bf 4f       	sbci	r27, 0xFF	; 255
     1a8:	9c 91       	ld	r25, X
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:107
  _tx_buffer_tail = (_tx_buffer_tail + 1) & (SERIAL_TX_BUFFER_SIZE-1); //% SERIAL_TX_BUFFER_SIZE;
     1aa:	81 8d       	ldd	r24, Z+25	; 0x19
     1ac:	8f 5f       	subi	r24, 0xFF	; 255
     1ae:	8f 73       	andi	r24, 0x3F	; 63
     1b0:	81 8f       	std	Z+25, r24	; 0x19
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:112

  // clear the TXCIF flag -- "can be cleared by writing a one to its bit
  // location". This makes sure flush() won't return until the bytes
  // actually got written
  (*_hwserial_module).STATUS = USART_TXCIF_bm;
     1b2:	80 e4       	ldi	r24, 0x40	; 64
     1b4:	8c 83       	std	Y+4, r24	; 0x04
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:114

  (*_hwserial_module).TXDATAL = c;
     1b6:	a4 85       	ldd	r26, Z+12	; 0x0c
     1b8:	b5 85       	ldd	r27, Z+13	; 0x0d
     1ba:	12 96       	adiw	r26, 0x02	; 2
     1bc:	9c 93       	st	X, r25
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:116

  if (_tx_buffer_head == _tx_buffer_tail) {
     1be:	90 8d       	ldd	r25, Z+24	; 0x18
     1c0:	81 8d       	ldd	r24, Z+25	; 0x19
     1c2:	98 13       	cpse	r25, r24
     1c4:	e8 cf       	rjmp	.-48     	; 0x196 <UartClass::_tx_data_empty_irq()+0x18>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:118
    // Buffer empty, so disable "data register empty" interrupt
    (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
     1c6:	04 84       	ldd	r0, Z+12	; 0x0c
     1c8:	f5 85       	ldd	r31, Z+13	; 0x0d
     1ca:	e0 2d       	mov	r30, r0
     1cc:	85 81       	ldd	r24, Z+5	; 0x05
     1ce:	8f 7d       	andi	r24, 0xDF	; 223
     1d0:	85 83       	std	Z+5, r24	; 0x05
     1d2:	e1 cf       	rjmp	.-62     	; 0x196 <UartClass::_tx_data_empty_irq()+0x18>

000001d4 <UartClass::_poll_tx_data_empty()>:
_poll_tx_data_empty():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:123
  }
}

// To invoke data empty "interrupt" via a call, use this method
void UartClass::_poll_tx_data_empty(void) {
     1d4:	dc 01       	movw	r26, r24
     1d6:	1c 96       	adiw	r26, 0x0c	; 12
     1d8:	ed 91       	ld	r30, X+
     1da:	fc 91       	ld	r31, X
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:124
  if ((!(SREG & CPU_I_bm)) || (!((*_hwserial_module).CTRLA & USART_DREIE_bm)) || CPUINT.STATUS) {
     1dc:	0f b6       	in	r0, 0x3f	; 63
     1de:	07 fe       	sbrs	r0, 7
     1e0:	07 c0       	rjmp	.+14     	; 0x1f0 <UartClass::_poll_tx_data_empty()+0x1c>
     1e2:	25 81       	ldd	r18, Z+5	; 0x05
     1e4:	25 ff       	sbrs	r18, 5
     1e6:	04 c0       	rjmp	.+8      	; 0x1f0 <UartClass::_poll_tx_data_empty()+0x1c>
     1e8:	20 91 11 01 	lds	r18, 0x0111	; 0x800111 <vtable for SSD1306Device+0x7f6abd>
     1ec:	22 23       	and	r18, r18
     1ee:	21 f0       	breq	.+8      	; 0x1f8 <UartClass::_poll_tx_data_empty()+0x24>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:137
    // so we'll have to poll the "data register empty" flag ourselves.
    // If it is set, pretend an interrupt has happened and call the handler
    // to free up space for us.

    // Invoke interrupt handler only if conditions data register is empty
    if ((*_hwserial_module).STATUS & USART_DREIF_bm) {
     1f0:	24 81       	ldd	r18, Z+4	; 0x04
     1f2:	25 fd       	sbrc	r18, 5
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:138
      _tx_data_empty_irq();
     1f4:	0c 94 bf 00 	jmp	0x17e	; 0x17e <UartClass::_tx_data_empty_irq()>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:142
    }
  }
  // In case interrupts are enabled, the interrupt routine will be invoked by itself
}
     1f8:	08 95       	ret

000001fa <UartClass::write(unsigned char)>:
write():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:361
  }
  // When we get here, nothing is queued anymore (DREIE is disabled) and
  // the hardware finished transmission (TXCIF is set).
}

size_t UartClass::write(uint8_t c) {
     1fa:	0f 93       	push	r16
     1fc:	1f 93       	push	r17
     1fe:	cf 93       	push	r28
     200:	df 93       	push	r29
     202:	ec 01       	movw	r28, r24
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:362
  _written = true;
     204:	81 e0       	ldi	r24, 0x01	; 1
     206:	8d 8b       	std	Y+21, r24	; 0x15
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:368

  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective data rate at high (>
  // 500kbit/s) bit rates, where interrupt overhead becomes a slowdown.
  if ((_tx_buffer_head == _tx_buffer_tail) && ((*_hwserial_module).STATUS & USART_DREIF_bm)) {
     208:	98 8d       	ldd	r25, Y+24	; 0x18
     20a:	89 8d       	ldd	r24, Y+25	; 0x19
     20c:	98 13       	cpse	r25, r24
     20e:	16 c0       	rjmp	.+44     	; 0x23c <UartClass::write(unsigned char)+0x42>
     210:	ec 85       	ldd	r30, Y+12	; 0x0c
     212:	fd 85       	ldd	r31, Y+13	; 0x0d
     214:	84 81       	ldd	r24, Z+4	; 0x04
     216:	85 ff       	sbrs	r24, 5
     218:	11 c0       	rjmp	.+34     	; 0x23c <UartClass::write(unsigned char)+0x42>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:369
    (*_hwserial_module).TXDATAL = c;
     21a:	62 83       	std	Z+2, r22	; 0x02
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:370
    (*_hwserial_module).STATUS = USART_TXCIF_bm;
     21c:	ec 85       	ldd	r30, Y+12	; 0x0c
     21e:	fd 85       	ldd	r31, Y+13	; 0x0d
     220:	80 e4       	ldi	r24, 0x40	; 64
     222:	84 83       	std	Z+4, r24	; 0x04
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:374

    // Make sure data register empty interrupt is disabled to avoid
    // that the interrupt handler is called in this situation
    (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
     224:	ec 85       	ldd	r30, Y+12	; 0x0c
     226:	fd 85       	ldd	r31, Y+13	; 0x0d
     228:	85 81       	ldd	r24, Z+5	; 0x05
     22a:	8f 7d       	andi	r24, 0xDF	; 223
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:391

  _tx_buffer[_tx_buffer_head] = c;
  _tx_buffer_head = i;

  // Enable data "register empty interrupt"
  (*_hwserial_module).CTRLA |= USART_DREIE_bm;
     22c:	85 83       	std	Z+5, r24	; 0x05
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:394

  return 1;
}
     22e:	81 e0       	ldi	r24, 0x01	; 1
     230:	90 e0       	ldi	r25, 0x00	; 0
     232:	df 91       	pop	r29
     234:	cf 91       	pop	r28
     236:	1f 91       	pop	r17
     238:	0f 91       	pop	r16
     23a:	08 95       	ret
     23c:	06 2f       	mov	r16, r22
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:379
    (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);

    return 1;
  }

  tx_buffer_index_t i = (_tx_buffer_head + 1) & (SERIAL_TX_BUFFER_SIZE-1); // % SERIAL_TX_BUFFER_SIZE;
     23e:	18 8d       	ldd	r17, Y+24	; 0x18
     240:	1f 5f       	subi	r17, 0xFF	; 255
     242:	1f 73       	andi	r17, 0x3F	; 63
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:383

  //If the output buffer is full, there's nothing for it other than to
  //wait for the interrupt handler to empty it a bit (or emulate interrupts)
  while (i == _tx_buffer_tail) {
     244:	89 8d       	ldd	r24, Y+25	; 0x19
     246:	81 13       	cpse	r24, r17
     248:	04 c0       	rjmp	.+8      	; 0x252 <UartClass::write(unsigned char)+0x58>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:384
    _poll_tx_data_empty();
     24a:	ce 01       	movw	r24, r28
     24c:	0e 94 ea 00 	call	0x1d4	; 0x1d4 <UartClass::_poll_tx_data_empty()>
     250:	f9 cf       	rjmp	.-14     	; 0x244 <UartClass::write(unsigned char)+0x4a>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:387
  }

  _tx_buffer[_tx_buffer_head] = c;
     252:	e8 8d       	ldd	r30, Y+24	; 0x18
     254:	ec 0f       	add	r30, r28
     256:	fd 2f       	mov	r31, r29
     258:	f1 1d       	adc	r31, r1
     25a:	e5 5a       	subi	r30, 0xA5	; 165
     25c:	ff 4f       	sbci	r31, 0xFF	; 255
     25e:	00 83       	st	Z, r16
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:388
  _tx_buffer_head = i;
     260:	18 8f       	std	Y+24, r17	; 0x18
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:391

  // Enable data "register empty interrupt"
  (*_hwserial_module).CTRLA |= USART_DREIE_bm;
     262:	ec 85       	ldd	r30, Y+12	; 0x0c
     264:	fd 85       	ldd	r31, Y+13	; 0x0d
     266:	85 81       	ldd	r24, Z+5	; 0x05
     268:	80 62       	ori	r24, 0x20	; 32
     26a:	e0 cf       	rjmp	.-64     	; 0x22c <UartClass::write(unsigned char)+0x32>

0000026c <UartClass::flush()>:
flush():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:332
    return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  }
  return tail - head - 1;
}

void UartClass::flush() {
     26c:	cf 93       	push	r28
     26e:	df 93       	push	r29
     270:	ec 01       	movw	r28, r24
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:336
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXCIF (transmit
  // complete) bit to 1 during initialization
  if (!_written) {
     272:	8d 89       	ldd	r24, Y+21	; 0x15
     274:	88 23       	and	r24, r24
     276:	61 f0       	breq	.+24     	; 0x290 <UartClass::flush()+0x24>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:351
  // it's appropriate to use for applications where it has only very small benefits, and significant risk of surprising the user and causing
  // breakage of code that would otherwise work. Finally, the previous implementation didn't check if it was called from the current lvl1 ISR
  // and in that case flush(), and write() with full buffer would just straight up hang...

  // Spin until the data-register-empty-interrupt is disabled and TX complete interrupt flag is raised
  while (((*_hwserial_module).CTRLA & USART_DREIE_bm) || (!((*_hwserial_module).STATUS & USART_TXCIF_bm))) {
     278:	ec 85       	ldd	r30, Y+12	; 0x0c
     27a:	fd 85       	ldd	r31, Y+13	; 0x0d
     27c:	85 81       	ldd	r24, Z+5	; 0x05
     27e:	85 fd       	sbrc	r24, 5
     280:	03 c0       	rjmp	.+6      	; 0x288 <UartClass::flush()+0x1c>
     282:	84 81       	ldd	r24, Z+4	; 0x04
     284:	86 fd       	sbrc	r24, 6
     286:	04 c0       	rjmp	.+8      	; 0x290 <UartClass::flush()+0x24>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:355

    // If interrupts are globally disabled or the and DR empty interrupt is disabled,
    // poll the "data register empty" interrupt flag to prevent deadlock
    _poll_tx_data_empty();
     288:	ce 01       	movw	r24, r28
     28a:	0e 94 ea 00 	call	0x1d4	; 0x1d4 <UartClass::_poll_tx_data_empty()>
     28e:	f4 cf       	rjmp	.-24     	; 0x278 <UartClass::flush()+0xc>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:359
  }
  // When we get here, nothing is queued anymore (DREIE is disabled) and
  // the hardware finished transmission (TXCIF is set).
}
     290:	df 91       	pop	r29
     292:	cf 91       	pop	r28
     294:	08 95       	ret

00000296 <Print::write(unsigned char const*, unsigned int)>:
write():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:29
#include "Print.h"

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size) {
     296:	af 92       	push	r10
     298:	bf 92       	push	r11
     29a:	cf 92       	push	r12
     29c:	df 92       	push	r13
     29e:	ef 92       	push	r14
     2a0:	ff 92       	push	r15
     2a2:	0f 93       	push	r16
     2a4:	1f 93       	push	r17
     2a6:	cf 93       	push	r28
     2a8:	df 93       	push	r29
     2aa:	6c 01       	movw	r12, r24
     2ac:	7b 01       	movw	r14, r22
     2ae:	8b 01       	movw	r16, r22
     2b0:	04 0f       	add	r16, r20
     2b2:	15 1f       	adc	r17, r21
     2b4:	eb 01       	movw	r28, r22
     2b6:	5e 01       	movw	r10, r28
     2b8:	ae 18       	sub	r10, r14
     2ba:	bf 08       	sbc	r11, r15
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:31
  size_t n = 0;
  while (size--) {
     2bc:	c0 17       	cp	r28, r16
     2be:	d1 07       	cpc	r29, r17
     2c0:	59 f0       	breq	.+22     	; 0x2d8 <Print::write(unsigned char const*, unsigned int)+0x42>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:32
    if (write(*buffer++)) {
     2c2:	69 91       	ld	r22, Y+
     2c4:	d6 01       	movw	r26, r12
     2c6:	ed 91       	ld	r30, X+
     2c8:	fc 91       	ld	r31, X
     2ca:	01 90       	ld	r0, Z+
     2cc:	f0 81       	ld	r31, Z
     2ce:	e0 2d       	mov	r30, r0
     2d0:	c6 01       	movw	r24, r12
     2d2:	09 95       	icall
     2d4:	89 2b       	or	r24, r25
     2d6:	79 f7       	brne	.-34     	; 0x2b6 <Print::write(unsigned char const*, unsigned int)+0x20>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.cpp:39
    } else {
      break;
    }
  }
  return n;
}
     2d8:	c5 01       	movw	r24, r10
     2da:	df 91       	pop	r29
     2dc:	cf 91       	pop	r28
     2de:	1f 91       	pop	r17
     2e0:	0f 91       	pop	r16
     2e2:	ff 90       	pop	r15
     2e4:	ef 90       	pop	r14
     2e6:	df 90       	pop	r13
     2e8:	cf 90       	pop	r12
     2ea:	bf 90       	pop	r11
     2ec:	af 90       	pop	r10
     2ee:	08 95       	ret

000002f0 <UartClass::operator bool()>:
operator 3():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.h:223
      return write((uint8_t)n);
    }
    using Print::write; // pull in write(str) and write(buf, size) from Print
    explicit operator bool() {
      return true;
    }
     2f0:	81 e0       	ldi	r24, 0x01	; 1
     2f2:	08 95       	ret

000002f4 <micros>:
micros():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:216
  #else
  uint8_t ticks;
  #endif

  /* Save current state and disable interrupts */
  uint8_t status = SREG;
     2f4:	8f b7       	in	r24, 0x3f	; 63
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:217
  cli();
     2f6:	f8 94       	cli
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:223



  /* Get current number of overflows and timer count */
  #if !(defined(MILLIS_USE_TIMERB0)  || defined(MILLIS_USE_TIMERB1) )
  overflows = timer_overflow_count;
     2f8:	20 91 78 38 	lds	r18, 0x3878	; 0x803878 <timer_overflow_count>
     2fc:	30 91 79 38 	lds	r19, 0x3879	; 0x803879 <timer_overflow_count+0x1>
     300:	40 91 7a 38 	lds	r20, 0x387A	; 0x80387a <timer_overflow_count+0x2>
     304:	50 91 7b 38 	lds	r21, 0x387B	; 0x80387b <timer_overflow_count+0x3>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:231
  #endif

  #if defined(MILLIS_USE_TIMERA0)
  ticks = (TIME_TRACKING_TIMER_PERIOD) - TCA0.SPLIT.HCNT;
  #elif defined(MILLIS_USE_TIMERD0)
  TCD0.CTRLE = TCD_SCAPTUREA_bm;
     308:	98 e0       	ldi	r25, 0x08	; 8
     30a:	90 93 84 0a 	sts	0x0A84, r25	; 0x800a84 <vtable for SSD1306Device+0x7f7430>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:232
  while (!(TCD0.STATUS & TCD_CMDRDY_bm)); //wait for sync - should be only one iteration of this loop
     30e:	90 91 8e 0a 	lds	r25, 0x0A8E	; 0x800a8e <vtable for SSD1306Device+0x7f743a>
     312:	91 ff       	sbrs	r25, 1
     314:	fc cf       	rjmp	.-8      	; 0x30e <micros+0x1a>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:233
  ticks = TCD0.CAPTUREA;
     316:	e0 91 a2 0a 	lds	r30, 0x0AA2	; 0x800aa2 <vtable for SSD1306Device+0x7f744e>
     31a:	f0 91 a3 0a 	lds	r31, 0x0AA3	; 0x800aa3 <vtable for SSD1306Device+0x7f744f>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:242
  /* If the timer overflow flag is raised, and the ticks we read are low, then the timer has rolled over but
    ISR has not fired. If we already read a high value of ticks, either we read it just before the overflow,
    so we shouldn't increment overflows, or interrupts are disabled and micros isn't expected to work so it doesn't matter
  */
  #if defined(MILLIS_USE_TIMERD0)
  if ((TCD0.INTFLAGS & TCD_OVF_bm) && !(ticks & 0xFF00)) {
     31e:	90 91 8d 0a 	lds	r25, 0x0A8D	; 0x800a8d <vtable for SSD1306Device+0x7f7439>
     322:	90 ff       	sbrs	r25, 0
     324:	08 c0       	rjmp	.+16     	; 0x336 <micros+0x42>
     326:	bf 01       	movw	r22, r30
     328:	66 27       	eor	r22, r22
     32a:	67 2b       	or	r22, r23
     32c:	21 f4       	brne	.+8      	; 0x336 <micros+0x42>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:251
  if ((_timer->INTFLAGS & TCB_CAPT_bm) && !(ticks & 0xFF00)) {
  #endif
    #if ((defined(MILLIS_USE_TIMERB0)|defined(MILLIS_USE_TIMERB1))&&(F_CPU>1000000))
    overflows++;
    #else
    overflows += 2;
     32e:	2e 5f       	subi	r18, 0xFE	; 254
     330:	3f 4f       	sbci	r19, 0xFF	; 255
     332:	4f 4f       	sbci	r20, 0xFF	; 255
     334:	5f 4f       	sbci	r21, 0xFF	; 255
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:258
  }

  //end getting ticks

  /* Restore state */
  SREG = status;
     336:	8f bf       	out	0x3f, r24	; 63
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:261
  #if defined(MILLIS_USE_TIMERD0)
  #if (F_CPU==20000000UL || F_CPU==10000000UL || F_CPU==5000000UL)
  uint8_t ticks_l = ticks >> 1;
     338:	bf 01       	movw	r22, r30
     33a:	76 95       	lsr	r23
     33c:	67 95       	ror	r22
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:262
  ticks = ticks + ticks_l + ((ticks_l >> 2) - (ticks_l >> 4) + (ticks_l >> 7));
     33e:	cf 01       	movw	r24, r30
     340:	86 0f       	add	r24, r22
     342:	91 1d       	adc	r25, r1
     344:	e6 2f       	mov	r30, r22
     346:	e6 95       	lsr	r30
     348:	e6 95       	lsr	r30
     34a:	76 2f       	mov	r23, r22
     34c:	72 95       	swap	r23
     34e:	7f 70       	andi	r23, 0x0F	; 15
     350:	e7 1b       	sub	r30, r23
     352:	ff 0b       	sbc	r31, r31
     354:	67 fd       	sbrc	r22, 7
     356:	31 96       	adiw	r30, 0x01	; 1
     358:	e8 0f       	add	r30, r24
     35a:	f9 1f       	adc	r31, r25
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:263
  microseconds = overflows * (TIME_TRACKING_CYCLES_PER_OVF / (20))
     35c:	a0 e3       	ldi	r26, 0x30	; 48
     35e:	b3 e0       	ldi	r27, 0x03	; 3
     360:	0e 94 14 0a 	call	0x1428	; 0x1428 <__muluhisi3>
     364:	6e 0f       	add	r22, r30
     366:	7f 1f       	adc	r23, r31
     368:	81 1d       	adc	r24, r1
     36a:	91 1d       	adc	r25, r1
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:308
  microseconds = ((overflows * millisClockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF))
                  + (ticks * (millisClockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF) / TIME_TRACKING_TIMER_PERIOD)));
  #endif
  #endif //end of timer-specific part of micros calculations
  return microseconds;
}
     36c:	08 95       	ret

0000036e <TWI_SlaveTransactionFinished>:
TWI_SlaveTransactionFinished():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:808
    Prepares module for new transaction.

    \param result  The result of the operation.
*/
void TWI_SlaveTransactionFinished(uint8_t result) {
  TWI0.SCTRLA |= (TWI_APIEN_bm | TWI_PIEN_bm);
     36e:	e0 e1       	ldi	r30, 0x10	; 16
     370:	f8 e0       	ldi	r31, 0x08	; 8
     372:	91 85       	ldd	r25, Z+9	; 0x09
     374:	90 66       	ori	r25, 0x60	; 96
     376:	91 87       	std	Z+9, r25	; 0x09
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:809
  twi_mode = TWI_MODE_SLAVE;
     378:	92 e0       	ldi	r25, 0x02	; 2
     37a:	90 93 6a 38 	sts	0x386A, r25	; 0x80386a <twi_mode>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:810
  slave_result = result;
     37e:	80 93 61 38 	sts	0x3861, r24	; 0x803861 <slave_result>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:811
  slave_trans_status = TWIM_STATUS_READY;
     382:	10 92 60 38 	sts	0x3860, r1	; 0x803860 <slave_trans_status>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:812
}
     386:	08 95       	ret

00000388 <TWI_SlaveAddressMatchHandler>:
TWI_SlaveAddressMatchHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:653
    This is the slave address match handler that takes care of responding to
    being addressed by a master

*/
void TWI_SlaveAddressMatchHandler() {
  slave_trans_status = TWIS_STATUS_BUSY;
     388:	81 e0       	ldi	r24, 0x01	; 1
     38a:	80 93 60 38 	sts	0x3860, r24	; 0x803860 <slave_trans_status>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:654
  slave_result = TWIS_RESULT_UNKNOWN;
     38e:	10 92 61 38 	sts	0x3861, r1	; 0x803861 <slave_result>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:657

  /* If Master Read/Slave Write */
  if (TWI0.SSTATUS & TWI_DIR_bm) {
     392:	90 91 1b 08 	lds	r25, 0x081B	; 0x80081b <vtable for SSD1306Device+0x7f71c7>
     396:	91 ff       	sbrs	r25, 1
     398:	0e c0       	rjmp	.+28     	; 0x3b6 <TWI_SlaveAddressMatchHandler+0x2e>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:658
    slave_bytesWritten = 0;
     39a:	10 92 70 38 	sts	0x3870, r1	; 0x803870 <slave_bytesWritten>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:660
    /* Call user function  */
    slave_bytesToWrite = TWI_onSlaveTransmit();
     39e:	f0 e0       	ldi	r31, 0x00	; 0
     3a0:	e0 e0       	ldi	r30, 0x00	; 0
     3a2:	09 95       	icall
     3a4:	80 93 6f 38 	sts	0x386F, r24	; 0x80386f <slave_bytesToWrite>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:661
    twi_mode = TWI_MODE_SLAVE_TRANSMIT;
     3a8:	85 e0       	ldi	r24, 0x05	; 5
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:667
  }
  /* If Master Write/Slave Read */
  else {
    slave_bytesRead = 0;
    slave_callUserReceive = 1;
    twi_mode = TWI_MODE_SLAVE_RECEIVE;
     3aa:	80 93 6a 38 	sts	0x386A, r24	; 0x80386a <twi_mode>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:671
  }

  /* Send ACK, wait for data interrupt */
  TWI0.SCTRLB = TWI_SCMD_RESPONSE_gc;
     3ae:	83 e0       	ldi	r24, 0x03	; 3
     3b0:	80 93 1a 08 	sts	0x081A, r24	; 0x80081a <vtable for SSD1306Device+0x7f71c6>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:674

  /* Data interrupt to follow... */
}
     3b4:	08 95       	ret
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:665
    slave_bytesToWrite = TWI_onSlaveTransmit();
    twi_mode = TWI_MODE_SLAVE_TRANSMIT;
  }
  /* If Master Write/Slave Read */
  else {
    slave_bytesRead = 0;
     3b6:	10 92 71 38 	sts	0x3871, r1	; 0x803871 <slave_bytesRead>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:666
    slave_callUserReceive = 1;
     3ba:	80 93 6e 38 	sts	0x386E, r24	; 0x80386e <slave_callUserReceive>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:667
    twi_mode = TWI_MODE_SLAVE_RECEIVE;
     3be:	86 e0       	ldi	r24, 0x06	; 6
     3c0:	f4 cf       	rjmp	.-24     	; 0x3aa <TWI_SlaveAddressMatchHandler+0x22>

000003c2 <TwoWire::flush()>:
flush():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:385
  //  rxBufferIndex = 0;
  //  rxBufferLength = 0;
  //
  //  /* Turn off and on TWI module */
  //  TWI_Flush();
}
     3c2:	08 95       	ret

000003c4 <TwoWire::peek()>:
peek():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:361
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::peek(void) {
  int value = -1;

  if (rxBufferIndex < rxBufferLength) {
     3c4:	81 e0       	ldi	r24, 0x01	; 1
     3c6:	90 e0       	ldi	r25, 0x00	; 0
     3c8:	30 91 5f 38 	lds	r19, 0x385F	; 0x80385f <TwoWire::rxBufferIndex>
     3cc:	20 91 5e 38 	lds	r18, 0x385E	; 0x80385e <TwoWire::rxBufferLength>
     3d0:	32 17       	cp	r19, r18
     3d2:	10 f4       	brcc	.+4      	; 0x3d8 <TwoWire::peek()+0x14>
     3d4:	90 e0       	ldi	r25, 0x00	; 0
     3d6:	80 e0       	ldi	r24, 0x00	; 0
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:366
    value = rxBuffer[rxBufferIndex];
  }

  return value;
}
     3d8:	91 95       	neg	r25
     3da:	81 95       	neg	r24
     3dc:	91 09       	sbc	r25, r1
     3de:	08 95       	ret

000003e0 <TwoWire::read()>:
read():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:347
// or after requestFrom(address, numBytes)
int TwoWire::read(void) {
  int value = -1;

  // get each successive byte on each call
  if (rxBufferIndex < rxBufferLength) {
     3e0:	80 91 5f 38 	lds	r24, 0x385F	; 0x80385f <TwoWire::rxBufferIndex>
     3e4:	90 91 5e 38 	lds	r25, 0x385E	; 0x80385e <TwoWire::rxBufferLength>
     3e8:	89 17       	cp	r24, r25
     3ea:	30 f4       	brcc	.+12     	; 0x3f8 <TwoWire::read()+0x18>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:349
    value = rxBuffer[rxBufferIndex];
    rxBufferIndex++;
     3ec:	8f 5f       	subi	r24, 0xFF	; 255
     3ee:	80 93 5f 38 	sts	0x385F, r24	; 0x80385f <TwoWire::rxBufferIndex>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:348
int TwoWire::read(void) {
  int value = -1;

  // get each successive byte on each call
  if (rxBufferIndex < rxBufferLength) {
    value = rxBuffer[rxBufferIndex];
     3f2:	90 e0       	ldi	r25, 0x00	; 0
     3f4:	80 e0       	ldi	r24, 0x00	; 0
     3f6:	08 95       	ret
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:344

// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void) {
  int value = -1;
     3f8:	8f ef       	ldi	r24, 0xFF	; 255
     3fa:	9f ef       	ldi	r25, 0xFF	; 255
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:353
    value = rxBuffer[rxBufferIndex];
    rxBufferIndex++;
  }

  return value;
}
     3fc:	08 95       	ret

000003fe <TwoWire::available()>:
available():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:337

// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void) {
  return rxBufferLength - rxBufferIndex;
     3fe:	80 91 5e 38 	lds	r24, 0x385E	; 0x80385e <TwoWire::rxBufferLength>
     402:	90 91 5f 38 	lds	r25, 0x385F	; 0x80385f <TwoWire::rxBufferIndex>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:338
}
     406:	89 1b       	sub	r24, r25
     408:	99 0b       	sbc	r25, r25
     40a:	08 95       	ret

0000040c <TwoWire::write(unsigned char const*, unsigned int)>:
write():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:323
}

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity) {
     40c:	cf 92       	push	r12
     40e:	df 92       	push	r13
     410:	ef 92       	push	r14
     412:	ff 92       	push	r15
     414:	0f 93       	push	r16
     416:	1f 93       	push	r17
     418:	cf 93       	push	r28
     41a:	df 93       	push	r29
     41c:	7c 01       	movw	r14, r24
     41e:	8a 01       	movw	r16, r20
     420:	eb 01       	movw	r28, r22
     422:	6b 01       	movw	r12, r22
     424:	c4 0e       	add	r12, r20
     426:	d5 1e       	adc	r13, r21
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:325

  for (size_t i = 0; i < quantity; i++) {
     428:	cc 15       	cp	r28, r12
     42a:	dd 05       	cpc	r29, r13
     42c:	51 f0       	breq	.+20     	; 0x442 <TwoWire::write(unsigned char const*, unsigned int)+0x36>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:326
    write(*(data + i));
     42e:	69 91       	ld	r22, Y+
     430:	d7 01       	movw	r26, r14
     432:	ed 91       	ld	r30, X+
     434:	fc 91       	ld	r31, X
     436:	01 90       	ld	r0, Z+
     438:	f0 81       	ld	r31, Z
     43a:	e0 2d       	mov	r30, r0
     43c:	c7 01       	movw	r24, r14
     43e:	09 95       	icall
     440:	f3 cf       	rjmp	.-26     	; 0x428 <TwoWire::write(unsigned char const*, unsigned int)+0x1c>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:330
  }

  return quantity;
}
     442:	c8 01       	movw	r24, r16
     444:	df 91       	pop	r29
     446:	cf 91       	pop	r28
     448:	1f 91       	pop	r17
     44a:	0f 91       	pop	r16
     44c:	ff 90       	pop	r15
     44e:	ef 90       	pop	r14
     450:	df 90       	pop	r13
     452:	cf 90       	pop	r12
     454:	08 95       	ret

00000456 <TwoWire::write(unsigned char)>:
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:305
// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data) {
  /* Check if buffer is full */
  if (txBufferLength >= BUFFER_LENGTH) {
     456:	20 91 5d 38 	lds	r18, 0x385D	; 0x80385d <TwoWire::txBufferLength>
     45a:	20 32       	cpi	r18, 0x20	; 32
     45c:	40 f0       	brcs	.+16     	; 0x46e <TwoWire::write(unsigned char)+0x18>
_ZN5Print13setWriteErrorEi():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/api/Print.h:39
    int write_error;
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) {
      write_error = err;
     45e:	21 e0       	ldi	r18, 0x01	; 1
     460:	30 e0       	ldi	r19, 0x00	; 0
     462:	fc 01       	movw	r30, r24
     464:	22 83       	std	Z+2, r18	; 0x02
     466:	33 83       	std	Z+3, r19	; 0x03
write():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:307
    setWriteError();
    return 0;
     468:	90 e0       	ldi	r25, 0x00	; 0
     46a:	80 e0       	ldi	r24, 0x00	; 0
     46c:	08 95       	ret
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:311
  }

  /* Put byte in txBuffer */
  txBuffer[txBufferIndex] = data;
     46e:	80 91 5c 38 	lds	r24, 0x385C	; 0x80385c <TwoWire::txBufferIndex>
     472:	e8 2f       	mov	r30, r24
     474:	f0 e0       	ldi	r31, 0x00	; 0
     476:	e4 5c       	subi	r30, 0xC4	; 196
     478:	f7 4c       	sbci	r31, 0xC7	; 199
     47a:	60 83       	st	Z, r22
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:312
  txBufferIndex++;
     47c:	8f 5f       	subi	r24, 0xFF	; 255
     47e:	80 93 5c 38 	sts	0x385C, r24	; 0x80385c <TwoWire::txBufferIndex>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:315

  /* Update buffer length */
  txBufferLength = txBufferIndex;
     482:	80 93 5d 38 	sts	0x385D, r24	; 0x80385d <TwoWire::txBufferLength>
     486:	81 e0       	ldi	r24, 0x01	; 1
     488:	90 e0       	ldi	r25, 0x00	; 0
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:318

  return 1;
}
     48a:	08 95       	ret

0000048c <datacute_write_wire(unsigned char)>:
datacute_write_wire():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED_Wire.h:18

#ifndef DATACUTE_I2C_WIRE
#define DATACUTE_I2C_WIRE

static bool datacute_write_wire(uint8_t byte) {
	return Wire.write(byte);
     48c:	68 2f       	mov	r22, r24
     48e:	8d e2       	ldi	r24, 0x2D	; 45
     490:	99 e3       	ldi	r25, 0x39	; 57
     492:	0e 94 2b 02 	call	0x456	; 0x456 <TwoWire::write(unsigned char)>
     496:	21 e0       	ldi	r18, 0x01	; 1
     498:	89 2b       	or	r24, r25
     49a:	09 f4       	brne	.+2      	; 0x49e <datacute_write_wire(unsigned char)+0x12>
     49c:	20 e0       	ldi	r18, 0x00	; 0
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED_Wire.h:19
}
     49e:	82 2f       	mov	r24, r18
     4a0:	08 95       	ret

000004a2 <ssd1306_send_stop()>:
ssd1306_send_stop():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:47
static bool ssd1306_send_byte(uint8_t byte) {
	return wireWriteFn(byte);
}

static void ssd1306_send_stop(void) {
	wireEndTransmissionFn();
     4a2:	e0 91 39 39 	lds	r30, 0x3939	; 0x803939 <wireEndTransmissionFn>
     4a6:	f0 91 3a 39 	lds	r31, 0x393A	; 0x80393a <wireEndTransmissionFn+0x1>
     4aa:	09 94       	ijmp

000004ac <ssd1306_send_byte(unsigned char)>:
ssd1306_send_byte():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:43
static void ssd1306_send_start(void) {
	wireBeginTransmissionFn();
}

static bool ssd1306_send_byte(uint8_t byte) {
	return wireWriteFn(byte);
     4ac:	e0 91 3b 39 	lds	r30, 0x393B	; 0x80393b <wireWriteFn>
     4b0:	f0 91 3c 39 	lds	r31, 0x393C	; 0x80393c <wireWriteFn+0x1>
     4b4:	09 94       	ijmp

000004b6 <ssd1306_send_start()>:
ssd1306_send_start():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:39
static void ssd1306_begin(void) {
	wireBeginFn();
}

static void ssd1306_send_start(void) {
	wireBeginTransmissionFn();
     4b6:	e0 91 3d 39 	lds	r30, 0x393D	; 0x80393d <wireBeginTransmissionFn>
     4ba:	f0 91 3e 39 	lds	r31, 0x393E	; 0x80393e <wireBeginTransmissionFn+0x1>
     4be:	09 94       	ijmp

000004c0 <SSD1306Device::setCursor(unsigned char, unsigned char) [clone .constprop.3]>:
setCursor():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:183

void SSD1306Device::setFont(const DCfont *font) {
	oledFont = font;
}

void SSD1306Device::setCursor(uint8_t x, uint8_t y) {
     4c0:	cf 93       	push	r28
     4c2:	df 93       	push	r29
     4c4:	c8 2f       	mov	r28, r24
     4c6:	d6 2f       	mov	r29, r22
ssd1306_send_command_start():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:51
static void ssd1306_send_stop(void) {
	wireEndTransmissionFn();
}

static void ssd1306_send_command_start(void) {
	ssd1306_send_start();
     4c8:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <ssd1306_send_start()>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:52
	ssd1306_send_byte(SSD1306_COMMAND);
     4cc:	80 e0       	ldi	r24, 0x00	; 0
     4ce:	0e 94 56 02 	call	0x4ac	; 0x4ac <ssd1306_send_byte(unsigned char)>
setCursor():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:184
void SSD1306Device::setFont(const DCfont *font) {
	oledFont = font;
}

void SSD1306Device::setCursor(uint8_t x, uint8_t y) {
	ssd1306_send_command3(renderingFrame | ((y + oledOffsetY) & 0x07), 0x10 | (((x + oledOffsetX) & 0xf0) >> 4), (x + oledOffsetX) & 0x0f);
     4d2:	8d 2f       	mov	r24, r29
     4d4:	87 70       	andi	r24, 0x07	; 7
ssd1306_send_command3():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:91
	ssd1306_send_stop();
}

static void ssd1306_send_command3(uint8_t command1, uint8_t command2, uint8_t command3) {
	ssd1306_send_command_start();
	ssd1306_send_byte(command1);
     4d6:	80 6b       	ori	r24, 0xB0	; 176
     4d8:	0e 94 56 02 	call	0x4ac	; 0x4ac <ssd1306_send_byte(unsigned char)>
setCursor():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:184
void SSD1306Device::setFont(const DCfont *font) {
	oledFont = font;
}

void SSD1306Device::setCursor(uint8_t x, uint8_t y) {
	ssd1306_send_command3(renderingFrame | ((y + oledOffsetY) & 0x07), 0x10 | (((x + oledOffsetX) & 0xf0) >> 4), (x + oledOffsetX) & 0x0f);
     4dc:	8c 2f       	mov	r24, r28
     4de:	82 95       	swap	r24
     4e0:	8f 70       	andi	r24, 0x0F	; 15
ssd1306_send_command3():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:92
}

static void ssd1306_send_command3(uint8_t command1, uint8_t command2, uint8_t command3) {
	ssd1306_send_command_start();
	ssd1306_send_byte(command1);
	ssd1306_send_byte(command2);
     4e2:	80 61       	ori	r24, 0x10	; 16
     4e4:	0e 94 56 02 	call	0x4ac	; 0x4ac <ssd1306_send_byte(unsigned char)>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:93
	ssd1306_send_byte(command3);
     4e8:	8c 2f       	mov	r24, r28
     4ea:	8f 70       	andi	r24, 0x0F	; 15
     4ec:	0e 94 56 02 	call	0x4ac	; 0x4ac <ssd1306_send_byte(unsigned char)>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:94
	ssd1306_send_stop();
     4f0:	0e 94 51 02 	call	0x4a2	; 0x4a2 <ssd1306_send_stop()>
setCursor():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:185
	oledFont = font;
}

void SSD1306Device::setCursor(uint8_t x, uint8_t y) {
	ssd1306_send_command3(renderingFrame | ((y + oledOffsetY) & 0x07), 0x10 | (((x + oledOffsetX) & 0xf0) >> 4), (x + oledOffsetX) & 0x0f);
	oledX = x;
     4f4:	c0 93 91 38 	sts	0x3891, r28	; 0x803891 <oledX>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:186
	oledY = y;
     4f8:	d0 93 90 38 	sts	0x3890, r29	; 0x803890 <oledY>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:187
}
     4fc:	df 91       	pop	r29
     4fe:	cf 91       	pop	r28
     500:	08 95       	ret

00000502 <SSD1306Device::newLine(unsigned char)>:
newLine():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:202
	}
	setCursor(0, 0);
}

void SSD1306Device::newLine(uint8_t fontHeight) {
	oledY+=fontHeight;
     502:	80 91 90 38 	lds	r24, 0x3890	; 0x803890 <oledY>
     506:	86 0f       	add	r24, r22
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:203
	if (oledY > oledPages - fontHeight) {
     508:	24 e0       	ldi	r18, 0x04	; 4
     50a:	30 e0       	ldi	r19, 0x00	; 0
     50c:	26 1b       	sub	r18, r22
     50e:	31 09       	sbc	r19, r1
     510:	82 17       	cp	r24, r18
     512:	13 06       	cpc	r1, r19
     514:	09 f0       	breq	.+2      	; 0x518 <SSD1306Device::newLine(unsigned char)+0x16>
     516:	3c f4       	brge	.+14     	; 0x526 <SSD1306Device::newLine(unsigned char)+0x24>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:204
		oledY = oledPages - fontHeight;
     518:	80 93 90 38 	sts	0x3890, r24	; 0x803890 <oledY>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:206
	}
	setCursor(0, oledY);
     51c:	60 91 90 38 	lds	r22, 0x3890	; 0x803890 <oledY>
     520:	80 e0       	ldi	r24, 0x00	; 0
     522:	0c 94 60 02 	jmp	0x4c0	; 0x4c0 <SSD1306Device::setCursor(unsigned char, unsigned char) [clone .constprop.3]>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:204
}

void SSD1306Device::newLine(uint8_t fontHeight) {
	oledY+=fontHeight;
	if (oledY > oledPages - fontHeight) {
		oledY = oledPages - fontHeight;
     526:	84 e0       	ldi	r24, 0x04	; 4
     528:	86 1b       	sub	r24, r22
     52a:	f6 cf       	rjmp	.-20     	; 0x518 <SSD1306Device::newLine(unsigned char)+0x16>

0000052c <SSD1306Device::write(unsigned char)>:
write():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED.cpp:256
			}
		}
	}
	while (--line);
	return 1;
}
     52c:	81 e0       	ldi	r24, 0x01	; 1
     52e:	90 e0       	ldi	r25, 0x00	; 0
     530:	08 95       	ret

00000532 <UartClass::begin(unsigned long)>:
begin():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.h:175
  public:
    inline UartClass(volatile USART_t *hwserial_module, uint8_t hwserial_rx_pin, uint8_t hwserial_tx_pin, uint8_t hwserial_rx_pin_swap, uint8_t hwserial_tx_pin_swap, uint8_t dre_vect_num, uint8_t uart_mux, uint8_t uart_mux_swap);
    bool pins(uint8_t tx, uint8_t rx);
    bool swap(uint8_t state = 1);
    void begin(unsigned long baud) {
      begin(baud, SERIAL_8N1);
     532:	dc 01       	movw	r26, r24
     534:	ed 91       	ld	r30, X+
     536:	fc 91       	ld	r31, X
     538:	06 84       	ldd	r0, Z+14	; 0x0e
     53a:	f7 85       	ldd	r31, Z+15	; 0x0f
     53c:	e0 2d       	mov	r30, r0
     53e:	23 e0       	ldi	r18, 0x03	; 3
     540:	30 e0       	ldi	r19, 0x00	; 0
     542:	09 94       	ijmp

00000544 <updateCurrentMenuItems()>:
updateCurrentMenuItems():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:241
}


void updateCurrentMenuItems() {

    switch (currentMenu) {
     544:	80 91 8b 38 	lds	r24, 0x388B	; 0x80388b <currentMenu>
     548:	90 91 8c 38 	lds	r25, 0x388C	; 0x80388c <currentMenu+0x1>
     54c:	81 30       	cpi	r24, 0x01	; 1
     54e:	91 05       	cpc	r25, r1
     550:	59 f0       	breq	.+22     	; 0x568 <updateCurrentMenuItems()+0x24>
     552:	20 f0       	brcs	.+8      	; 0x55c <updateCurrentMenuItems()+0x18>
     554:	82 30       	cpi	r24, 0x02	; 2
     556:	91 05       	cpc	r25, r1
     558:	01 f1       	breq	.+64     	; 0x59a <updateCurrentMenuItems()+0x56>
     55a:	08 95       	ret
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:244

        case MENU_OCTAVE: {
            currentMenuItems.items[0] = ITEM_OCTAVE;
     55c:	10 92 02 38 	sts	0x3802, r1	; 0x803802 <currentMenuItems>
     560:	10 92 03 38 	sts	0x3803, r1	; 0x803803 <currentMenuItems+0x1>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:263
                    break;
                }

                default: {
                    currentMenuItems.items[0] = ITEM_SHAPE;
                    currentMenuItems.length = 1;
     564:	81 e0       	ldi	r24, 0x01	; 1
     566:	16 c0       	rjmp	.+44     	; 0x594 <updateCurrentMenuItems()+0x50>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:252
        }

        case MENU_OSCILLATOR1: {
            waveform_t currentWaveForm = getOscillatorWaveform(0);

            switch (currentWaveForm) {
     568:	20 91 11 38 	lds	r18, 0x3811	; 0x803811 <oscillators>
     56c:	30 91 12 38 	lds	r19, 0x3812	; 0x803812 <oscillators+0x1>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:254
                case WAVE_PULSE: {
                    currentMenuItems.items[0] = ITEM_SHAPE;
     570:	80 93 02 38 	sts	0x3802, r24	; 0x803802 <currentMenuItems>
     574:	90 93 03 38 	sts	0x3803, r25	; 0x803803 <currentMenuItems+0x1>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:252
        }

        case MENU_OSCILLATOR1: {
            waveform_t currentWaveForm = getOscillatorWaveform(0);

            switch (currentWaveForm) {
     578:	23 2b       	or	r18, r19
     57a:	a1 f7       	brne	.-24     	; 0x564 <updateCurrentMenuItems()+0x20>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:255
                case WAVE_PULSE: {
                    currentMenuItems.items[0] = ITEM_SHAPE;
                    currentMenuItems.items[1] = ITEM_PULSE_RANGE;
     57c:	82 e0       	ldi	r24, 0x02	; 2
     57e:	90 e0       	ldi	r25, 0x00	; 0
     580:	80 93 04 38 	sts	0x3804, r24	; 0x803804 <currentMenuItems+0x2>
     584:	90 93 05 38 	sts	0x3805, r25	; 0x803805 <currentMenuItems+0x3>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:256
                    currentMenuItems.items[2] = ITEM_PULSE_SPEED;
     588:	83 e0       	ldi	r24, 0x03	; 3
     58a:	90 e0       	ldi	r25, 0x00	; 0
     58c:	80 93 06 38 	sts	0x3806, r24	; 0x803806 <currentMenuItems+0x4>
     590:	90 93 07 38 	sts	0x3807, r25	; 0x803807 <currentMenuItems+0x5>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:288

                default: {
                    currentMenuItems.items[0] = ITEM_SHAPE;
                    currentMenuItems.items[1] = ITEM_DETUNE;
                    currentMenuItems.items[2] = ITEM_SYNC;
                    currentMenuItems.length = 3;
     594:	80 93 10 38 	sts	0x3810, r24	; 0x803810 <currentMenuItems+0xe>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:299

        default: {
            break;
        }
    }
}
     598:	08 95       	ret
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:273
        }

        case MENU_OSCILLATOR2: {
            waveform_t currentWaveForm = getOscillatorWaveform(1);

            switch (currentWaveForm) {
     59a:	20 91 24 38 	lds	r18, 0x3824	; 0x803824 <oscillators+0x13>
     59e:	30 91 25 38 	lds	r19, 0x3825	; 0x803825 <oscillators+0x14>
     5a2:	23 2b       	or	r18, r19
     5a4:	e9 f4       	brne	.+58     	; 0x5e0 <updateCurrentMenuItems()+0x9c>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:275
                case WAVE_PULSE: {
                    currentMenuItems.items[0] = ITEM_SHAPE;
     5a6:	21 e0       	ldi	r18, 0x01	; 1
     5a8:	30 e0       	ldi	r19, 0x00	; 0
     5aa:	20 93 02 38 	sts	0x3802, r18	; 0x803802 <currentMenuItems>
     5ae:	30 93 03 38 	sts	0x3803, r19	; 0x803803 <currentMenuItems+0x1>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:276
                    currentMenuItems.items[1] = ITEM_PULSE_RANGE;
     5b2:	80 93 04 38 	sts	0x3804, r24	; 0x803804 <currentMenuItems+0x2>
     5b6:	90 93 05 38 	sts	0x3805, r25	; 0x803805 <currentMenuItems+0x3>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:277
                    currentMenuItems.items[2] = ITEM_PULSE_SPEED;
     5ba:	83 e0       	ldi	r24, 0x03	; 3
     5bc:	90 e0       	ldi	r25, 0x00	; 0
     5be:	80 93 06 38 	sts	0x3806, r24	; 0x803806 <currentMenuItems+0x4>
     5c2:	90 93 07 38 	sts	0x3807, r25	; 0x803807 <currentMenuItems+0x5>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:278
                    currentMenuItems.items[3] = ITEM_DETUNE;
     5c6:	84 e0       	ldi	r24, 0x04	; 4
     5c8:	90 e0       	ldi	r25, 0x00	; 0
     5ca:	80 93 08 38 	sts	0x3808, r24	; 0x803808 <currentMenuItems+0x6>
     5ce:	90 93 09 38 	sts	0x3809, r25	; 0x803809 <currentMenuItems+0x7>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:279
                    currentMenuItems.items[4] = ITEM_SYNC;
     5d2:	85 e0       	ldi	r24, 0x05	; 5
     5d4:	90 e0       	ldi	r25, 0x00	; 0
     5d6:	80 93 0a 38 	sts	0x380A, r24	; 0x80380a <currentMenuItems+0x8>
     5da:	90 93 0b 38 	sts	0x380B, r25	; 0x80380b <currentMenuItems+0x9>
     5de:	da cf       	rjmp	.-76     	; 0x594 <updateCurrentMenuItems()+0x50>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:285
                    currentMenuItems.length = 5;
                    break;
                }

                default: {
                    currentMenuItems.items[0] = ITEM_SHAPE;
     5e0:	81 e0       	ldi	r24, 0x01	; 1
     5e2:	90 e0       	ldi	r25, 0x00	; 0
     5e4:	80 93 02 38 	sts	0x3802, r24	; 0x803802 <currentMenuItems>
     5e8:	90 93 03 38 	sts	0x3803, r25	; 0x803803 <currentMenuItems+0x1>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:286
                    currentMenuItems.items[1] = ITEM_DETUNE;
     5ec:	84 e0       	ldi	r24, 0x04	; 4
     5ee:	90 e0       	ldi	r25, 0x00	; 0
     5f0:	80 93 04 38 	sts	0x3804, r24	; 0x803804 <currentMenuItems+0x2>
     5f4:	90 93 05 38 	sts	0x3805, r25	; 0x803805 <currentMenuItems+0x3>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:287
                    currentMenuItems.items[2] = ITEM_SYNC;
     5f8:	85 e0       	ldi	r24, 0x05	; 5
     5fa:	90 e0       	ldi	r25, 0x00	; 0
     5fc:	80 93 06 38 	sts	0x3806, r24	; 0x803806 <currentMenuItems+0x4>
     600:	90 93 07 38 	sts	0x3807, r25	; 0x803807 <currentMenuItems+0x5>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:288
                    currentMenuItems.length = 3;
     604:	83 e0       	ldi	r24, 0x03	; 3
     606:	c6 cf       	rjmp	.-116    	; 0x594 <updateCurrentMenuItems()+0x50>

00000608 <tiny4koled_beginTransmission_wire()>:
beginTransmission():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:256

void TwoWire::beginTransmission(uint8_t address) {
  // indicate that we are transmitting
  transmitting = 1;
  // set address of targeted slave
  txAddress = address;
     608:	8c e3       	ldi	r24, 0x3C	; 60
     60a:	80 93 3b 38 	sts	0x383B, r24	; 0x80383b <TwoWire::txAddress>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:258
  // reset tx buffer iterator vars
  txBufferIndex = 0;
     60e:	10 92 5c 38 	sts	0x385C, r1	; 0x80385c <TwoWire::txBufferIndex>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:259
  txBufferLength = 0;
     612:	10 92 5d 38 	sts	0x385D, r1	; 0x80385d <TwoWire::txBufferLength>
tiny4koled_beginTransmission_wire():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED_Wire.h:38
#endif

static bool tiny4koled_beginTransmission_wire(void) {
	Wire.beginTransmission(SSD1306);
	return true;
}
     616:	81 e0       	ldi	r24, 0x01	; 1
     618:	08 95       	ret

0000061a <datacute_endTransmission_wire()>:
TWI_MasterWriteRead():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:325
uint8_t TWI_MasterWriteRead(uint8_t slave_address,
                            uint8_t *write_data,
                            uint8_t bytes_to_write,
                            uint8_t bytes_to_read,
                            uint8_t send_stop) {
  if (twi_mode != TWI_MODE_MASTER) {
     61a:	90 91 6a 38 	lds	r25, 0x386A	; 0x80386a <twi_mode>
     61e:	91 30       	cpi	r25, 0x01	; 1
     620:	09 f0       	breq	.+2      	; 0x624 <datacute_endTransmission_wire()+0xa>
     622:	5a c0       	rjmp	.+180    	; 0x6d8 <datacute_endTransmission_wire()+0xbe>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:330
    return false;
  }

  /*Initiate transaction if bus is ready. */
  if (master_trans_status == TWIM_STATUS_READY) {
     624:	80 91 6b 38 	lds	r24, 0x386B	; 0x80386b <master_trans_status>
     628:	81 11       	cpse	r24, r1
     62a:	5c c0       	rjmp	.+184    	; 0x6e4 <datacute_endTransmission_wire()+0xca>
endTransmission():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:281
//  no call to endTransmission(true) is made. Some I2C
//  devices will behave oddly if they do not see a STOP.
//
uint8_t TwoWire::endTransmission(bool sendStop) {
  // transmit buffer (blocking)
  uint8_t status = TWI_MasterWrite(txAddress, txBuffer, txBufferLength, sendStop);
     62c:	20 91 5d 38 	lds	r18, 0x385D	; 0x80385d <TwoWire::txBufferLength>
     630:	80 91 3b 38 	lds	r24, 0x383B	; 0x80383b <TwoWire::txAddress>
TWI_MasterWriteRead():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:332

    master_trans_status = TWIM_STATUS_BUSY;
     634:	90 93 6b 38 	sts	0x386B, r25	; 0x80386b <master_trans_status>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:333
    master_result = TWIM_RESULT_UNKNOWN;
     638:	10 92 6c 38 	sts	0x386C, r1	; 0x80386c <master_result>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:335

    master_writeData = write_data;
     63c:	4c e3       	ldi	r20, 0x3C	; 60
     63e:	58 e3       	ldi	r21, 0x38	; 56
     640:	40 93 63 38 	sts	0x3863, r20	; 0x803863 <master_writeData>
     644:	50 93 64 38 	sts	0x3864, r21	; 0x803864 <master_writeData+0x1>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:337

    master_bytesToWrite = bytes_to_write;
     648:	20 93 66 38 	sts	0x3866, r18	; 0x803866 <master_bytesToWrite>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:338
    master_bytesToRead = bytes_to_read;
     64c:	10 92 68 38 	sts	0x3868, r1	; 0x803868 <master_bytesToRead>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:339
    master_bytesWritten = 0;
     650:	10 92 65 38 	sts	0x3865, r1	; 0x803865 <master_bytesWritten>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:340
    master_bytesRead = 0;
     654:	10 92 69 38 	sts	0x3869, r1	; 0x803869 <master_bytesRead>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:341
    master_sendStop = send_stop;
     658:	90 93 67 38 	sts	0x3867, r25	; 0x803867 <master_sendStop>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:342
    master_slaveAddress = slave_address << 1;
     65c:	88 0f       	add	r24, r24
     65e:	80 93 62 38 	sts	0x3862, r24	; 0x803862 <master_slaveAddress>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:365
      uint8_t readAddress = ADD_READ_BIT(master_slaveAddress);
      TWI0.MADDR = readAddress;
    }

    else if (master_bytesToWrite == 0 && master_bytesToRead == 0) {
      twi_mode = TWI_MODE_MASTER_TRANSMIT;
     662:	93 e0       	ldi	r25, 0x03	; 3
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:359

    /* If read command, send the START condition + Address +
       'R/_W = 1'
    */
    else if (master_bytesToRead > 0) {
      twi_mode = TWI_MODE_MASTER_RECEIVE;
     664:	24 e0       	ldi	r18, 0x04	; 4
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:349
  trigger_action:

    /* If write command, send the START condition + Address +
       'R/_W = 0'
    */
    if (master_bytesToWrite > 0) {
     666:	80 91 66 38 	lds	r24, 0x3866	; 0x803866 <master_bytesToWrite>
     66a:	88 23       	and	r24, r24
     66c:	31 f0       	breq	.+12     	; 0x67a <datacute_endTransmission_wire()+0x60>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:365
      uint8_t readAddress = ADD_READ_BIT(master_slaveAddress);
      TWI0.MADDR = readAddress;
    }

    else if (master_bytesToWrite == 0 && master_bytesToRead == 0) {
      twi_mode = TWI_MODE_MASTER_TRANSMIT;
     66e:	90 93 6a 38 	sts	0x386A, r25	; 0x80386a <twi_mode>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:366
      uint8_t writeAddress = ADD_WRITE_BIT(master_slaveAddress);
     672:	80 91 62 38 	lds	r24, 0x3862	; 0x803862 <master_slaveAddress>
     676:	8e 7f       	andi	r24, 0xFE	; 254
     678:	09 c0       	rjmp	.+18     	; 0x68c <datacute_endTransmission_wire()+0x72>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:358
    }

    /* If read command, send the START condition + Address +
       'R/_W = 1'
    */
    else if (master_bytesToRead > 0) {
     67a:	80 91 68 38 	lds	r24, 0x3868	; 0x803868 <master_bytesToRead>
     67e:	88 23       	and	r24, r24
     680:	41 f0       	breq	.+16     	; 0x692 <datacute_endTransmission_wire()+0x78>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:359
      twi_mode = TWI_MODE_MASTER_RECEIVE;
     682:	20 93 6a 38 	sts	0x386A, r18	; 0x80386a <twi_mode>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:360
      uint8_t readAddress = ADD_READ_BIT(master_slaveAddress);
     686:	80 91 62 38 	lds	r24, 0x3862	; 0x803862 <master_slaveAddress>
     68a:	81 60       	ori	r24, 0x01	; 1
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:367
    }

    else if (master_bytesToWrite == 0 && master_bytesToRead == 0) {
      twi_mode = TWI_MODE_MASTER_TRANSMIT;
      uint8_t writeAddress = ADD_WRITE_BIT(master_slaveAddress);
      TWI0.MADDR = writeAddress;
     68c:	80 93 17 08 	sts	0x0817, r24	; 0x800817 <vtable for SSD1306Device+0x7f71c3>
     690:	08 c0       	rjmp	.+16     	; 0x6a2 <datacute_endTransmission_wire()+0x88>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:364
      twi_mode = TWI_MODE_MASTER_RECEIVE;
      uint8_t readAddress = ADD_READ_BIT(master_slaveAddress);
      TWI0.MADDR = readAddress;
    }

    else if (master_bytesToWrite == 0 && master_bytesToRead == 0) {
     692:	80 91 66 38 	lds	r24, 0x3866	; 0x803866 <master_bytesToWrite>
     696:	81 11       	cpse	r24, r1
     698:	04 c0       	rjmp	.+8      	; 0x6a2 <datacute_endTransmission_wire()+0x88>
     69a:	80 91 68 38 	lds	r24, 0x3868	; 0x803868 <master_bytesToRead>
     69e:	88 23       	and	r24, r24
     6a0:	31 f3       	breq	.-52     	; 0x66e <datacute_endTransmission_wire()+0x54>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:371
      uint8_t writeAddress = ADD_WRITE_BIT(master_slaveAddress);
      TWI0.MADDR = writeAddress;
    }

    /* Arduino requires blocking function */
    while (master_result == TWIM_RESULT_UNKNOWN) {}
     6a2:	80 91 6c 38 	lds	r24, 0x386C	; 0x80386c <master_result>
     6a6:	88 23       	and	r24, r24
     6a8:	e1 f3       	breq	.-8      	; 0x6a2 <datacute_endTransmission_wire()+0x88>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:374

    // in case of arbitration lost, retry sending
    if (master_result == TWIM_RESULT_ARBITRATION_LOST) {
     6aa:	80 91 6c 38 	lds	r24, 0x386C	; 0x80386c <master_result>
     6ae:	83 30       	cpi	r24, 0x03	; 3
     6b0:	d1 f2       	breq	.-76     	; 0x666 <datacute_endTransmission_wire()+0x4c>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:379
      goto trigger_action;
    }

    uint8_t ret = 0;
    if (master_bytesToRead > 0) {
     6b2:	80 91 68 38 	lds	r24, 0x3868	; 0x803868 <master_bytesToRead>
     6b6:	88 23       	and	r24, r24
     6b8:	39 f0       	breq	.+14     	; 0x6c8 <datacute_endTransmission_wire()+0xae>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:381
      // return bytes really read
      ret = master_bytesRead;
     6ba:	80 91 69 38 	lds	r24, 0x3869	; 0x803869 <master_bytesRead>
endTransmission():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:284

  // reset tx buffer iterator vars
  txBufferIndex = 0;
     6be:	10 92 5c 38 	sts	0x385C, r1	; 0x80385c <TwoWire::txBufferIndex>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:285
  txBufferLength = 0;
     6c2:	10 92 5d 38 	sts	0x385D, r1	; 0x80385d <TwoWire::txBufferLength>
datacute_endTransmission_wire():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED_Wire.h:31
static void datacute_end_read_wire(void) __attribute__((unused));
static void datacute_end_read_wire(void) {}

static uint8_t datacute_endTransmission_wire(void) {
	return Wire.endTransmission();
}
     6c6:	08 95       	ret
TWI_MasterWriteRead():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:384
    } else {
      // return 0 if success, >0 otherwise (follow classic AVR conventions)
      switch (master_result) {
     6c8:	80 91 6c 38 	lds	r24, 0x386C	; 0x80386c <master_result>
     6cc:	82 30       	cpi	r24, 0x02	; 2
     6ce:	51 f0       	breq	.+20     	; 0x6e4 <datacute_endTransmission_wire()+0xca>
     6d0:	85 30       	cpi	r24, 0x05	; 5
     6d2:	21 f0       	breq	.+8      	; 0x6dc <datacute_endTransmission_wire()+0xc2>
     6d4:	81 30       	cpi	r24, 0x01	; 1
     6d6:	21 f4       	brne	.+8      	; 0x6e0 <datacute_endTransmission_wire()+0xc6>
datacute_endTransmission_wire():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:386
        case TWIM_RESULT_OK:
          ret = 0;
     6d8:	80 e0       	ldi	r24, 0x00	; 0
     6da:	f1 cf       	rjmp	.-30     	; 0x6be <datacute_endTransmission_wire()+0xa4>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:392
          break;
        case TWIM_RESULT_BUFFER_OVERFLOW:
          ret = 1;
          break;
        case TWIM_RESULT_NACK_RECEIVED:
          ret = 3;
     6dc:	83 e0       	ldi	r24, 0x03	; 3
     6de:	ef cf       	rjmp	.-34     	; 0x6be <datacute_endTransmission_wire()+0xa4>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:395
          break;
        default:
          ret = 4;
     6e0:	84 e0       	ldi	r24, 0x04	; 4
     6e2:	ed cf       	rjmp	.-38     	; 0x6be <datacute_endTransmission_wire()+0xa4>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:402
      }
    }

    return ret;
  } else {
    return 1;
     6e4:	81 e0       	ldi	r24, 0x01	; 1
     6e6:	eb cf       	rjmp	.-42     	; 0x6be <datacute_endTransmission_wire()+0xa4>

000006e8 <tiny4koled_begin_wire()>:
tiny4koled_begin_wire():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED_Wire.h:48
	tiny4koled_beginTransmission_wire();
	return (datacute_endTransmission_wire()==noError);
}
#endif

static void tiny4koled_begin_wire(void) {
     6e8:	cf 92       	push	r12
     6ea:	df 92       	push	r13
     6ec:	ef 92       	push	r14
     6ee:	ff 92       	push	r15
begin():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:169
    #endif
  #endif
}

void TwoWire::begin(void) {
  rxBufferIndex = 0;
     6f0:	10 92 5f 38 	sts	0x385F, r1	; 0x80385f <TwoWire::rxBufferIndex>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:170
  rxBufferLength = 0;
     6f4:	10 92 5e 38 	sts	0x385E, r1	; 0x80385e <TwoWire::rxBufferLength>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:172

  txBufferIndex = 0;
     6f8:	10 92 5c 38 	sts	0x385C, r1	; 0x80385c <TwoWire::txBufferIndex>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/Wire.cpp:173
  txBufferLength = 0;
     6fc:	10 92 5d 38 	sts	0x385D, r1	; 0x80385d <TwoWire::txBufferLength>
TWI_MasterInit():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:64
    Remember to enable interrupts globally from the main application.

    \param frequency            The required baud.
*/
void TWI_MasterInit(uint32_t frequency) {
  if (twi_mode != TWI_MODE_UNKNOWN) {
     700:	80 91 6a 38 	lds	r24, 0x386A	; 0x80386a <twi_mode>
     704:	81 11       	cpse	r24, r1
     706:	1a c0       	rjmp	.+52     	; 0x73c <tiny4koled_begin_wire()+0x54>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:77
  } else {
    PORTA.OUTCLR=0x0C; //bits 2 and 3
  }
  #else // megaTinyCore
    #if defined(PORTMUX_TWI0_bm)
      if ((PORTMUX.CTRLB & PORTMUX_TWI0_bm)) {
     708:	80 91 01 02 	lds	r24, 0x0201	; 0x800201 <vtable for SSD1306Device+0x7f6bad>
     70c:	84 ff       	sbrs	r24, 4
     70e:	3c c0       	rjmp	.+120    	; 0x788 <tiny4koled_begin_wire()+0xa0>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:80
        // make sure we don't get errata'ed - make sure their bits in the
        // PORTx.OUT registers are 0.
        PORTA.OUTCLR=0x06; // if swapped it's on PA1, PA2
     710:	86 e0       	ldi	r24, 0x06	; 6
     712:	80 93 06 04 	sts	0x0406, r24	; 0x800406 <vtable for SSD1306Device+0x7f6db2>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:91
    #else
      PORTB.OUTCLR=0x03; // else, zero series, no remapping, it's on PB0, PB1
    #endif
  #endif

  twi_mode = TWI_MODE_MASTER;
     716:	81 e0       	ldi	r24, 0x01	; 1
     718:	80 93 6a 38 	sts	0x386A, r24	; 0x80386a <twi_mode>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:93

  master_bytesRead = 0;
     71c:	10 92 69 38 	sts	0x3869, r1	; 0x803869 <master_bytesRead>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:94
  master_bytesWritten = 0;
     720:	10 92 65 38 	sts	0x3865, r1	; 0x803865 <master_bytesWritten>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:95
  master_trans_status = TWIM_STATUS_READY;
     724:	10 92 6b 38 	sts	0x386B, r1	; 0x80386b <master_trans_status>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:96
  master_result = TWIM_RESULT_UNKNOWN;
     728:	10 92 6c 38 	sts	0x386C, r1	; 0x80386c <master_result>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:98

  TWI0.MCTRLA = TWI_RIEN_bm | TWI_WIEN_bm | TWI_ENABLE_bm;
     72c:	91 ec       	ldi	r25, 0xC1	; 193
     72e:	90 93 13 08 	sts	0x0813, r25	; 0x800813 <vtable for SSD1306Device+0x7f71bf>
TWI_MasterSetBaud():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:246
    frequency = 100000;
    t_rise    = 1000;
  }

  uint32_t baud = (F_CPU / frequency - F_CPU / 1000 / 1000 * t_rise / 1000 - 10) / 2;
  TWI0.MBAUD = (uint8_t)baud;
     732:	95 e5       	ldi	r25, 0x55	; 85
     734:	90 93 16 08 	sts	0x0816, r25	; 0x800816 <vtable for SSD1306Device+0x7f71c2>
TWI_MasterInit():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:100
  master_trans_status = TWIM_STATUS_READY;
  master_result = TWIM_RESULT_UNKNOWN;

  TWI0.MCTRLA = TWI_RIEN_bm | TWI_WIEN_bm | TWI_ENABLE_bm;
  TWI_MasterSetBaud(frequency);
  TWI0.MSTATUS = TWI_BUSSTATE_IDLE_gc;
     738:	80 93 15 08 	sts	0x0815, r24	; 0x800815 <vtable for SSD1306Device+0x7f71c1>
tiny4koled_check_wire():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED_Wire.h:43
}

#ifndef TINY4KOLED_QUICK_BEGIN
inline static bool tiny4koled_check_wire(void) {
	const uint8_t noError = 0x00;
	tiny4koled_beginTransmission_wire();
     73c:	0e 94 04 03 	call	0x608	; 0x608 <tiny4koled_beginTransmission_wire()>
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED_Wire.h:44
	return (datacute_endTransmission_wire()==noError);
     740:	0e 94 0d 03 	call	0x61a	; 0x61a <datacute_endTransmission_wire()>
tiny4koled_begin_wire():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED_Wire.h:51
#endif

static void tiny4koled_begin_wire(void) {
	Wire.begin();
#ifndef TINY4KOLED_QUICK_BEGIN
	while (!tiny4koled_check_wire()) {
     744:	88 23       	and	r24, r24
     746:	21 f1       	breq	.+72     	; 0x790 <tiny4koled_begin_wire()+0xa8>
delay():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:316

#endif //end of non-MILLIS_USE_TIMERNONE code

#if !(defined(MILLIS_USE_TIMERNONE) || defined(MILLIS_USE_TIMERRTC)) //delay implementation when we do have micros()
void delay(unsigned long ms) {
  uint32_t start_time = micros(), delay_time = 1000 * ms;
     748:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <micros>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:319

  /* Calculate future time to return */
  uint32_t return_time = start_time + delay_time;
     74c:	6b 01       	movw	r12, r22
     74e:	7c 01       	movw	r14, r24
     750:	20 e1       	ldi	r18, 0x10	; 16
     752:	c2 0e       	add	r12, r18
     754:	27 e2       	ldi	r18, 0x27	; 39
     756:	d2 1e       	adc	r13, r18
     758:	e1 1c       	adc	r14, r1
     75a:	f1 1c       	adc	r15, r1
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:322

  /* If return time overflows */
  if (return_time < delay_time) {
     75c:	80 e1       	ldi	r24, 0x10	; 16
     75e:	c8 16       	cp	r12, r24
     760:	87 e2       	ldi	r24, 0x27	; 39
     762:	d8 06       	cpc	r13, r24
     764:	e1 04       	cpc	r14, r1
     766:	f1 04       	cpc	r15, r1
     768:	38 f4       	brcc	.+14     	; 0x778 <tiny4koled_begin_wire()+0x90>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:324
    /* Wait until micros overflows */
    while (micros() > return_time);
     76a:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <micros>
     76e:	c6 16       	cp	r12, r22
     770:	d7 06       	cpc	r13, r23
     772:	e8 06       	cpc	r14, r24
     774:	f9 06       	cpc	r15, r25
     776:	c8 f3       	brcs	.-14     	; 0x76a <tiny4koled_begin_wire()+0x82>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:328
  }

  /* Wait until return time */
  while (micros() < return_time);
     778:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <micros>
     77c:	6c 15       	cp	r22, r12
     77e:	7d 05       	cpc	r23, r13
     780:	8e 05       	cpc	r24, r14
     782:	9f 05       	cpc	r25, r15
     784:	c8 f3       	brcs	.-14     	; 0x778 <tiny4koled_begin_wire()+0x90>
     786:	da cf       	rjmp	.-76     	; 0x73c <tiny4koled_begin_wire()+0x54>
TWI_MasterInit():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:82
      if ((PORTMUX.CTRLB & PORTMUX_TWI0_bm)) {
        // make sure we don't get errata'ed - make sure their bits in the
        // PORTx.OUT registers are 0.
        PORTA.OUTCLR=0x06; // if swapped it's on PA1, PA2
      } else {
        PORTB.OUTCLR=0x03; // else PB0, PB1
     788:	83 e0       	ldi	r24, 0x03	; 3
     78a:	80 93 26 04 	sts	0x0426, r24	; 0x800426 <vtable for SSD1306Device+0x7f6dd2>
     78e:	c3 cf       	rjmp	.-122    	; 0x716 <tiny4koled_begin_wire()+0x2e>
tiny4koled_begin_wire():
/Users/lerouxb/Documents/Arduino/libraries/Tiny4kOLED/src/Tiny4kOLED_Wire.h:55
		delay(10);
	}
#endif
}
     790:	ff 90       	pop	r15
     792:	ef 90       	pop	r14
     794:	df 90       	pop	r13
     796:	cf 90       	pop	r12
     798:	08 95       	ret

0000079a <digitalWrite.constprop.5>:
digitalWrite():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:221
  that the value of the port was set correctly when it was
  changed to an output. Code in the wild relies on this behavior.
  */

  if (val == LOW) { /* If LOW */
    port->OUTCLR = bit_mask;
     79a:	90 e4       	ldi	r25, 0x40	; 64
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:220
  you could digitalWrite() a pin while it's an input, to ensure
  that the value of the port was set correctly when it was
  changed to an output. Code in the wild relies on this behavior.
  */

  if (val == LOW) { /* If LOW */
     79c:	81 11       	cpse	r24, r1
     79e:	13 c0       	rjmp	.+38     	; 0x7c6 <digitalWrite.constprop.5+0x2c>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:221
    port->OUTCLR = bit_mask;
     7a0:	90 93 06 04 	sts	0x0406, r25	; 0x800406 <vtable for SSD1306Device+0x7f6db2>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:238
  } else {
    port->OUTSET = bit_mask;
  }

  /* Input direction */
  if (!(port->DIR & bit_mask)) {
     7a4:	90 91 00 04 	lds	r25, 0x0400	; 0x800400 <vtable for SSD1306Device+0x7f6dac>
     7a8:	96 fd       	sbrc	r25, 6
     7aa:	0a c0       	rjmp	.+20     	; 0x7c0 <digitalWrite.constprop.5+0x26>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:251

    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);

    /* Save system status and disable interrupts */
    uint8_t status = SREG;
     7ac:	9f b7       	in	r25, 0x3f	; 63
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:252
    cli();
     7ae:	f8 94       	cli
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:254

    if (val == LOW) {
     7b0:	81 11       	cpse	r24, r1
     7b2:	0c c0       	rjmp	.+24     	; 0x7cc <digitalWrite.constprop.5+0x32>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:256
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
     7b4:	80 91 16 04 	lds	r24, 0x0416	; 0x800416 <vtable for SSD1306Device+0x7f6dc2>
     7b8:	87 7f       	andi	r24, 0xF7	; 247
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:259
    } else {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
     7ba:	80 93 16 04 	sts	0x0416, r24	; 0x800416 <vtable for SSD1306Device+0x7f6dc2>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:263
    }

    /* Restore system status */
    SREG = status;
     7be:	9f bf       	out	0x3f, r25	; 63
turnOffPWM():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:150
    /* we don't need the type b timers as this core does not use them for PWM      */

    // 1-series parts have a DAC that we can use...
    #if defined(DAC0)
      case DACOUT:
        DAC0.CTRLA = 0x00;
     7c0:	10 92 a0 06 	sts	0x06A0, r1	; 0x8006a0 <vtable for SSD1306Device+0x7f704c>
digitalWrite():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:270
  /* Turn off PWM if applicable */
  // If the pin supports PWM output, we need to turn it off
  // Better to do so AFTER we have set PORTx.OUT to what we want it to be when we're done
  // The glitch would be super short, of course, but why make a glitch we don't have to?
  turnOffPWM(pin);
}
     7c4:	08 95       	ret
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:234
    // val will now be 0 (LOW) if the toggling made it LOW
    // or bit_mask if not. And further down, we only need to
    // know if it's
  /* If HIGH OR  > TOGGLE  */
  } else {
    port->OUTSET = bit_mask;
     7c6:	90 93 05 04 	sts	0x0405, r25	; 0x800405 <vtable for SSD1306Device+0x7f6db1>
     7ca:	ec cf       	rjmp	.-40     	; 0x7a4 <digitalWrite.constprop.5+0xa>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:259
    if (val == LOW) {
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
    } else {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
     7cc:	80 91 16 04 	lds	r24, 0x0416	; 0x800416 <vtable for SSD1306Device+0x7f6dc2>
     7d0:	88 60       	ori	r24, 0x08	; 8
     7d2:	f3 cf       	rjmp	.-26     	; 0x7ba <digitalWrite.constprop.5+0x20>

000007d4 <pinMode>:
pinMode():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:41
    // taking shortcuts we disapprove of, but to call out things that are virtually guaranteed to be a bug.
    // Passing -1/255/NOT_A_PIN to the digital I/O functions is most likely intentional.
      badArg("Digital pin is constant, but not a valid pin");
}

void pinMode(uint8_t pin, uint8_t mode) {
     7d4:	cf 93       	push	r28
     7d6:	df 93       	push	r29
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:44
  check_valid_digital_pin(pin);

  uint8_t bit_mask = digitalPinToBitMask(pin);
     7d8:	82 31       	cpi	r24, 0x12	; 18
     7da:	98 f4       	brcc	.+38     	; 0x802 <__DATA_REGION_LENGTH__+0x2>
check_valid_digital_pin():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:32
#include "pins_arduino.h"


inline __attribute__((always_inline)) void check_valid_digital_pin(pin_size_t pin)
{
  if(__builtin_constant_p(pin))
     7dc:	90 e0       	ldi	r25, 0x00	; 0
pinMode():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:44
}

void pinMode(uint8_t pin, uint8_t mode) {
  check_valid_digital_pin(pin);

  uint8_t bit_mask = digitalPinToBitMask(pin);
     7de:	fc 01       	movw	r30, r24
     7e0:	e8 5e       	subi	r30, 0xE8	; 232
     7e2:	f9 46       	sbci	r31, 0x69	; 105
     7e4:	20 81       	ld	r18, Z
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:46

  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
     7e6:	2f 3f       	cpi	r18, 0xFF	; 255
     7e8:	61 f0       	breq	.+24     	; 0x802 <__DATA_REGION_LENGTH__+0x2>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:50
    return;
  }

  PORT_t *port = digitalPinToPortStruct(pin);
     7ea:	fc 01       	movw	r30, r24
     7ec:	ea 5f       	subi	r30, 0xFA	; 250
     7ee:	f9 46       	sbci	r31, 0x69	; 105
     7f0:	e0 81       	ld	r30, Z
     7f2:	30 e2       	ldi	r19, 0x20	; 32
     7f4:	e3 9f       	mul	r30, r19
     7f6:	f0 01       	movw	r30, r0
     7f8:	11 24       	eor	r1, r1
     7fa:	fc 5f       	subi	r31, 0xFC	; 252
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:55
  if (port == NULL) {
    return;
  }

  if (mode == OUTPUT) {
     7fc:	61 30       	cpi	r22, 0x01	; 1
     7fe:	21 f4       	brne	.+8      	; 0x808 <__DATA_REGION_LENGTH__+0x8>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:58

    /* Configure direction as output */
    port->DIRSET = bit_mask;
     800:	21 83       	std	Z+1, r18	; 0x01
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:95
    }

    /* Restore state */
    SREG = status;
  }
}
     802:	df 91       	pop	r29
     804:	cf 91       	pop	r28
     806:	08 95       	ret
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:62
    /* Configure direction as output */
    port->DIRSET = bit_mask;

  } else { /* mode == INPUT or INPUT_PULLUP */

    uint8_t bit_pos = digitalPinToBitPosition(pin);
     808:	8c 50       	subi	r24, 0x0C	; 12
     80a:	9a 46       	sbci	r25, 0x6A	; 106
     80c:	ec 01       	movw	r28, r24
     80e:	a8 81       	ld	r26, Y
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:64
    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
     810:	af 3f       	cpi	r26, 0xFF	; 255
     812:	71 f0       	breq	.+28     	; 0x830 <__DATA_REGION_LENGTH__+0x30>
     814:	cf 01       	movw	r24, r30
     816:	40 96       	adiw	r24, 0x10	; 16
     818:	a8 0f       	add	r26, r24
     81a:	b9 2f       	mov	r27, r25
     81c:	b1 1d       	adc	r27, r1
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:67

    /* Save state */
    uint8_t status = SREG;
     81e:	9f b7       	in	r25, 0x3f	; 63
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:68
    cli();
     820:	f8 94       	cli
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:71

    /* Configure direction as input */
    port->DIRCLR = bit_mask;
     822:	22 83       	std	Z+2, r18	; 0x02
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:77

    /* Configure pull-up resistor */
    if (mode == INPUT_PULLUP) {

      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
     824:	8c 91       	ld	r24, X
     826:	88 60       	ori	r24, 0x08	; 8
     828:	8c 93       	st	X, r24
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:82
      /* Considered this, it was in some 2.2.0 releases. This is debatable - it actually broke Wire...
       * though only because of errata effecting Wire that wasn't explicitly accounted for.
       */
      // emulate setting of the port output register on classic AVR
      port->OUTSET=bit_mask;
     82a:	25 83       	std	Z+5, r18	; 0x05
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:93
      port->OUTCLR=bit_mask;

    }

    /* Restore state */
    SREG = status;
     82c:	9f bf       	out	0x3f, r25	; 63
     82e:	e9 cf       	rjmp	.-46     	; 0x802 <__DATA_REGION_LENGTH__+0x2>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:64

  } else { /* mode == INPUT or INPUT_PULLUP */

    uint8_t bit_pos = digitalPinToBitPosition(pin);
    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
     830:	b0 e0       	ldi	r27, 0x00	; 0
     832:	a0 e0       	ldi	r26, 0x00	; 0
     834:	f4 cf       	rjmp	.-24     	; 0x81e <__DATA_REGION_LENGTH__+0x1e>

00000836 <UartClass::begin(unsigned long, unsigned int)>:
begin():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:172
    _pin_set = 0;
    return false;
  }
}

void UartClass::begin(unsigned long baud, uint16_t config) {
     836:	8f 92       	push	r8
     838:	9f 92       	push	r9
     83a:	af 92       	push	r10
     83c:	bf 92       	push	r11
     83e:	df 92       	push	r13
     840:	ef 92       	push	r14
     842:	ff 92       	push	r15
     844:	0f 93       	push	r16
     846:	1f 93       	push	r17
     848:	cf 93       	push	r28
     84a:	df 93       	push	r29
     84c:	ec 01       	movw	r28, r24
     84e:	4a 01       	movw	r8, r20
     850:	5b 01       	movw	r10, r22
     852:	d2 2e       	mov	r13, r18
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:179
    if (baud > (F_CPU/8)) badArg("Unachievable baud, too high - must be less than F_CPU/8");
    if (baud < (F_CPU/16800)) badArg("Unachievable baud, too low - must be more than F_CPU/16800 (16384 plus allowable error)");
  }
  // Make sure no transmissions are ongoing and USART is disabled in case begin() is called by accident
  // without first calling end()
  if (_written) {
     854:	8d 89       	ldd	r24, Y+21	; 0x15
     856:	88 23       	and	r24, r24
     858:	39 f0       	breq	.+14     	; 0x868 <UartClass::begin(unsigned long, unsigned int)+0x32>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:180
    this->end();
     85a:	e8 81       	ld	r30, Y
     85c:	f9 81       	ldd	r31, Y+1	; 0x01
     85e:	00 88       	ldd	r0, Z+16	; 0x10
     860:	f1 89       	ldd	r31, Z+17	; 0x11
     862:	e0 2d       	mov	r30, r0
     864:	ce 01       	movw	r24, r28
     866:	09 95       	icall
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:183
  }

  struct UartPinSet *set = &_hw_set[_pin_set];
     868:	0c 89       	ldd	r16, Y+20	; 0x14
     86a:	10 e0       	ldi	r17, 0x00	; 0
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:186

  int32_t baud_setting = 0;
  uint8_t rxmode=0;
     86c:	e1 2c       	mov	r14, r1
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:190

  // Use CLK2X if appropriate.
  #if (F_CPU > 2000000)
  if(baud>=(38400*(F_CPU/1000000))) {
     86e:	81 14       	cp	r8, r1
     870:	28 eb       	ldi	r18, 0xB8	; 184
     872:	92 06       	cpc	r9, r18
     874:	2b e0       	ldi	r18, 0x0B	; 11
     876:	a2 06       	cpc	r10, r18
     878:	b1 04       	cpc	r11, r1
     87a:	30 f0       	brcs	.+12     	; 0x888 <UartClass::begin(unsigned long, unsigned int)+0x52>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:192
    rxmode = USART_RXMODE_CLK2X_gc;
    baud=baud>>1;
     87c:	b6 94       	lsr	r11
     87e:	a7 94       	ror	r10
     880:	97 94       	ror	r9
     882:	87 94       	ror	r8
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:191
  uint8_t rxmode=0;

  // Use CLK2X if appropriate.
  #if (F_CPU > 2000000)
  if(baud>=(38400*(F_CPU/1000000))) {
    rxmode = USART_RXMODE_CLK2X_gc;
     884:	42 e0       	ldi	r20, 0x02	; 2
     886:	e4 2e       	mov	r14, r20
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:204
  #else
  //if clocked at 1 or 2 MHz, always use CLK2X mode and save a bit of space, we correct for not shifting the baud value below, as it saves a bit of flash
    rxmode = USART_RXMODE_CLK2X_gc;
  #endif

  _written = false;
     888:	1d 8a       	std	Y+21, r1	; 0x15
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:216
    // it's close enough to work under normal circumstances anyway.
    #if (F_CPU==20000000UL || F_CPU==10000000UL || F_CPU==5000000UL) //this means we are on the 20MHz oscillator
      #ifdef UARTBAUD3V
        int8_t sigrow_val = SIGROW.OSC20ERR3V;
      #else
        int8_t sigrow_val = SIGROW.OSC20ERR5V;
     88a:	f0 90 25 11 	lds	r15, 0x1125	; 0x801125 <vtable for SSD1306Device+0x7f7ad1>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:227
        int8_t sigrow_val = SIGROW.OSC16ERR5V;
      #endif
    #endif
    #if (F_CPU > 2000000)
      //if we are above 2 MHz, baud was corrected above if CLK2X used.
      baud_setting = ((8 * F_CPU) / baud);
     88e:	60 e0       	ldi	r22, 0x00	; 0
     890:	78 e6       	ldi	r23, 0x68	; 104
     892:	89 e8       	ldi	r24, 0x89	; 137
     894:	99 e0       	ldi	r25, 0x09	; 9
     896:	a5 01       	movw	r20, r10
     898:	94 01       	movw	r18, r8
     89a:	0e 94 f2 09 	call	0x13e4	; 0x13e4 <__udivmodsi4>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:232
    #else
      //if clocked at 1 or 2 MHz, always use CLK2X mode and save a bit of flash...
      baud_setting = ((16 * F_CPU) / baud);
    #endif
    baud_setting *= (1024 + sigrow_val);
     89e:	af 2d       	mov	r26, r15
     8a0:	ff 0c       	add	r15, r15
     8a2:	bb 0b       	sbc	r27, r27
     8a4:	bc 5f       	subi	r27, 0xFC	; 252
     8a6:	0e 94 1f 0a 	call	0x143e	; 0x143e <__mulshisi3>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:233
    baud_setting /= 2048;
     8aa:	dc 01       	movw	r26, r24
     8ac:	cb 01       	movw	r24, r22
     8ae:	2b e0       	ldi	r18, 0x0B	; 11
     8b0:	b5 95       	asr	r27
     8b2:	a7 95       	ror	r26
     8b4:	97 95       	ror	r25
     8b6:	87 95       	ror	r24
     8b8:	2a 95       	dec	r18
     8ba:	d1 f7       	brne	.-12     	; 0x8b0 <UartClass::begin(unsigned long, unsigned int)+0x7a>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:249
    #endif
  #endif

  // Make sure global interrupts are disabled during initialization
  // no reason to do this before we potentially do all that long division, right?
  uint8_t oldSREG = SREG;
     8bc:	ff b6       	in	r15, 0x3f	; 63
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:250
  cli();
     8be:	f8 94       	cli
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:252
  // assign the baud_setting, a.k.a. BAUD (USART Baud Rate Register)
  (*_hwserial_module).BAUD = (uint16_t)baud_setting;
     8c0:	ec 85       	ldd	r30, Y+12	; 0x0c
     8c2:	fd 85       	ldd	r31, Y+13	; 0x0d
     8c4:	00 97       	sbiw	r24, 0x00	; 0
     8c6:	21 e0       	ldi	r18, 0x01	; 1
     8c8:	a2 07       	cpc	r26, r18
     8ca:	b1 05       	cpc	r27, r1
     8cc:	24 f0       	brlt	.+8      	; 0x8d6 <UartClass::begin(unsigned long, unsigned int)+0xa0>
     8ce:	8f ef       	ldi	r24, 0xFF	; 255
     8d0:	9f ef       	ldi	r25, 0xFF	; 255
     8d2:	a0 e0       	ldi	r26, 0x00	; 0
     8d4:	b0 e0       	ldi	r27, 0x00	; 0
     8d6:	80 87       	std	Z+8, r24	; 0x08
     8d8:	91 87       	std	Z+9, r25	; 0x09
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:255

  // Set USART mode of operation
  (*_hwserial_module).CTRLC = config;
     8da:	ec 85       	ldd	r30, Y+12	; 0x0c
     8dc:	fd 85       	ldd	r31, Y+13	; 0x0d
     8de:	d7 82       	std	Z+7, r13	; 0x07
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:258

  // Enable transmitter and receiver
  (*_hwserial_module).CTRLB = ((*_hwserial_module).CTRLB&(~USART_RXMODE_gm)) | rxmode | (USART_RXEN_bm | USART_TXEN_bm);
     8e0:	ec 85       	ldd	r30, Y+12	; 0x0c
     8e2:	fd 85       	ldd	r31, Y+13	; 0x0d
     8e4:	86 81       	ldd	r24, Z+6	; 0x06
     8e6:	89 7f       	andi	r24, 0xF9	; 249
     8e8:	80 6c       	ori	r24, 0xC0	; 192
     8ea:	8e 29       	or	r24, r14
     8ec:	86 83       	std	Z+6, r24	; 0x06
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:260

  (*_hwserial_module).CTRLA |= USART_RXCIE_bm;
     8ee:	ec 85       	ldd	r30, Y+12	; 0x0c
     8f0:	fd 85       	ldd	r31, Y+13	; 0x0d
     8f2:	85 81       	ldd	r24, Z+5	; 0x05
     8f4:	80 68       	ori	r24, 0x80	; 128
     8f6:	85 83       	std	Z+5, r24	; 0x05
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:265


  // Let PORTMUX point to alternative UART pins as requested
  #ifdef PORTMUX_CTRLB
    PORTMUX.CTRLB = set->mux | (PORTMUX.CTRLB & ~_hw_set[1].mux);
     8f8:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <vtable for SSD1306Device+0x7f6bad>
     8fc:	8b 89       	ldd	r24, Y+19	; 0x13
     8fe:	80 95       	com	r24
     900:	89 23       	and	r24, r25
     902:	98 01       	movw	r18, r16
     904:	22 0f       	add	r18, r18
     906:	33 1f       	adc	r19, r19
     908:	02 0f       	add	r16, r18
     90a:	13 1f       	adc	r17, r19
     90c:	c0 0f       	add	r28, r16
     90e:	d1 1f       	adc	r29, r17
     910:	98 89       	ldd	r25, Y+16	; 0x10
     912:	89 2b       	or	r24, r25
     914:	80 93 01 02 	sts	0x0201, r24	; 0x800201 <vtable for SSD1306Device+0x7f6bad>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:271
  #else
    PORTMUX.USARTROUTEA = set->mux | (PORTMUX.USARTROUTEA & ~_hw_set[1].mux);
  #endif

  // Set pin state for swapped UART pins
  pinMode(set->rx_pin, INPUT_PULLUP);
     918:	62 e0       	ldi	r22, 0x02	; 2
     91a:	8e 85       	ldd	r24, Y+14	; 0x0e
     91c:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <pinMode>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:273
  //digitalWrite(set->tx_pin, HIGH);
  pinMode(set->tx_pin, OUTPUT);
     920:	61 e0       	ldi	r22, 0x01	; 1
     922:	8f 85       	ldd	r24, Y+15	; 0x0f
     924:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <pinMode>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:276

  // Restore SREG content
  SREG = oldSREG;
     928:	ff be       	out	0x3f, r15	; 63
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART.cpp:277
}
     92a:	df 91       	pop	r29
     92c:	cf 91       	pop	r28
     92e:	1f 91       	pop	r17
     930:	0f 91       	pop	r16
     932:	ff 90       	pop	r15
     934:	ef 90       	pop	r14
     936:	df 90       	pop	r13
     938:	bf 90       	pop	r11
     93a:	af 90       	pop	r10
     93c:	9f 90       	pop	r9
     93e:	8f 90       	pop	r8
     940:	08 95       	ret

00000942 <__vector_28>:
__vector_28():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART0.cpp:48
#else
#error "Don't know what the Data Received interrupt vector is called for Serial"
#endif

#if defined(HWSERIAL0_DRE_VECTOR)
ISR(HWSERIAL0_DRE_VECTOR) {
     942:	1f 92       	push	r1
     944:	0f 92       	push	r0
     946:	0f b6       	in	r0, 0x3f	; 63
     948:	0f 92       	push	r0
     94a:	11 24       	eor	r1, r1
     94c:	2f 93       	push	r18
     94e:	3f 93       	push	r19
     950:	4f 93       	push	r20
     952:	5f 93       	push	r21
     954:	6f 93       	push	r22
     956:	7f 93       	push	r23
     958:	8f 93       	push	r24
     95a:	9f 93       	push	r25
     95c:	af 93       	push	r26
     95e:	bf 93       	push	r27
     960:	ef 93       	push	r30
     962:	ff 93       	push	r31
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART0.cpp:49
  Serial._tx_data_empty_irq();
     964:	82 e9       	ldi	r24, 0x92	; 146
     966:	98 e3       	ldi	r25, 0x38	; 56
     968:	0e 94 bf 00 	call	0x17e	; 0x17e <UartClass::_tx_data_empty_irq()>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART0.cpp:50
}
     96c:	ff 91       	pop	r31
     96e:	ef 91       	pop	r30
     970:	bf 91       	pop	r27
     972:	af 91       	pop	r26
     974:	9f 91       	pop	r25
     976:	8f 91       	pop	r24
     978:	7f 91       	pop	r23
     97a:	6f 91       	pop	r22
     97c:	5f 91       	pop	r21
     97e:	4f 91       	pop	r20
     980:	3f 91       	pop	r19
     982:	2f 91       	pop	r18
     984:	0f 90       	pop	r0
     986:	0f be       	out	0x3f, r0	; 63
     988:	0f 90       	pop	r0
     98a:	1f 90       	pop	r1
     98c:	18 95       	reti

0000098e <__vector_27>:
__vector_27():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART0.cpp:40
// first place.

#if defined(HAVE_HWSERIAL0)

#if defined(HWSERIAL0_RXC_VECTOR)
ISR(HWSERIAL0_RXC_VECTOR) {
     98e:	1f 92       	push	r1
     990:	0f 92       	push	r0
     992:	0f b6       	in	r0, 0x3f	; 63
     994:	0f 92       	push	r0
     996:	11 24       	eor	r1, r1
     998:	2f 93       	push	r18
     99a:	8f 93       	push	r24
     99c:	9f 93       	push	r25
     99e:	ef 93       	push	r30
     9a0:	ff 93       	push	r31
_rx_complete_irq():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART_private.h:59

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void UartClass::_rx_complete_irq(void) {
  //if (bit_is_clear(*_rxdatah, USART_PERR_bp)) {
  if (!(((*_hwserial_module).RXDATAH) & USART_PERR_bm)) {
     9a2:	e0 91 9e 38 	lds	r30, 0x389E	; 0x80389e <Serial+0xc>
     9a6:	f0 91 9f 38 	lds	r31, 0x389F	; 0x80389f <Serial+0xd>
     9aa:	81 81       	ldd	r24, Z+1	; 0x01
     9ac:	81 fd       	sbrc	r24, 1
     9ae:	1b c0       	rjmp	.+54     	; 0x9e6 <__vector_27+0x58>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART_private.h:62
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = (*_hwserial_module).RXDATAL;
     9b0:	90 81       	ld	r25, Z
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART_private.h:63
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
     9b2:	80 91 a8 38 	lds	r24, 0x38A8	; 0x8038a8 <Serial+0x16>
     9b6:	8f 5f       	subi	r24, 0xFF	; 255
     9b8:	8f 73       	andi	r24, 0x3F	; 63
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART_private.h:69

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
     9ba:	20 91 a9 38 	lds	r18, 0x38A9	; 0x8038a9 <Serial+0x17>
     9be:	82 17       	cp	r24, r18
     9c0:	41 f0       	breq	.+16     	; 0x9d2 <__vector_27+0x44>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART_private.h:70
      _rx_buffer[_rx_buffer_head] = c;
     9c2:	e0 91 a8 38 	lds	r30, 0x38A8	; 0x8038a8 <Serial+0x16>
     9c6:	f0 e0       	ldi	r31, 0x00	; 0
     9c8:	ee 56       	subi	r30, 0x6E	; 110
     9ca:	f7 4c       	sbci	r31, 0xC7	; 199
     9cc:	93 8f       	std	Z+27, r25	; 0x1b
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART_private.h:71
      _rx_buffer_head = i;
     9ce:	80 93 a8 38 	sts	0x38A8, r24	; 0x8038a8 <Serial+0x16>
__vector_27():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART0.cpp:42
  Serial._rx_complete_irq();
}
     9d2:	ff 91       	pop	r31
     9d4:	ef 91       	pop	r30
     9d6:	9f 91       	pop	r25
     9d8:	8f 91       	pop	r24
     9da:	2f 91       	pop	r18
     9dc:	0f 90       	pop	r0
     9de:	0f be       	out	0x3f, r0	; 63
     9e0:	0f 90       	pop	r0
     9e2:	1f 90       	pop	r1
     9e4:	18 95       	reti
_rx_complete_irq():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/UART_private.h:75
    }
  } else {
    // Parity error, read byte but discard it
    (*_hwserial_module).RXDATAL;
     9e6:	80 81       	ld	r24, Z
     9e8:	f4 cf       	rjmp	.-24     	; 0x9d2 <__vector_27+0x44>

000009ea <__vector_15>:
__vector_15():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:139
#elif defined(MILLIS_USE_TIMERB1)
  ISR(TCB1_INT_vect)
#else
  #error "No millis timer selected, but not disabled - cannot determine millis vector"
#endif
{
     9ea:	1f 92       	push	r1
     9ec:	0f 92       	push	r0
     9ee:	0f b6       	in	r0, 0x3f	; 63
     9f0:	0f 92       	push	r0
     9f2:	11 24       	eor	r1, r1
     9f4:	2f 93       	push	r18
     9f6:	3f 93       	push	r19
     9f8:	4f 93       	push	r20
     9fa:	5f 93       	push	r21
     9fc:	6f 93       	push	r22
     9fe:	8f 93       	push	r24
     a00:	9f 93       	push	r25
     a02:	af 93       	push	r26
     a04:	bf 93       	push	r27
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:151
  #else
  timer_millis += 2;
  #endif
  #else
  #if !defined(MILLIS_USE_TIMERRTC) //TCA0 or TCD0
  uint32_t m = timer_millis;
     a06:	80 91 74 38 	lds	r24, 0x3874	; 0x803874 <timer_millis>
     a0a:	90 91 75 38 	lds	r25, 0x3875	; 0x803875 <timer_millis+0x1>
     a0e:	a0 91 76 38 	lds	r26, 0x3876	; 0x803876 <timer_millis+0x2>
     a12:	b0 91 77 38 	lds	r27, 0x3877	; 0x803877 <timer_millis+0x3>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:152
  uint16_t f = timer_fract;
     a16:	40 91 72 38 	lds	r20, 0x3872	; 0x803872 <timer_fract>
     a1a:	50 91 73 38 	lds	r21, 0x3873	; 0x803873 <timer_fract+0x1>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:154
  m += MILLIS_INC;
  f += FRACT_INC;
     a1e:	9a 01       	movw	r18, r20
     a20:	20 5d       	subi	r18, 0xD0	; 208
     a22:	3c 4f       	sbci	r19, 0xFC	; 252
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:155
  if (f >= FRACT_MAX) {
     a24:	28 3e       	cpi	r18, 0xE8	; 232
     a26:	63 e0       	ldi	r22, 0x03	; 3
     a28:	36 07       	cpc	r19, r22
     a2a:	28 f0       	brcs	.+10     	; 0xa36 <__vector_15+0x4c>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:157

    f -= FRACT_MAX;
     a2c:	28 5e       	subi	r18, 0xE8	; 232
     a2e:	33 40       	sbci	r19, 0x03	; 3
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:158
    m += 1;
     a30:	01 96       	adiw	r24, 0x01	; 1
     a32:	a1 1d       	adc	r26, r1
     a34:	b1 1d       	adc	r27, r1
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:160
  }
  timer_fract = f;
     a36:	20 93 72 38 	sts	0x3872, r18	; 0x803872 <timer_fract>
     a3a:	30 93 73 38 	sts	0x3873, r19	; 0x803873 <timer_fract+0x1>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:161
  timer_millis = m;
     a3e:	80 93 74 38 	sts	0x3874, r24	; 0x803874 <timer_millis>
     a42:	90 93 75 38 	sts	0x3875, r25	; 0x803875 <timer_millis+0x1>
     a46:	a0 93 76 38 	sts	0x3876, r26	; 0x803876 <timer_millis+0x2>
     a4a:	b0 93 77 38 	sts	0x3877, r27	; 0x803877 <timer_millis+0x3>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:164
  #endif
  //if RTC is used as timer, we only increment the overflow count
  timer_overflow_count++;
     a4e:	80 91 78 38 	lds	r24, 0x3878	; 0x803878 <timer_overflow_count>
     a52:	90 91 79 38 	lds	r25, 0x3879	; 0x803879 <timer_overflow_count+0x1>
     a56:	a0 91 7a 38 	lds	r26, 0x387A	; 0x80387a <timer_overflow_count+0x2>
     a5a:	b0 91 7b 38 	lds	r27, 0x387B	; 0x80387b <timer_overflow_count+0x3>
     a5e:	01 96       	adiw	r24, 0x01	; 1
     a60:	a1 1d       	adc	r26, r1
     a62:	b1 1d       	adc	r27, r1
     a64:	80 93 78 38 	sts	0x3878, r24	; 0x803878 <timer_overflow_count>
     a68:	90 93 79 38 	sts	0x3879, r25	; 0x803879 <timer_overflow_count+0x1>
     a6c:	a0 93 7a 38 	sts	0x387A, r26	; 0x80387a <timer_overflow_count+0x2>
     a70:	b0 93 7b 38 	sts	0x387B, r27	; 0x80387b <timer_overflow_count+0x3>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:170
  #endif
  /* Clear flag */
  #if defined(MILLIS_USE_TIMERA0)
  TCA0.SPLIT.INTFLAGS = TCA_SPLIT_HUNF_bm;
  #elif defined(MILLIS_USE_TIMERD0)
  TCD0.INTFLAGS = TCD_OVF_bm;
     a74:	81 e0       	ldi	r24, 0x01	; 1
     a76:	80 93 8d 0a 	sts	0x0A8D, r24	; 0x800a8d <vtable for SSD1306Device+0x7f7439>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:176
  #elif defined(MILLIS_USE_TIMERRTC)
  RTC.INTFLAGS = RTC_OVF_bm;
  #else //timerb
  _timer->INTFLAGS = TCB_CAPT_bm;
  #endif
}
     a7a:	bf 91       	pop	r27
     a7c:	af 91       	pop	r26
     a7e:	9f 91       	pop	r25
     a80:	8f 91       	pop	r24
     a82:	6f 91       	pop	r22
     a84:	5f 91       	pop	r21
     a86:	4f 91       	pop	r20
     a88:	3f 91       	pop	r19
     a8a:	2f 91       	pop	r18
     a8c:	0f 90       	pop	r0
     a8e:	0f be       	out	0x3f, r0	; 63
     a90:	0f 90       	pop	r0
     a92:	1f 90       	pop	r1
     a94:	18 95       	reti

00000a96 <__vector_24>:
__vector_24():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:818

ISR(TWI0_TWIM_vect) {
  TWI_MasterInterruptHandler();
}

ISR(TWI0_TWIS_vect) {
     a96:	1f 92       	push	r1
     a98:	0f 92       	push	r0
     a9a:	0f b6       	in	r0, 0x3f	; 63
     a9c:	0f 92       	push	r0
     a9e:	11 24       	eor	r1, r1
     aa0:	2f 93       	push	r18
     aa2:	3f 93       	push	r19
     aa4:	4f 93       	push	r20
     aa6:	5f 93       	push	r21
     aa8:	6f 93       	push	r22
     aaa:	7f 93       	push	r23
     aac:	8f 93       	push	r24
     aae:	9f 93       	push	r25
     ab0:	af 93       	push	r26
     ab2:	bf 93       	push	r27
     ab4:	cf 93       	push	r28
     ab6:	ef 93       	push	r30
     ab8:	ff 93       	push	r31
TWI_SlaveInterruptHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:581

    Check current status and calls the appropriate handler.

*/
void TWI_SlaveInterruptHandler() {
  uint8_t currentStatus = TWI0.SSTATUS;
     aba:	c0 91 1b 08 	lds	r28, 0x081B	; 0x80081b <vtable for SSD1306Device+0x7f71c7>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:584

  /* If bus error */
  if (currentStatus & TWI_BUSERR_bm) {
     abe:	c2 ff       	sbrs	r28, 2
     ac0:	0a c0       	rjmp	.+20     	; 0xad6 <__vector_24+0x40>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:585
    slave_bytesRead = 0;
     ac2:	10 92 71 38 	sts	0x3871, r1	; 0x803871 <slave_bytesRead>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:586
    slave_bytesWritten = 0;
     ac6:	10 92 70 38 	sts	0x3870, r1	; 0x803870 <slave_bytesWritten>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:587
    slave_bytesToWrite = 0;
     aca:	10 92 6f 38 	sts	0x386F, r1	; 0x80386f <slave_bytesToWrite>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:588
    TWI_SlaveTransactionFinished(TWIS_RESULT_BUS_ERROR);
     ace:	84 e0       	ldi	r24, 0x04	; 4
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:642
    }
  }

  /* If unexpected state */
  else {
    TWI_SlaveTransactionFinished(TWIS_RESULT_FAIL);
     ad0:	0e 94 b7 01 	call	0x36e	; 0x36e <TWI_SlaveTransactionFinished>
     ad4:	12 c0       	rjmp	.+36     	; 0xafa <__vector_24+0x64>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:592
    slave_bytesToWrite = 0;
    TWI_SlaveTransactionFinished(TWIS_RESULT_BUS_ERROR);
  }

  /* If Address or Stop */
  else if (currentStatus & TWI_APIF_bm) {
     ad6:	c6 ff       	sbrs	r28, 6
     ad8:	2d c0       	rjmp	.+90     	; 0xb34 <__vector_24+0x9e>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:597

    /* Call user onReceive function if end of Master Write/Slave Read.
       This should be hit when there is a STOP or REPSTART
    */
    if (slave_callUserReceive == 1) {
     ada:	80 91 6e 38 	lds	r24, 0x386E	; 0x80386e <slave_callUserReceive>
     ade:	81 30       	cpi	r24, 0x01	; 1
     ae0:	41 f4       	brne	.+16     	; 0xaf2 <__vector_24+0x5c>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:598
      TWI_onSlaveReceive(slave_bytesRead);
     ae2:	80 91 71 38 	lds	r24, 0x3871	; 0x803871 <slave_bytesRead>
     ae6:	90 e0       	ldi	r25, 0x00	; 0
     ae8:	f0 e0       	ldi	r31, 0x00	; 0
     aea:	e0 e0       	ldi	r30, 0x00	; 0
     aec:	09 95       	icall
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:599
      slave_callUserReceive = 0;
     aee:	10 92 6e 38 	sts	0x386E, r1	; 0x80386e <slave_callUserReceive>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:603
    }

    /* If address match */
    if (currentStatus & TWI_AP_bm) {
     af2:	c0 ff       	sbrs	r28, 0
     af4:	14 c0       	rjmp	.+40     	; 0xb1e <__vector_24+0x88>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:604
      TWI_SlaveAddressMatchHandler();
     af6:	0e 94 c4 01 	call	0x388	; 0x388 <TWI_SlaveAddressMatchHandler>
__vector_24():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:820
  TWI_MasterInterruptHandler();
}

ISR(TWI0_TWIS_vect) {
  TWI_SlaveInterruptHandler();
}
     afa:	ff 91       	pop	r31
     afc:	ef 91       	pop	r30
     afe:	cf 91       	pop	r28
     b00:	bf 91       	pop	r27
     b02:	af 91       	pop	r26
     b04:	9f 91       	pop	r25
     b06:	8f 91       	pop	r24
     b08:	7f 91       	pop	r23
     b0a:	6f 91       	pop	r22
     b0c:	5f 91       	pop	r21
     b0e:	4f 91       	pop	r20
     b10:	3f 91       	pop	r19
     b12:	2f 91       	pop	r18
     b14:	0f 90       	pop	r0
     b16:	0f be       	out	0x3f, r0	; 63
     b18:	0f 90       	pop	r0
     b1a:	1f 90       	pop	r1
     b1c:	18 95       	reti
TWI_SlaveStopHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:682

*/
void TWI_SlaveStopHandler() {

  /* Clear APIF, don't ACK or NACK */
  TWI0.SSTATUS = TWI_APIF_bm;
     b1e:	80 e4       	ldi	r24, 0x40	; 64
     b20:	80 93 1b 08 	sts	0x081B, r24	; 0x80081b <vtable for SSD1306Device+0x7f71c7>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:684

  TWI_SlaveTransactionFinished(TWIS_RESULT_OK);
     b24:	81 e0       	ldi	r24, 0x01	; 1
     b26:	0e 94 b7 01 	call	0x36e	; 0x36e <TWI_SlaveTransactionFinished>
TWI_SlaveInterruptHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:615

      /* If CLKHOLD is high, we have missed an address match
        from a fast start after stop.
        Because the flag is shared we need to handle this here.
      */
      if (TWI0.SSTATUS & TWI_CLKHOLD_bm) {
     b2a:	80 91 1b 08 	lds	r24, 0x081B	; 0x80081b <vtable for SSD1306Device+0x7f71c7>
     b2e:	85 ff       	sbrs	r24, 5
     b30:	e4 cf       	rjmp	.-56     	; 0xafa <__vector_24+0x64>
     b32:	e1 cf       	rjmp	.-62     	; 0xaf6 <__vector_24+0x60>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:624
      }
    }
  }

  /* If Data Interrupt */
  else if (currentStatus & TWI_DIF_bm) {
     b34:	c7 ff       	sbrs	r28, 7
     b36:	50 c0       	rjmp	.+160    	; 0xbd8 <__vector_24+0x142>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:627

    /* If collision flag is raised, slave transmit unsuccessful */
    if (currentStatus & TWI_COLL_bm) {
     b38:	c3 ff       	sbrs	r28, 3
     b3a:	08 c0       	rjmp	.+16     	; 0xb4c <__vector_24+0xb6>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:628
      slave_bytesRead = 0;
     b3c:	10 92 71 38 	sts	0x3871, r1	; 0x803871 <slave_bytesRead>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:629
      slave_bytesWritten = 0;
     b40:	10 92 70 38 	sts	0x3870, r1	; 0x803870 <slave_bytesWritten>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:630
      slave_bytesToWrite = 0;
     b44:	10 92 6f 38 	sts	0x386F, r1	; 0x80386f <slave_bytesToWrite>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:631
      TWI_SlaveTransactionFinished(TWIS_RESULT_TRANSMIT_COLLISION);
     b48:	83 e0       	ldi	r24, 0x03	; 3
     b4a:	c2 cf       	rjmp	.-124    	; 0xad0 <__vector_24+0x3a>
TWI_SlaveDataHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:697

*/
void TWI_SlaveDataHandler() {

  /* Enable stop interrupt */
  TWI0.SCTRLA |= (TWI_APIEN_bm | TWI_PIEN_bm);
     b4c:	80 91 19 08 	lds	r24, 0x0819	; 0x800819 <vtable for SSD1306Device+0x7f71c5>
     b50:	80 66       	ori	r24, 0x60	; 96
     b52:	80 93 19 08 	sts	0x0819, r24	; 0x800819 <vtable for SSD1306Device+0x7f71c5>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:700

  /* If Master Read/Slave Write */
  if (TWI0.SSTATUS & TWI_DIR_bm) {
     b56:	80 91 1b 08 	lds	r24, 0x081B	; 0x80081b <vtable for SSD1306Device+0x7f71c7>
     b5a:	81 ff       	sbrs	r24, 1
     b5c:	26 c0       	rjmp	.+76     	; 0xbaa <__vector_24+0x114>
TWI_SlaveWriteHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:721

*/
void TWI_SlaveWriteHandler() {

  /* If NACK, slave write transaction finished */
  if ((slave_bytesWritten > 0) && (TWI0.SSTATUS & TWI_RXACK_bm)) {
     b5e:	80 91 70 38 	lds	r24, 0x3870	; 0x803870 <slave_bytesWritten>
     b62:	88 23       	and	r24, r24
     b64:	49 f0       	breq	.+18     	; 0xb78 <__vector_24+0xe2>
     b66:	80 91 1b 08 	lds	r24, 0x081B	; 0x80081b <vtable for SSD1306Device+0x7f71c7>
     b6a:	84 ff       	sbrs	r24, 4
     b6c:	05 c0       	rjmp	.+10     	; 0xb78 <__vector_24+0xe2>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:723

    TWI0.SCTRLB = TWI_SCMD_COMPTRANS_gc;
     b6e:	82 e0       	ldi	r24, 0x02	; 2
     b70:	80 93 1a 08 	sts	0x081A, r24	; 0x80081a <vtable for SSD1306Device+0x7f71c6>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:724
    TWI_SlaveTransactionFinished(TWIS_RESULT_OK);
     b74:	81 e0       	ldi	r24, 0x01	; 1
     b76:	ac cf       	rjmp	.-168    	; 0xad0 <__vector_24+0x3a>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:730
  }

  /* If ACK, master expects more data */
  else {

    if (slave_bytesWritten < slave_bytesToWrite) {
     b78:	90 91 70 38 	lds	r25, 0x3870	; 0x803870 <slave_bytesWritten>
     b7c:	80 91 6f 38 	lds	r24, 0x386F	; 0x80386f <slave_bytesToWrite>
     b80:	98 17       	cp	r25, r24
     b82:	78 f4       	brcc	.+30     	; 0xba2 <__vector_24+0x10c>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:731
      uint8_t data = slave_writeData[slave_bytesWritten];
     b84:	e0 91 70 38 	lds	r30, 0x3870	; 0x803870 <slave_bytesWritten>
     b88:	f0 e0       	ldi	r31, 0x00	; 0
     b8a:	80 81       	ld	r24, Z
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:732
      TWI0.SDATA = data;
     b8c:	80 93 1d 08 	sts	0x081D, r24	; 0x80081d <vtable for SSD1306Device+0x7f71c9>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:733
      slave_bytesWritten++;
     b90:	80 91 70 38 	lds	r24, 0x3870	; 0x803870 <slave_bytesWritten>
     b94:	8f 5f       	subi	r24, 0xFF	; 255
     b96:	80 93 70 38 	sts	0x3870, r24	; 0x803870 <slave_bytesWritten>
TWI_SlaveReadHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:767
    uint8_t data = TWI0.SDATA;
    slave_readData[slave_bytesRead] = data;
    slave_bytesRead++;

    /* Send ACK and wait for data interrupt */
    TWI0.SCTRLB = TWI_SCMD_RESPONSE_gc;
     b9a:	83 e0       	ldi	r24, 0x03	; 3
     b9c:	80 93 1a 08 	sts	0x081A, r24	; 0x80081a <vtable for SSD1306Device+0x7f71c6>
     ba0:	ac cf       	rjmp	.-168    	; 0xafa <__vector_24+0x64>
TWI_SlaveWriteHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:742

    }

    /* If buffer overflow */
    else {
      TWI0.SCTRLB = TWI_SCMD_COMPTRANS_gc;
     ba2:	82 e0       	ldi	r24, 0x02	; 2
     ba4:	80 93 1a 08 	sts	0x081A, r24	; 0x80081a <vtable for SSD1306Device+0x7f71c6>
     ba8:	93 cf       	rjmp	.-218    	; 0xad0 <__vector_24+0x3a>
TWI_SlaveReadHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:759

*/
void TWI_SlaveReadHandler() {

  /* If free space in buffer */
  if (slave_bytesRead < slave_bytesToRead) {
     baa:	90 91 71 38 	lds	r25, 0x3871	; 0x803871 <slave_bytesRead>
     bae:	80 91 6d 38 	lds	r24, 0x386D	; 0x80386d <slave_bytesToRead>
     bb2:	98 17       	cp	r25, r24
     bb4:	60 f4       	brcc	.+24     	; 0xbce <__vector_24+0x138>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:762

    /* Fetch data */
    uint8_t data = TWI0.SDATA;
     bb6:	80 91 1d 08 	lds	r24, 0x081D	; 0x80081d <vtable for SSD1306Device+0x7f71c9>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:763
    slave_readData[slave_bytesRead] = data;
     bba:	e0 91 71 38 	lds	r30, 0x3871	; 0x803871 <slave_bytesRead>
     bbe:	f0 e0       	ldi	r31, 0x00	; 0
     bc0:	80 83       	st	Z, r24
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:764
    slave_bytesRead++;
     bc2:	80 91 71 38 	lds	r24, 0x3871	; 0x803871 <slave_bytesRead>
     bc6:	8f 5f       	subi	r24, 0xFF	; 255
     bc8:	80 93 71 38 	sts	0x3871, r24	; 0x803871 <slave_bytesRead>
     bcc:	e6 cf       	rjmp	.-52     	; 0xb9a <__vector_24+0x104>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:772
    TWI0.SCTRLB = TWI_SCMD_RESPONSE_gc;
  }
  /* If buffer overflow, send NACK and wait for next START.
    Set result buffer overflow */
  else {
    TWI0.SCTRLB = TWI_ACKACT_bm | TWI_SCMD_COMPTRANS_gc;
     bce:	86 e0       	ldi	r24, 0x06	; 6
     bd0:	80 93 1a 08 	sts	0x081A, r24	; 0x80081a <vtable for SSD1306Device+0x7f71c6>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:773
    TWI_SlaveTransactionFinished(TWIS_RESULT_BUFFER_OVERFLOW);
     bd4:	82 e0       	ldi	r24, 0x02	; 2
     bd6:	7c cf       	rjmp	.-264    	; 0xad0 <__vector_24+0x3a>
TWI_SlaveInterruptHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:642
    }
  }

  /* If unexpected state */
  else {
    TWI_SlaveTransactionFinished(TWIS_RESULT_FAIL);
     bd8:	85 e0       	ldi	r24, 0x05	; 5
     bda:	7a cf       	rjmp	.-268    	; 0xad0 <__vector_24+0x3a>

00000bdc <__vector_25>:
__vector_25():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:814
  twi_mode = TWI_MODE_SLAVE;
  slave_result = result;
  slave_trans_status = TWIM_STATUS_READY;
}

ISR(TWI0_TWIM_vect) {
     bdc:	1f 92       	push	r1
     bde:	0f 92       	push	r0
     be0:	0f b6       	in	r0, 0x3f	; 63
     be2:	0f 92       	push	r0
     be4:	11 24       	eor	r1, r1
     be6:	2f 93       	push	r18
     be8:	8f 93       	push	r24
     bea:	9f 93       	push	r25
     bec:	ef 93       	push	r30
     bee:	ff 93       	push	r31
TWI_MasterInterruptHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:413

    Check current status and calls the appropriate handler.

*/
void TWI_MasterInterruptHandler() {
  uint8_t currentStatus = TWI0.MSTATUS;
     bf0:	80 91 15 08 	lds	r24, 0x0815	; 0x800815 <vtable for SSD1306Device+0x7f71c1>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:416

  /* If arbitration lost or bus error. */
  if ((currentStatus & TWI_ARBLOST_bm) ||
     bf4:	98 2f       	mov	r25, r24
     bf6:	9c 70       	andi	r25, 0x0C	; 12
     bf8:	c1 f0       	breq	.+48     	; 0xc2a <__vector_25+0x4e>
TWI_MasterArbitrationLostBusErrorHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:444

    Handles TWI responses to lost arbitration and bus error.

*/
void TWI_MasterArbitrationLostBusErrorHandler() {
  uint8_t currentStatus = TWI0.MSTATUS;
     bfa:	80 91 15 08 	lds	r24, 0x0815	; 0x800815 <vtable for SSD1306Device+0x7f71c1>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:448

  /* If bus error. */
  if (currentStatus & TWI_BUSERR_bm) {
    master_result = TWIM_RESULT_BUS_ERROR;
     bfe:	94 e0       	ldi	r25, 0x04	; 4
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:447
*/
void TWI_MasterArbitrationLostBusErrorHandler() {
  uint8_t currentStatus = TWI0.MSTATUS;

  /* If bus error. */
  if (currentStatus & TWI_BUSERR_bm) {
     c00:	82 ff       	sbrs	r24, 2
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:452
    master_result = TWIM_RESULT_BUS_ERROR;
  }
  /* If arbitration lost. */
  else {
    master_result = TWIM_RESULT_ARBITRATION_LOST;
     c02:	93 e0       	ldi	r25, 0x03	; 3
     c04:	90 93 6c 38 	sts	0x386C, r25	; 0x80386c <master_result>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:456
  }

  /* Clear all flags, abort operation */
  TWI0.MSTATUS = currentStatus;
     c08:	80 93 15 08 	sts	0x0815, r24	; 0x800815 <vtable for SSD1306Device+0x7f71c1>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:459

  /* Wait for a new operation */
  twi_mode = TWI_MODE_MASTER;
     c0c:	81 e0       	ldi	r24, 0x01	; 1
     c0e:	80 93 6a 38 	sts	0x386A, r24	; 0x80386a <twi_mode>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:460
  master_trans_status = TWIM_STATUS_READY;
     c12:	10 92 6b 38 	sts	0x386B, r1	; 0x80386b <master_trans_status>
__vector_25():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:816
  slave_trans_status = TWIM_STATUS_READY;
}

ISR(TWI0_TWIM_vect) {
  TWI_MasterInterruptHandler();
}
     c16:	ff 91       	pop	r31
     c18:	ef 91       	pop	r30
     c1a:	9f 91       	pop	r25
     c1c:	8f 91       	pop	r24
     c1e:	2f 91       	pop	r18
     c20:	0f 90       	pop	r0
     c22:	0f be       	out	0x3f, r0	; 63
     c24:	0f 90       	pop	r0
     c26:	1f 90       	pop	r1
     c28:	18 95       	reti
TWI_MasterInterruptHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:423

    TWI_MasterArbitrationLostBusErrorHandler();
  }

  /* If master write interrupt. */
  else if (currentStatus & TWI_WIF_bm) {
     c2a:	86 ff       	sbrs	r24, 6
     c2c:	4c c0       	rjmp	.+152    	; 0xcc6 <__vector_25+0xea>
TWI_MasterWriteHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:471
    Handles TWI transactions (master write) and responses to (N)ACK.

*/
void TWI_MasterWriteHandler() {
  /* Local variables used in if tests to avoid compiler warning. */
  uint8_t bytesToWrite  = master_bytesToWrite;
     c2e:	20 91 66 38 	lds	r18, 0x3866	; 0x803866 <master_bytesToWrite>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:472
  uint8_t bytesToRead   = master_bytesToRead;
     c32:	90 91 68 38 	lds	r25, 0x3868	; 0x803868 <master_bytesToRead>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:475

  /* If NOT acknowledged (NACK) by slave cancel the transaction. */
  if (TWI0.MSTATUS & TWI_RXACK_bm) {
     c36:	80 91 15 08 	lds	r24, 0x0815	; 0x800815 <vtable for SSD1306Device+0x7f71c1>
     c3a:	84 ff       	sbrs	r24, 4
     c3c:	10 c0       	rjmp	.+32     	; 0xc5e <__vector_25+0x82>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:476
    if (master_sendStop) {
     c3e:	80 91 67 38 	lds	r24, 0x3867	; 0x803867 <master_sendStop>
     c42:	88 23       	and	r24, r24
     c44:	51 f0       	breq	.+20     	; 0xc5a <__vector_25+0x7e>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:477
      TWI0.MCTRLB = TWI_MCMD_STOP_gc;
     c46:	83 e0       	ldi	r24, 0x03	; 3
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:479
    } else {
      TWI0.MCTRLB = TWI_MCMD_REPSTART_gc;
     c48:	80 93 14 08 	sts	0x0814, r24	; 0x800814 <vtable for SSD1306Device+0x7f71c0>
TWI_MasterTransactionFinished():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:569
    Prepares module for new transaction.

    \param result  The result of the operation.
*/
void TWI_MasterTransactionFinished(uint8_t result) {
  master_result = result;
     c4c:	85 e0       	ldi	r24, 0x05	; 5
     c4e:	80 93 6c 38 	sts	0x386C, r24	; 0x80386c <master_result>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:570
  master_trans_status = TWIM_STATUS_READY;
     c52:	10 92 6b 38 	sts	0x386B, r1	; 0x80386b <master_trans_status>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:571
  twi_mode = TWI_MODE_MASTER;
     c56:	81 e0       	ldi	r24, 0x01	; 1
     c58:	31 c0       	rjmp	.+98     	; 0xcbc <__vector_25+0xe0>
TWI_MasterWriteHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:479
  /* If NOT acknowledged (NACK) by slave cancel the transaction. */
  if (TWI0.MSTATUS & TWI_RXACK_bm) {
    if (master_sendStop) {
      TWI0.MCTRLB = TWI_MCMD_STOP_gc;
    } else {
      TWI0.MCTRLB = TWI_MCMD_REPSTART_gc;
     c5a:	81 e0       	ldi	r24, 0x01	; 1
     c5c:	f5 cf       	rjmp	.-22     	; 0xc48 <__vector_25+0x6c>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:486
    }
    TWI_MasterTransactionFinished(TWIM_RESULT_NACK_RECEIVED);
  }

  /* If more bytes to write, send data. */
  else if (master_bytesWritten < bytesToWrite) {
     c5e:	80 91 65 38 	lds	r24, 0x3865	; 0x803865 <master_bytesWritten>
     c62:	82 17       	cp	r24, r18
     c64:	90 f4       	brcc	.+36     	; 0xc8a <__vector_25+0xae>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:487
    uint8_t data = master_writeData[master_bytesWritten];
     c66:	e0 91 65 38 	lds	r30, 0x3865	; 0x803865 <master_bytesWritten>
     c6a:	80 91 63 38 	lds	r24, 0x3863	; 0x803863 <master_writeData>
     c6e:	90 91 64 38 	lds	r25, 0x3864	; 0x803864 <master_writeData+0x1>
     c72:	e8 0f       	add	r30, r24
     c74:	f9 2f       	mov	r31, r25
     c76:	f1 1d       	adc	r31, r1
     c78:	80 81       	ld	r24, Z
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:488
    TWI0.MDATA = data;
     c7a:	80 93 18 08 	sts	0x0818, r24	; 0x800818 <vtable for SSD1306Device+0x7f71c4>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:489
    master_bytesWritten++;
     c7e:	80 91 65 38 	lds	r24, 0x3865	; 0x803865 <master_bytesWritten>
     c82:	8f 5f       	subi	r24, 0xFF	; 255
     c84:	80 93 65 38 	sts	0x3865, r24	; 0x803865 <master_bytesWritten>
     c88:	c6 cf       	rjmp	.-116    	; 0xc16 <__vector_25+0x3a>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:495
  }

  /* If bytes to read, send START condition + Address +
     'R/_W = 1'
  */
  else if (master_bytesRead < bytesToRead) {
     c8a:	80 91 69 38 	lds	r24, 0x3869	; 0x803869 <master_bytesRead>
     c8e:	89 17       	cp	r24, r25
     c90:	48 f4       	brcc	.+18     	; 0xca4 <__vector_25+0xc8>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:496
    twi_mode = TWI_MODE_MASTER_RECEIVE;
     c92:	84 e0       	ldi	r24, 0x04	; 4
     c94:	80 93 6a 38 	sts	0x386A, r24	; 0x80386a <twi_mode>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:497
    uint8_t readAddress = ADD_READ_BIT(master_slaveAddress);
     c98:	80 91 62 38 	lds	r24, 0x3862	; 0x803862 <master_slaveAddress>
     c9c:	81 60       	ori	r24, 0x01	; 1
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:498
    TWI0.MADDR = readAddress;
     c9e:	80 93 17 08 	sts	0x0817, r24	; 0x800817 <vtable for SSD1306Device+0x7f71c3>
     ca2:	b9 cf       	rjmp	.-142    	; 0xc16 <__vector_25+0x3a>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:503
  }

  /* If transaction finished, send ACK/STOP condition if instructed and set RESULT OK. */
  else {
    if (master_sendStop) {
     ca4:	80 91 67 38 	lds	r24, 0x3867	; 0x803867 <master_sendStop>
     ca8:	88 23       	and	r24, r24
     caa:	59 f0       	breq	.+22     	; 0xcc2 <__vector_25+0xe6>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:504
      TWI0.MCTRLB = TWI_MCMD_STOP_gc;
     cac:	83 e0       	ldi	r24, 0x03	; 3
TWI_MasterReadHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:554
  /* If transaction finished, issue NACK and STOP condition if instructed. */
  else {
    if (master_sendStop) {
      TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_STOP_gc;
    } else {
      TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_REPSTART_gc;
     cae:	80 93 14 08 	sts	0x0814, r24	; 0x800814 <vtable for SSD1306Device+0x7f71c0>
TWI_MasterTransactionFinished():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:569
    Prepares module for new transaction.

    \param result  The result of the operation.
*/
void TWI_MasterTransactionFinished(uint8_t result) {
  master_result = result;
     cb2:	81 e0       	ldi	r24, 0x01	; 1
     cb4:	80 93 6c 38 	sts	0x386C, r24	; 0x80386c <master_result>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:570
  master_trans_status = TWIM_STATUS_READY;
     cb8:	10 92 6b 38 	sts	0x386B, r1	; 0x80386b <master_trans_status>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:571
  twi_mode = TWI_MODE_MASTER;
     cbc:	80 93 6a 38 	sts	0x386A, r24	; 0x80386a <twi_mode>
     cc0:	aa cf       	rjmp	.-172    	; 0xc16 <__vector_25+0x3a>
TWI_MasterWriteHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:506
  /* If transaction finished, send ACK/STOP condition if instructed and set RESULT OK. */
  else {
    if (master_sendStop) {
      TWI0.MCTRLB = TWI_MCMD_STOP_gc;
    } else {
      TWI0.MCTRLB = TWI_MCMD_REPSTART_gc;
     cc2:	81 e0       	ldi	r24, 0x01	; 1
     cc4:	f4 cf       	rjmp	.-24     	; 0xcae <__vector_25+0xd2>
TWI_MasterInterruptHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:428
  else if (currentStatus & TWI_WIF_bm) {
    TWI_MasterWriteHandler();
  }

  /* If master read interrupt. */
  else if (currentStatus & TWI_RIF_bm) {
     cc6:	87 ff       	sbrs	r24, 7
     cc8:	37 c0       	rjmp	.+110    	; 0xd38 <__vector_25+0x15c>
TWI_MasterReadHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:522

    \param twi The TWI_Master_t struct instance.
*/
void TWI_MasterReadHandler() {
  /* Fetch data if bytes to be read. */
  if (master_bytesRead < master_bytesToRead) {
     cca:	90 91 69 38 	lds	r25, 0x3869	; 0x803869 <master_bytesRead>
     cce:	80 91 68 38 	lds	r24, 0x3868	; 0x803868 <master_bytesToRead>
     cd2:	98 17       	cp	r25, r24
     cd4:	a8 f4       	brcc	.+42     	; 0xd00 <__vector_25+0x124>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:523
    uint8_t data = TWI0.MDATA;
     cd6:	80 91 18 08 	lds	r24, 0x0818	; 0x800818 <vtable for SSD1306Device+0x7f71c4>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:524
    master_readData[master_bytesRead] = data;
     cda:	e0 91 69 38 	lds	r30, 0x3869	; 0x803869 <master_bytesRead>
     cde:	f0 e0       	ldi	r31, 0x00	; 0
     ce0:	80 83       	st	Z, r24
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:525
    master_bytesRead++;
     ce2:	80 91 69 38 	lds	r24, 0x3869	; 0x803869 <master_bytesRead>
     ce6:	8f 5f       	subi	r24, 0xFF	; 255
     ce8:	80 93 69 38 	sts	0x3869, r24	; 0x803869 <master_bytesRead>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:542
    master_bytesToRead = 0;
    return;
  }

  /* Local variable used in if test to avoid compiler warning. */
  uint8_t bytesToRead = master_bytesToRead;
     cec:	90 91 68 38 	lds	r25, 0x3868	; 0x803868 <master_bytesToRead>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:545

  /* If more bytes to read, issue ACK and start a byte read. */
  if (master_bytesRead < bytesToRead) {
     cf0:	80 91 69 38 	lds	r24, 0x3869	; 0x803869 <master_bytesRead>
     cf4:	89 17       	cp	r24, r25
     cf6:	c0 f4       	brcc	.+48     	; 0xd28 <__vector_25+0x14c>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:546
    TWI0.MCTRLB = TWI_MCMD_RECVTRANS_gc;
     cf8:	82 e0       	ldi	r24, 0x02	; 2
     cfa:	80 93 14 08 	sts	0x0814, r24	; 0x800814 <vtable for SSD1306Device+0x7f71c0>
     cfe:	8b cf       	rjmp	.-234    	; 0xc16 <__vector_25+0x3a>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:530
    master_bytesRead++;
  }

  /* If buffer overflow, issue NACK/STOP and BUFFER_OVERFLOW condition. */
  else {
    if (master_sendStop) {
     d00:	80 91 67 38 	lds	r24, 0x3867	; 0x803867 <master_sendStop>
     d04:	88 23       	and	r24, r24
     d06:	71 f0       	breq	.+28     	; 0xd24 <__vector_25+0x148>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:531
      TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_STOP_gc;
     d08:	87 e0       	ldi	r24, 0x07	; 7
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:533
    } else {
      TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_REPSTART_gc;
     d0a:	80 93 14 08 	sts	0x0814, r24	; 0x800814 <vtable for SSD1306Device+0x7f71c0>
TWI_MasterTransactionFinished():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:569
    Prepares module for new transaction.

    \param result  The result of the operation.
*/
void TWI_MasterTransactionFinished(uint8_t result) {
  master_result = result;
     d0e:	82 e0       	ldi	r24, 0x02	; 2
     d10:	80 93 6c 38 	sts	0x386C, r24	; 0x80386c <master_result>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:570
  master_trans_status = TWIM_STATUS_READY;
     d14:	10 92 6b 38 	sts	0x386B, r1	; 0x80386b <master_trans_status>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:571
  twi_mode = TWI_MODE_MASTER;
     d18:	81 e0       	ldi	r24, 0x01	; 1
     d1a:	80 93 6a 38 	sts	0x386A, r24	; 0x80386a <twi_mode>
TWI_MasterReadHandler():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:537
    } else {
      TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_REPSTART_gc;
    }

    TWI_MasterTransactionFinished(TWIM_RESULT_BUFFER_OVERFLOW);
    master_bytesToRead = 0;
     d1e:	10 92 68 38 	sts	0x3868, r1	; 0x803868 <master_bytesToRead>
     d22:	79 cf       	rjmp	.-270    	; 0xc16 <__vector_25+0x3a>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:533
  /* If buffer overflow, issue NACK/STOP and BUFFER_OVERFLOW condition. */
  else {
    if (master_sendStop) {
      TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_STOP_gc;
    } else {
      TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_REPSTART_gc;
     d24:	85 e0       	ldi	r24, 0x05	; 5
     d26:	f1 cf       	rjmp	.-30     	; 0xd0a <__vector_25+0x12e>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:551
    TWI0.MCTRLB = TWI_MCMD_RECVTRANS_gc;
  }

  /* If transaction finished, issue NACK and STOP condition if instructed. */
  else {
    if (master_sendStop) {
     d28:	80 91 67 38 	lds	r24, 0x3867	; 0x803867 <master_sendStop>
     d2c:	88 23       	and	r24, r24
     d2e:	11 f0       	breq	.+4      	; 0xd34 <__vector_25+0x158>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:552
      TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_STOP_gc;
     d30:	87 e0       	ldi	r24, 0x07	; 7
     d32:	bd cf       	rjmp	.-134    	; 0xcae <__vector_25+0xd2>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:554
    } else {
      TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_REPSTART_gc;
     d34:	85 e0       	ldi	r24, 0x05	; 5
     d36:	bb cf       	rjmp	.-138    	; 0xcae <__vector_25+0xd2>
TWI_MasterTransactionFinished():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/libraries/Wire/src/utility/twi.c:569
    Prepares module for new transaction.

    \param result  The result of the operation.
*/
void TWI_MasterTransactionFinished(uint8_t result) {
  master_result = result;
     d38:	86 e0       	ldi	r24, 0x06	; 6
     d3a:	89 cf       	rjmp	.-238    	; 0xc4e <__vector_25+0x72>

00000d3c <__vector_8>:
__vector_8():
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:61

    updateInterface();
}


ISR(TCA0_OVF_vect) {
     d3c:	1f 92       	push	r1
     d3e:	0f 92       	push	r0
     d40:	0f b6       	in	r0, 0x3f	; 63
     d42:	0f 92       	push	r0
     d44:	11 24       	eor	r1, r1
     d46:	cf 92       	push	r12
     d48:	df 92       	push	r13
     d4a:	ef 92       	push	r14
     d4c:	ff 92       	push	r15
     d4e:	0f 93       	push	r16
     d50:	1f 93       	push	r17
     d52:	2f 93       	push	r18
     d54:	3f 93       	push	r19
     d56:	4f 93       	push	r20
     d58:	5f 93       	push	r21
     d5a:	6f 93       	push	r22
     d5c:	7f 93       	push	r23
     d5e:	8f 93       	push	r24
     d60:	9f 93       	push	r25
     d62:	af 93       	push	r26
     d64:	bf 93       	push	r27
     d66:	ef 93       	push	r30
     d68:	ff 93       	push	r31
digitalWriteFast():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:298
  if (val == LOW)
    vport->OUT &= ~mask;
  else if (val == CHANGE)
    vport->IN  |= mask;
  else // HIGH
    vport->OUT |= mask;
     d6a:	2c 9a       	sbi	0x05, 4	; 5
__vector_8():
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:65

    digitalWriteFast(LED_PIN, true);

    ++tick;
     d6c:	80 91 81 38 	lds	r24, 0x3881	; 0x803881 <tick>
     d70:	90 91 82 38 	lds	r25, 0x3882	; 0x803882 <tick+0x1>
     d74:	a0 91 83 38 	lds	r26, 0x3883	; 0x803883 <tick+0x2>
     d78:	b0 91 84 38 	lds	r27, 0x3884	; 0x803884 <tick+0x3>
     d7c:	01 96       	adiw	r24, 0x01	; 1
     d7e:	a1 1d       	adc	r26, r1
     d80:	b1 1d       	adc	r27, r1
     d82:	80 93 81 38 	sts	0x3881, r24	; 0x803881 <tick>
     d86:	90 93 82 38 	sts	0x3882, r25	; 0x803882 <tick+0x1>
     d8a:	a0 93 83 38 	sts	0x3883, r26	; 0x803883 <tick+0x2>
     d8e:	b0 93 84 38 	sts	0x3884, r27	; 0x803884 <tick+0x3>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:68

    // TODO: we need to sleep while not playing and wake as soon as a key is pressed
    if (isPlaying) {
     d92:	80 91 8d 38 	lds	r24, 0x388D	; 0x80388d <isPlaying>
     d96:	88 23       	and	r24, r24
     d98:	e9 f1       	breq	.+122    	; 0xe14 <__vector_8+0xd8>
digitalWriteFast():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:298
     d9a:	0d 9a       	sbi	0x01, 5	; 1
__vector_8():
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:78
        // TODO: optimise
        digitalWriteFast(ENABLE_PIN, false); // on before next sample
    }

    // write the previously calculated sample first so the timing is reliable no matter how long it takes to calculate the next sample
    analogWrite(DAC_PIN, sample);
     d9c:	10 91 00 38 	lds	r17, 0x3800	; 0x803800 <__DATA_REGION_ORIGIN__>
analogWrite():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_analog.c:217
  uint8_t bit_mask  = digitalPinToBitMask(pin);
  if (bit_mask == NOT_A_PIN) {
    return;
  }
  // Set pin output because that's what Arduino does
  pinMode(pin, OUTPUT);
     da0:	61 e0       	ldi	r22, 0x01	; 1
     da2:	82 e0       	ldi	r24, 0x02	; 2
     da4:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <pinMode>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_analog.c:263
      // End of TCA case

  #if defined(DAC0)
    case DACOUT:
    {
      DAC0.DATA = val;
     da8:	10 93 a1 06 	sts	0x06A1, r17	; 0x8006a1 <vtable for SSD1306Device+0x7f704d>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_analog.c:264
      DAC0.CTRLA = 0x41; //OUTEN=1, ENABLE=1
     dac:	81 e4       	ldi	r24, 0x41	; 65
     dae:	80 93 a0 06 	sts	0x06A0, r24	; 0x8006a0 <vtable for SSD1306Device+0x7f704c>
nextSample():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:51

uint8_t nextSample(){

    uint16_t sample = 0;

    if (isPlaying) {
     db2:	80 91 8d 38 	lds	r24, 0x388D	; 0x80388d <isPlaying>
     db6:	88 23       	and	r24, r24
     db8:	09 f4       	brne	.+2      	; 0xdbc <__vector_8+0x80>
     dba:	b1 c0       	rjmp	.+354    	; 0xf1e <__vector_8+0x1e2>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:58
            if (oscillators[0].phase < oscillators[0].jump && i == 1 && syncOscillators) {
                // sync the second oscillator to the first one if oscillator sync is enabled and the first oscillator just wrapped
                oscillators[1].phase = oscillators[0].phase;
            }
            else {
                oscillators[i].phase += oscillators[i].jump;
     dbc:	40 91 17 38 	lds	r20, 0x3817	; 0x803817 <oscillators+0x6>
     dc0:	50 91 18 38 	lds	r21, 0x3818	; 0x803818 <oscillators+0x7>
     dc4:	60 91 19 38 	lds	r22, 0x3819	; 0x803819 <oscillators+0x8>
     dc8:	70 91 1a 38 	lds	r23, 0x381A	; 0x80381a <oscillators+0x9>
     dcc:	80 91 13 38 	lds	r24, 0x3813	; 0x803813 <oscillators+0x2>
     dd0:	90 91 14 38 	lds	r25, 0x3814	; 0x803814 <oscillators+0x3>
     dd4:	a0 91 15 38 	lds	r26, 0x3815	; 0x803815 <oscillators+0x4>
     dd8:	b0 91 16 38 	lds	r27, 0x3816	; 0x803816 <oscillators+0x5>
     ddc:	84 0f       	add	r24, r20
     dde:	95 1f       	adc	r25, r21
     de0:	a6 1f       	adc	r26, r22
     de2:	b7 1f       	adc	r27, r23
     de4:	80 93 17 38 	sts	0x3817, r24	; 0x803817 <oscillators+0x6>
     de8:	90 93 18 38 	sts	0x3818, r25	; 0x803818 <oscillators+0x7>
     dec:	a0 93 19 38 	sts	0x3819, r26	; 0x803819 <oscillators+0x8>
     df0:	b0 93 1a 38 	sts	0x381A, r27	; 0x80381a <oscillators+0x9>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:61
            }

            switch (oscillators[i].waveform) {
     df4:	20 91 11 38 	lds	r18, 0x3811	; 0x803811 <oscillators>
     df8:	30 91 12 38 	lds	r19, 0x3812	; 0x803812 <oscillators+0x1>
     dfc:	21 30       	cpi	r18, 0x01	; 1
     dfe:	31 05       	cpc	r19, r1
     e00:	09 f4       	brne	.+2      	; 0xe04 <__vector_8+0xc8>
     e02:	5b c0       	rjmp	.+182    	; 0xeba <__vector_8+0x17e>
     e04:	48 f0       	brcs	.+18     	; 0xe18 <__vector_8+0xdc>
     e06:	22 30       	cpi	r18, 0x02	; 2
     e08:	31 05       	cpc	r19, r1
     e0a:	09 f4       	brne	.+2      	; 0xe0e <__vector_8+0xd2>
     e0c:	79 c0       	rjmp	.+242    	; 0xf00 <__vector_8+0x1c4>
__vector_8():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:49
    isPlaying = true;
}

uint8_t nextSample(){

    uint16_t sample = 0;
     e0e:	90 e0       	ldi	r25, 0x00	; 0
     e10:	80 e0       	ldi	r24, 0x00	; 0
     e12:	57 c0       	rjmp	.+174    	; 0xec2 <__vector_8+0x186>
digitalWriteFast():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:294
    vport->OUT &= ~mask;
  else // CHANGE
    vport->IN = mask;
*/
  if (val == LOW)
    vport->OUT &= ~mask;
     e14:	0d 98       	cbi	0x01, 5	; 1
     e16:	c2 cf       	rjmp	.-124    	; 0xd9c <__vector_8+0x60>
pulseSample():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:125
uint8_t pulseSample(oscillator_t *oscillator) {

    // TODO: something is buggy in here.

    // forwards/backwards
    uint32_t newPulse = oscillator->pulse + oscillator->pulseAmount; // TODO: this is probably the bug. overflow.
     e18:	40 91 1b 38 	lds	r20, 0x381B	; 0x80381b <oscillators+0xa>
     e1c:	50 91 1c 38 	lds	r21, 0x381C	; 0x80381c <oscillators+0xb>
     e20:	60 91 1d 38 	lds	r22, 0x381D	; 0x80381d <oscillators+0xc>
     e24:	70 91 1e 38 	lds	r23, 0x381E	; 0x80381e <oscillators+0xd>
     e28:	00 91 1f 38 	lds	r16, 0x381F	; 0x80381f <oscillators+0xe>
     e2c:	10 91 20 38 	lds	r17, 0x3820	; 0x803820 <oscillators+0xf>
     e30:	20 91 21 38 	lds	r18, 0x3821	; 0x803821 <oscillators+0x10>
     e34:	30 91 22 38 	lds	r19, 0x3822	; 0x803822 <oscillators+0x11>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:126
    if (newPulse < MIN_PULSE || newPulse > MAX_PULSE) {
     e38:	6a 01       	movw	r12, r20
     e3a:	7b 01       	movw	r14, r22
     e3c:	e9 e9       	ldi	r30, 0x99	; 153
     e3e:	ce 1a       	sub	r12, r30
     e40:	de 0a       	sbc	r13, r30
     e42:	ee 0a       	sbc	r14, r30
     e44:	e9 e1       	ldi	r30, 0x19	; 25
     e46:	fe 0a       	sbc	r15, r30
     e48:	c0 0e       	add	r12, r16
     e4a:	d1 1e       	adc	r13, r17
     e4c:	e2 1e       	adc	r14, r18
     e4e:	f3 1e       	adc	r15, r19
     e50:	ef ec       	ldi	r30, 0xCF	; 207
     e52:	ce 16       	cp	r12, r30
     e54:	ec ec       	ldi	r30, 0xCC	; 204
     e56:	de 06       	cpc	r13, r30
     e58:	ee 06       	cpc	r14, r30
     e5a:	fe 06       	cpc	r15, r30
     e5c:	78 f0       	brcs	.+30     	; 0xe7c <__vector_8+0x140>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:127
        oscillator->pulseAmount = -oscillator->pulseAmount;
     e5e:	30 95       	com	r19
     e60:	20 95       	com	r18
     e62:	10 95       	com	r17
     e64:	01 95       	neg	r16
     e66:	1f 4f       	sbci	r17, 0xFF	; 255
     e68:	2f 4f       	sbci	r18, 0xFF	; 255
     e6a:	3f 4f       	sbci	r19, 0xFF	; 255
     e6c:	00 93 1f 38 	sts	0x381F, r16	; 0x80381f <oscillators+0xe>
     e70:	10 93 20 38 	sts	0x3820, r17	; 0x803820 <oscillators+0xf>
     e74:	20 93 21 38 	sts	0x3821, r18	; 0x803821 <oscillators+0x10>
     e78:	30 93 22 38 	sts	0x3822, r19	; 0x803822 <oscillators+0x11>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:131
    }

    // TODO: This will drift because the last one won't make it to the end before bouncing back. Does that matter, though?
    oscillator->pulse += oscillator->pulseAmount;
     e7c:	00 91 1f 38 	lds	r16, 0x381F	; 0x80381f <oscillators+0xe>
     e80:	10 91 20 38 	lds	r17, 0x3820	; 0x803820 <oscillators+0xf>
     e84:	20 91 21 38 	lds	r18, 0x3821	; 0x803821 <oscillators+0x10>
     e88:	30 91 22 38 	lds	r19, 0x3822	; 0x803822 <oscillators+0x11>
     e8c:	40 0f       	add	r20, r16
     e8e:	51 1f       	adc	r21, r17
     e90:	62 1f       	adc	r22, r18
     e92:	73 1f       	adc	r23, r19
     e94:	40 93 1b 38 	sts	0x381B, r20	; 0x80381b <oscillators+0xa>
     e98:	50 93 1c 38 	sts	0x381C, r21	; 0x80381c <oscillators+0xb>
     e9c:	60 93 1d 38 	sts	0x381D, r22	; 0x80381d <oscillators+0xc>
     ea0:	70 93 1e 38 	sts	0x381E, r23	; 0x80381e <oscillators+0xd>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:134

    // funny how we're using a DAC and right now we're only using it to make a square wave :)
    if (oscillator->phase < oscillator->pulse) {
     ea4:	21 e0       	ldi	r18, 0x01	; 1
     ea6:	84 17       	cp	r24, r20
     ea8:	95 07       	cpc	r25, r21
     eaa:	a6 07       	cpc	r26, r22
     eac:	b7 07       	cpc	r27, r23
     eae:	08 f0       	brcs	.+2      	; 0xeb2 <__vector_8+0x176>
     eb0:	20 e0       	ldi	r18, 0x00	; 0
     eb2:	21 95       	neg	r18
nextSample():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:63
                oscillators[i].phase += oscillators[i].jump;
            }

            switch (oscillators[i].waveform) {
                case WAVE_PULSE:
                    sample += pulseSample(&oscillators[i]);
     eb4:	82 2f       	mov	r24, r18
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:71
                case WAVE_SAW:
                    sample += sawSample(&oscillators[i]);
                    break;

                case WAVE_TRIANGLE:
                    sample += triangleSample(&oscillators[i]);
     eb6:	90 e0       	ldi	r25, 0x00	; 0
     eb8:	04 c0       	rjmp	.+8      	; 0xec2 <__vector_8+0x186>
sawSample():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:146
}

uint8_t sawSample(oscillator_t *oscillator) {

    // top 8 bits of the 32 bit number
    return oscillator->phase >> 24;
     eba:	8b 2f       	mov	r24, r27
     ebc:	99 27       	eor	r25, r25
     ebe:	aa 27       	eor	r26, r26
     ec0:	bb 27       	eor	r27, r27
nextSample():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:75
                case WAVE_TRIANGLE:
                    sample += triangleSample(&oscillators[i]);
                    break;
            }
        }
        sample = sample >> 1; // roughly divide by 2
     ec2:	96 95       	lsr	r25
     ec4:	87 95       	ror	r24
__vector_8():
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:81

    // calculate the sample for next time
    sample = nextSample();
     ec6:	80 93 00 38 	sts	0x3800, r24	; 0x803800 <__DATA_REGION_ORIGIN__>
digitalWriteFast():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_digital.c:294
     eca:	2c 98       	cbi	0x05, 4	; 5
__vector_8():
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:86

    digitalWriteFast(LED_PIN, false); // TODO: optimise

    // The interrupt flag has to be cleared manually
    TCA0.SINGLE.INTFLAGS = TCA_SINGLE_OVF_bm;
     ecc:	81 e0       	ldi	r24, 0x01	; 1
     ece:	80 93 0b 0a 	sts	0x0A0B, r24	; 0x800a0b <vtable for SSD1306Device+0x7f73b7>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:87
}
     ed2:	ff 91       	pop	r31
     ed4:	ef 91       	pop	r30
     ed6:	bf 91       	pop	r27
     ed8:	af 91       	pop	r26
     eda:	9f 91       	pop	r25
     edc:	8f 91       	pop	r24
     ede:	7f 91       	pop	r23
     ee0:	6f 91       	pop	r22
     ee2:	5f 91       	pop	r21
     ee4:	4f 91       	pop	r20
     ee6:	3f 91       	pop	r19
     ee8:	2f 91       	pop	r18
     eea:	1f 91       	pop	r17
     eec:	0f 91       	pop	r16
     eee:	ff 90       	pop	r15
     ef0:	ef 90       	pop	r14
     ef2:	df 90       	pop	r13
     ef4:	cf 90       	pop	r12
     ef6:	0f 90       	pop	r0
     ef8:	0f be       	out	0x3f, r0	; 63
     efa:	0f 90       	pop	r0
     efc:	1f 90       	pop	r1
     efe:	18 95       	reti
triangleSample():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:151
    return oscillator->phase >> 24;
}

uint8_t triangleSample(oscillator_t *oscillator) {

    int8_t temp = oscillator->phase >> 24;
     f00:	8b 2f       	mov	r24, r27
     f02:	99 27       	eor	r25, r25
     f04:	aa 27       	eor	r26, r26
     f06:	bb 27       	eor	r27, r27
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:152
    int8_t mask = temp >> 7;
     f08:	28 2f       	mov	r18, r24
     f0a:	08 2e       	mov	r0, r24
     f0c:	00 0c       	add	r0, r0
     f0e:	33 0b       	sbc	r19, r19
     f10:	22 0f       	add	r18, r18
     f12:	23 2f       	mov	r18, r19
     f14:	22 1f       	adc	r18, r18
     f16:	33 0b       	sbc	r19, r19
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:154

    return (uint8_t) (temp ^ mask) << 1;
     f18:	82 27       	eor	r24, r18
     f1a:	88 0f       	add	r24, r24
     f1c:	cc cf       	rjmp	.-104    	; 0xeb6 <__vector_8+0x17a>
__vector_8():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:79
        }
        sample = sample >> 1; // roughly divide by 2
    }
    else {
        //sample = 127; // middle value
        sample = 0;
     f1e:	80 e0       	ldi	r24, 0x00	; 0
     f20:	d2 cf       	rjmp	.-92     	; 0xec6 <__vector_8+0x18a>

00000f22 <global constructors keyed to 65535_0_engine.cpp.o.3393>:
_GLOBAL__I_65535_0_engine.cpp.o.3393():
     f22:	e2 e9       	ldi	r30, 0x92	; 146
     f24:	f8 e3       	ldi	r31, 0x38	; 56
     f26:	12 82       	std	Z+2, r1	; 0x02
     f28:	13 82       	std	Z+3, r1	; 0x03
     f2a:	88 ee       	ldi	r24, 0xE8	; 232
     f2c:	93 e0       	ldi	r25, 0x03	; 3
     f2e:	a0 e0       	ldi	r26, 0x00	; 0
     f30:	b0 e0       	ldi	r27, 0x00	; 0
     f32:	84 83       	std	Z+4, r24	; 0x04
     f34:	95 83       	std	Z+5, r25	; 0x05
     f36:	a6 83       	std	Z+6, r26	; 0x06
     f38:	b7 83       	std	Z+7, r27	; 0x07
     f3a:	2e e2       	ldi	r18, 0x2E	; 46
     f3c:	36 e9       	ldi	r19, 0x96	; 150
     f3e:	20 83       	st	Z, r18
     f40:	31 83       	std	Z+1, r19	; 0x01
     f42:	20 e0       	ldi	r18, 0x00	; 0
     f44:	38 e0       	ldi	r19, 0x08	; 8
     f46:	24 87       	std	Z+12, r18	; 0x0c
     f48:	35 87       	std	Z+13, r19	; 0x0d
     f4a:	26 e0       	ldi	r18, 0x06	; 6
     f4c:	26 87       	std	Z+14, r18	; 0x0e
     f4e:	27 e0       	ldi	r18, 0x07	; 7
     f50:	27 87       	std	Z+15, r18	; 0x0f
     f52:	10 8a       	std	Z+16, r1	; 0x10
     f54:	2f e0       	ldi	r18, 0x0F	; 15
     f56:	21 8b       	std	Z+17, r18	; 0x11
     f58:	2e e0       	ldi	r18, 0x0E	; 14
     f5a:	22 8b       	std	Z+18, r18	; 0x12
     f5c:	21 e0       	ldi	r18, 0x01	; 1
     f5e:	23 8b       	std	Z+19, r18	; 0x13
     f60:	14 8a       	std	Z+20, r1	; 0x14
     f62:	15 8a       	std	Z+21, r1	; 0x15
     f64:	16 8a       	std	Z+22, r1	; 0x16
     f66:	17 8a       	std	Z+23, r1	; 0x17
     f68:	10 8e       	std	Z+24, r1	; 0x18
     f6a:	11 8e       	std	Z+25, r1	; 0x19
     f6c:	2c e1       	ldi	r18, 0x1C	; 28
     f6e:	22 8f       	std	Z+26, r18	; 0x1a
     f70:	ed e2       	ldi	r30, 0x2D	; 45
     f72:	f9 e3       	ldi	r31, 0x39	; 57
     f74:	12 82       	std	Z+2, r1	; 0x02
     f76:	13 82       	std	Z+3, r1	; 0x03
     f78:	84 83       	std	Z+4, r24	; 0x04
     f7a:	95 83       	std	Z+5, r25	; 0x05
     f7c:	a6 83       	std	Z+6, r26	; 0x06
     f7e:	b7 83       	std	Z+7, r27	; 0x07
     f80:	88 e4       	ldi	r24, 0x48	; 72
     f82:	96 e9       	ldi	r25, 0x96	; 150
     f84:	80 83       	st	Z, r24
     f86:	91 83       	std	Z+1, r25	; 0x01
     f88:	ef e3       	ldi	r30, 0x3F	; 63
     f8a:	f9 e3       	ldi	r31, 0x39	; 57
     f8c:	12 82       	std	Z+2, r1	; 0x02
     f8e:	13 82       	std	Z+3, r1	; 0x03
     f90:	88 e5       	ldi	r24, 0x58	; 88
     f92:	96 e9       	ldi	r25, 0x96	; 150
     f94:	80 83       	st	Z, r24
     f96:	91 83       	std	Z+1, r25	; 0x01
     f98:	84 e0       	ldi	r24, 0x04	; 4
     f9a:	93 e0       	ldi	r25, 0x03	; 3
     f9c:	80 93 3d 39 	sts	0x393D, r24	; 0x80393d <wireBeginTransmissionFn>
     fa0:	90 93 3e 39 	sts	0x393E, r25	; 0x80393e <wireBeginTransmissionFn+0x1>
     fa4:	86 e4       	ldi	r24, 0x46	; 70
     fa6:	92 e0       	ldi	r25, 0x02	; 2
     fa8:	80 93 3b 39 	sts	0x393B, r24	; 0x80393b <wireWriteFn>
     fac:	90 93 3c 39 	sts	0x393C, r25	; 0x80393c <wireWriteFn+0x1>
     fb0:	8d e0       	ldi	r24, 0x0D	; 13
     fb2:	93 e0       	ldi	r25, 0x03	; 3
     fb4:	80 93 39 39 	sts	0x3939, r24	; 0x803939 <wireEndTransmissionFn>
     fb8:	90 93 3a 39 	sts	0x393A, r25	; 0x80393a <wireEndTransmissionFn+0x1>
     fbc:	08 95       	ret

00000fbe <main>:
init():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:601

  /******************************** CLOCK STUFF *********************************/
  #if (CLOCK_SOURCE==0)
  #if (F_CPU == 20000000)
  /* No division on clock */
  _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, 0x00);
     fbe:	88 ed       	ldi	r24, 0xD8	; 216
     fc0:	90 e0       	ldi	r25, 0x00	; 0
     fc2:	84 bf       	out	0x34, r24	; 52
     fc4:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <vtable for SSD1306Device+0x7f6a0d>
init_ADC0():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:669
    be connected to the pin for longer, though the datasheet does not explicitly
    state that this is the case. However, we can use the SAMPLEN register to
    compensate for this! */

  #if F_CPU >= 12000000 // 16 MHz / 16 = 1 MHz,  20 MHz / 16 = 1.25 MHz
  ADC0.CTRLC = ADC_PRESC_DIV16_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;;
     fc8:	83 e5       	ldi	r24, 0x53	; 83
     fca:	80 93 02 06 	sts	0x0602, r24	; 0x800602 <vtable for SSD1306Device+0x7f6fae>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:677
  #elif F_CPU >= 3000000 // 4 MHz / 32 = 1 MHz, 5 MHz / 32 = 1.25 MHz
  ADC0.CTRLC = ADC_PRESC_DIV4_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;;
  #else  // 1 MHz / 2 = 500 kHz - the lowest setting
  ADC0.CTRLC = ADC_PRESC_DIV2_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;;
  #endif
  ADC0.SAMPCTRL = 14; //16 ADC clock sampling time - should be about the same amount of *time* as originally?
     fce:	8e e0       	ldi	r24, 0x0E	; 14
     fd0:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <vtable for SSD1306Device+0x7f6fb1>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:694
  ADC0.CTRLC = ADC_PRESC_DIV8_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;;
  #else // 128 kHz / 2 = 64 kHz -> This is the closest you can get, the prescaler is 2
  ADC0.CTRLC = ADC_PRESC_DIV2_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;;
  #endif
  #endif
  ADC0.CTRLD = ADC_INITDLY_DLY16_gc;
     fd4:	80 e2       	ldi	r24, 0x20	; 32
     fd6:	80 93 03 06 	sts	0x0603, r24	; 0x800603 <vtable for SSD1306Device+0x7f6faf>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:696
  /* Enable ADC */
  ADC0.CTRLA |= ADC_ENABLE_bm;
     fda:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <vtable for SSD1306Device+0x7f6fac>
     fde:	81 60       	ori	r24, 0x01	; 1
     fe0:	80 93 00 06 	sts	0x0600, r24	; 0x800600 <vtable for SSD1306Device+0x7f6fac>
init_TCA0():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:776

  /* PORTMUX setting for TCA - don't need to set because using default */
  //PORTMUX.CTRLA = PORTMUX_TCA00_DEFAULT_gc;

  /* Enable Split Mode */
  TCA0.SPLIT.CTRLD = TCA_SPLIT_SPLITM_bm;
     fe4:	91 e0       	ldi	r25, 0x01	; 1
     fe6:	90 93 03 0a 	sts	0x0A03, r25	; 0x800a03 <vtable for SSD1306Device+0x7f73af>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:781

  //Only 1 WGM so no need to specifically set up.

  /* Period setting, 8-bit register in SPLIT mode */
  TCA0.SPLIT.LPER    = PWM_TIMER_PERIOD;
     fea:	8e ef       	ldi	r24, 0xFE	; 254
     fec:	80 93 26 0a 	sts	0x0A26, r24	; 0x800a26 <vtable for SSD1306Device+0x7f73d2>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:782
  TCA0.SPLIT.HPER    = PWM_TIMER_PERIOD;
     ff0:	80 93 27 0a 	sts	0x0A27, r24	; 0x800a27 <vtable for SSD1306Device+0x7f73d3>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:799

  /* Use prescale appropriate for system clock speed */
  #if (F_CPU > 25000000) //   use 256 divider when clocked over 25 MHz - probably not terribly relevant - though they might be viable at 30 or 32, and are viable at 24/25 MHz.
    TCA0.SPLIT.CTRLA   = (TCA_SPLIT_CLKSEL_DIV256_gc) | (TCA_SPLIT_ENABLE_bm);
  #elif (F_CPU > 5000000) //  use 64 divider
    TCA0.SPLIT.CTRLA   =  (TCA_SPLIT_CLKSEL_DIV64_gc) | (TCA_SPLIT_ENABLE_bm);
     ff4:	8b e0       	ldi	r24, 0x0B	; 11
     ff6:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <vtable for SSD1306Device+0x7f73ac>
init_millis():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:541
    #if defined(MILLIS_USE_TIMERA0)
      TCA0.SPLIT.INTCTRL |= TCA_SPLIT_HUNF_bm;
    #elif defined(MILLIS_USE_TIMERA1)
      TCA1.SPLIT.INTCTRL |= TCA_SPLIT_HUNF_bm;
    #elif defined(MILLIS_USE_TIMERD0)
      TCD0.CMPBCLR        = TIME_TRACKING_TIMER_PERIOD; //essentially, this is TOP
     ffa:	2d ef       	ldi	r18, 0xFD	; 253
     ffc:	31 e0       	ldi	r19, 0x01	; 1
     ffe:	20 93 ae 0a 	sts	0x0AAE, r18	; 0x800aae <vtable for SSD1306Device+0x7f745a>
    1002:	30 93 af 0a 	sts	0x0AAF, r19	; 0x800aaf <vtable for SSD1306Device+0x7f745b>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:542
      TCD0.INTCTRL        = 0x01;//enable interrupt
    1006:	90 93 8c 0a 	sts	0x0A8C, r25	; 0x800a8c <vtable for SSD1306Device+0x7f7438>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:543
      TCD0.CTRLB          = 0x00; //oneramp mode
    100a:	10 92 81 0a 	sts	0x0A81, r1	; 0x800a81 <vtable for SSD1306Device+0x7f742d>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:544
      TCD0.CTRLC          = 0x80;
    100e:	80 e8       	ldi	r24, 0x80	; 128
    1010:	80 93 82 0a 	sts	0x0A82, r24	; 0x800a82 <vtable for SSD1306Device+0x7f742e>
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:545
      TCD0.CTRLA          = TIMERD0_PRESCALER | 0x01; //set clock source and enable!
    1014:	81 e1       	ldi	r24, 0x11	; 17
    1016:	80 93 80 0a 	sts	0x0A80, r24	; 0x800a80 <vtable for SSD1306Device+0x7f742c>
init():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring.c:651
  #ifndef MILLIS_USE_TIMERNONE
  init_millis();
  #endif //end #ifndef MILLIS_USE_TIMERNONE
  /*************************** ENABLE GLOBAL INTERRUPTS *************************/

  sei();
    101a:	78 94       	sei
DACReference():
/Users/lerouxb/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.2.8/cores/megatinycore/wiring_analog.c:134

#ifdef DAC0
void DACReference(uint8_t mode) {
  check_valid_dac_ref(mode);
  if (mode < 5) {
    VREF.CTRLA = mode | (VREF.CTRLA & (~VREF_DAC0REFSEL_gm));
    101c:	80 91 a0 00 	lds	r24, 0x00A0	; 0x8000a0 <vtable for SSD1306Device+0x7f6a4c>
    1020:	88 7f       	andi	r24, 0xF8	; 248
    1022:	82 60       	ori	r24, 0x02	; 2
    1024:	80 93 a0 00 	sts	0x00A0, r24	; 0x8000a0 <vtable for SSD1306Device+0x7f6a4c>
setup():
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:24

    DACReference(INTERNAL2V5);

    // setup a timer overflow interrupt to fire at 25khz
    // system clock is 20Mhz. Prescaler is 16. Period is 49 (so it will be 49+1 = 50)
    TCA0.SINGLE.INTCTRL = 0 << TCA_SINGLE_CMP0_bp   /* Compare 0 Interrupt: disabled */
    1028:	90 93 0a 0a 	sts	0x0A0A, r25	; 0x800a0a <vtable for SSD1306Device+0x7f73b6>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:29
                          | 0 << TCA_SINGLE_CMP1_bp /* Compare 1 Interrupt: disabled */
                          | 0 << TCA_SINGLE_CMP2_bp /* Compare 2 Interrupt: disabled */
                          | 1 << TCA_SINGLE_OVF_bp; /* Overflow Interrupt: enabled */

    TCA0.SINGLE.PER = 49; /* 49 + 1 == 50 */
    102c:	81 e3       	ldi	r24, 0x31	; 49
    102e:	90 e0       	ldi	r25, 0x00	; 0
    1030:	80 93 26 0a 	sts	0x0A26, r24	; 0x800a26 <vtable for SSD1306Device+0x7f73d2>
    1034:	90 93 27 0a 	sts	0x0A27, r25	; 0x800a27 <vtable for SSD1306Device+0x7f73d3>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:31

    TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV16_gc /* System Clock / 16 */
    1038:	89 e0       	ldi	r24, 0x09	; 9
    103a:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <vtable for SSD1306Device+0x7f73ac>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:38

    // TODO: set up the sleep stuff

    // presumably we don't have to configure DAC_PIN, KEYS_PIN, serial or i2c pins

    pinMode(LED_PIN, OUTPUT);
    103e:	61 e0       	ldi	r22, 0x01	; 1
    1040:	85 e0       	ldi	r24, 0x05	; 5
    1042:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <pinMode>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:39
    pinMode(DAC_PIN, OUTPUT);
    1046:	61 e0       	ldi	r22, 0x01	; 1
    1048:	82 e0       	ldi	r24, 0x02	; 2
    104a:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <pinMode>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:40
    pinMode(ENABLE_PIN, OUTPUT);
    104e:	61 e0       	ldi	r22, 0x01	; 1
    1050:	81 e0       	ldi	r24, 0x01	; 1
    1052:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <pinMode>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:41
    pinMode(BUTTON_LEFT_PIN, INPUT_PULLUP);
    1056:	62 e0       	ldi	r22, 0x02	; 2
    1058:	8a e0       	ldi	r24, 0x0A	; 10
    105a:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <pinMode>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:42
    pinMode(BUTTON_DOWN_PIN, INPUT_PULLUP);
    105e:	62 e0       	ldi	r22, 0x02	; 2
    1060:	8b e0       	ldi	r24, 0x0B	; 11
    1062:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <pinMode>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:43
    pinMode(BUTTON_UP_PIN, INPUT_PULLUP);
    1066:	62 e0       	ldi	r22, 0x02	; 2
    1068:	8c e0       	ldi	r24, 0x0C	; 12
    106a:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <pinMode>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:44
    pinMode(BUTTON_RIGHT_PIN, INPUT_PULLUP);
    106e:	62 e0       	ldi	r22, 0x02	; 2
    1070:	8d e0       	ldi	r24, 0x0D	; 13
    1072:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <pinMode>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:45
    pinMode(BUTTON_SELECT_PIN, INPUT_PULLUP);
    1076:	62 e0       	ldi	r22, 0x02	; 2
    1078:	8e e0       	ldi	r24, 0x0E	; 14
    107a:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <pinMode>
/Users/lerouxb/src/minor-1/firmware/minor-1/minor-1.ino:51

    // TODO: make sure all pins are dealt with from a power consumption perspective

    //initDisplay();

    Serial.begin(115200);
    107e:	40 e0       	ldi	r20, 0x00	; 0
    1080:	52 ec       	ldi	r21, 0xC2	; 194
    1082:	61 e0       	ldi	r22, 0x01	; 1
    1084:	70 e0       	ldi	r23, 0x00	; 0
    1086:	82 e9       	ldi	r24, 0x92	; 146
    1088:	98 e3       	ldi	r25, 0x38	; 56
    108a:	0e 94 99 02 	call	0x532	; 0x532 <UartClass::begin(unsigned long)>
updateMenuItem():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:324
    }
}

void updateMenuItem(int8_t delta) {

    tweakTimeout = TWEAK_TICKS;
    108e:	08 ea       	ldi	r16, 0xA8	; 168
    1090:	11 e6       	ldi	r17, 0x61	; 97
updateMenuItemValue():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:382


        case ITEM_SYNC: {
            // this lives in the second oscillator's menu
            bool currentSync = getOscillatorSync();
            setOscillatorSync(!currentSync);
    1092:	d1 e0       	ldi	r29, 0x01	; 1
getNavigationDeltas():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:228

    // This only applies if a button was pressed

    bounceTimeout = DEBOUNCE_TICKS;
    if (repeating) {
        repeatTimeout = REPEAT_TICKS2;
    1094:	30 ed       	ldi	r19, 0xD0	; 208
    1096:	23 2e       	mov	r2, r19
    1098:	37 e0       	ldi	r19, 0x07	; 7
    109a:	33 2e       	mov	r3, r19
clearNote():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:34
void clearNote() {

    // for now this is one to one with jump == -1, but once we have things like envelopes that assumption won't hold
    isPlaying = false;

    oscillators[0].jump = -1;
    109c:	cc 24       	eor	r12, r12
    109e:	ca 94       	dec	r12
    10a0:	dc 2c       	mov	r13, r12
    10a2:	76 01       	movw	r14, r12
getNavigationDeltas():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:168
navdeltas_t getNavigationDeltas() {

    navdeltas_t deltas = { leftRight: 0,  upDown: 0 };

    // tick wraps about once every 2 days :)
    if (lastTick > tick) {
    10a4:	80 91 81 38 	lds	r24, 0x3881	; 0x803881 <tick>
    10a8:	90 91 82 38 	lds	r25, 0x3882	; 0x803882 <tick+0x1>
    10ac:	a0 91 83 38 	lds	r26, 0x3883	; 0x803883 <tick+0x2>
    10b0:	b0 91 84 38 	lds	r27, 0x3884	; 0x803884 <tick+0x3>
    10b4:	40 91 85 38 	lds	r20, 0x3885	; 0x803885 <lastTick>
    10b8:	50 91 86 38 	lds	r21, 0x3886	; 0x803886 <lastTick+0x1>
    10bc:	60 91 87 38 	lds	r22, 0x3887	; 0x803887 <lastTick+0x2>
    10c0:	70 91 88 38 	lds	r23, 0x3888	; 0x803888 <lastTick+0x3>
    10c4:	84 17       	cp	r24, r20
    10c6:	95 07       	cpc	r25, r21
    10c8:	a6 07       	cpc	r26, r22
    10ca:	b7 07       	cpc	r27, r23
    10cc:	40 f4       	brcc	.+16     	; 0x10de <main+0x120>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:169
        lastTick = 0;
    10ce:	10 92 85 38 	sts	0x3885, r1	; 0x803885 <lastTick>
    10d2:	10 92 86 38 	sts	0x3886, r1	; 0x803886 <lastTick+0x1>
    10d6:	10 92 87 38 	sts	0x3887, r1	; 0x803887 <lastTick+0x2>
    10da:	10 92 88 38 	sts	0x3888, r1	; 0x803888 <lastTick+0x3>
    10de:	40 90 85 38 	lds	r4, 0x3885	; 0x803885 <lastTick>
    10e2:	50 90 86 38 	lds	r5, 0x3886	; 0x803886 <lastTick+0x1>
    10e6:	60 90 87 38 	lds	r6, 0x3887	; 0x803887 <lastTick+0x2>
    10ea:	70 90 88 38 	lds	r7, 0x3888	; 0x803888 <lastTick+0x3>
    10ee:	40 91 8e 38 	lds	r20, 0x388E	; 0x80388e <tweakTimeout>
    10f2:	50 91 8f 38 	lds	r21, 0x388F	; 0x80388f <tweakTimeout+0x1>
    10f6:	20 91 7f 38 	lds	r18, 0x387F	; 0x80387f <bounceTimeout>
    10fa:	30 91 80 38 	lds	r19, 0x3880	; 0x803880 <bounceTimeout+0x1>
    10fe:	80 91 7d 38 	lds	r24, 0x387D	; 0x80387d <repeatTimeout>
    1102:	90 91 7e 38 	lds	r25, 0x387E	; 0x80387e <repeatTimeout+0x1>
    1106:	60 91 7c 38 	lds	r22, 0x387C	; 0x80387c <repeating>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:172
    }

    while (lastTick < tick) {
    110a:	80 90 81 38 	lds	r8, 0x3881	; 0x803881 <tick>
    110e:	90 90 82 38 	lds	r9, 0x3882	; 0x803882 <tick+0x1>
    1112:	a0 90 83 38 	lds	r10, 0x3883	; 0x803883 <tick+0x2>
    1116:	b0 90 84 38 	lds	r11, 0x3884	; 0x803884 <tick+0x3>
    111a:	48 14       	cp	r4, r8
    111c:	59 04       	cpc	r5, r9
    111e:	6a 04       	cpc	r6, r10
    1120:	7b 04       	cpc	r7, r11
    1122:	18 f5       	brcc	.+70     	; 0x116a <main+0x1ac>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:175
        ++lastTick;

        if (tweakTimeout > 0) {
    1124:	41 15       	cp	r20, r1
    1126:	51 05       	cpc	r21, r1
    1128:	11 f0       	breq	.+4      	; 0x112e <main+0x170>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:176
            --tweakTimeout;
    112a:	41 50       	subi	r20, 0x01	; 1
    112c:	51 09       	sbc	r21, r1
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:180
        }

        // don't bother checking if the buttons are released if we're not bouncing or repeating
        if (bounceTimeout > 0 || repeatTimeout > 0) {
    112e:	21 15       	cp	r18, r1
    1130:	31 05       	cpc	r19, r1
    1132:	69 f4       	brne	.+26     	; 0x114e <main+0x190>
    1134:	00 97       	sbiw	r24, 0x00	; 0
    1136:	69 f4       	brne	.+26     	; 0x1152 <main+0x194>
    1138:	9c 01       	movw	r18, r24
    113a:	03 c0       	rjmp	.+6      	; 0x1142 <main+0x184>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:191
            // TODO: optimise. these are the only things on port C
            // TODO: the assumption here is that the button is still the same one. Which might be assuming too much
            if (digitalReadFast(BUTTON_LEFT_PIN) == true && digitalReadFast(BUTTON_RIGHT_PIN) == true && digitalReadFast(BUTTON_UP_PIN) == true && digitalReadFast(BUTTON_DOWN_PIN) == true) {
                // immediately clear repeat if the button is lifted
                repeatTimeout = 0;
                repeating = false;
    113c:	60 e0       	ldi	r22, 0x00	; 0
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:190

            // TODO: optimise. these are the only things on port C
            // TODO: the assumption here is that the button is still the same one. Which might be assuming too much
            if (digitalReadFast(BUTTON_LEFT_PIN) == true && digitalReadFast(BUTTON_RIGHT_PIN) == true && digitalReadFast(BUTTON_UP_PIN) == true && digitalReadFast(BUTTON_DOWN_PIN) == true) {
                // immediately clear repeat if the button is lifted
                repeatTimeout = 0;
    113e:	90 e0       	ldi	r25, 0x00	; 0
    1140:	80 e0       	ldi	r24, 0x00	; 0
    1142:	7f ef       	ldi	r23, 0xFF	; 255
    1144:	47 1a       	sub	r4, r23
    1146:	57 0a       	sbc	r5, r23
    1148:	67 0a       	sbc	r6, r23
    114a:	77 0a       	sbc	r7, r23
    114c:	de cf       	rjmp	.-68     	; 0x110a <main+0x14c>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:183

        // don't bother checking if the buttons are released if we're not bouncing or repeating
        if (bounceTimeout > 0 || repeatTimeout > 0) {
            // always count down bounce regardless of whether a button is held down or not
            if (bounceTimeout > 0) {
                --bounceTimeout;
    114e:	21 50       	subi	r18, 0x01	; 1
    1150:	31 09       	sbc	r19, r1
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:188
            }

            // TODO: optimise. these are the only things on port C
            // TODO: the assumption here is that the button is still the same one. Which might be assuming too much
            if (digitalReadFast(BUTTON_LEFT_PIN) == true && digitalReadFast(BUTTON_RIGHT_PIN) == true && digitalReadFast(BUTTON_UP_PIN) == true && digitalReadFast(BUTTON_DOWN_PIN) == true) {
    1152:	50 9b       	sbis	0x0a, 0	; 10
    1154:	06 c0       	rjmp	.+12     	; 0x1162 <main+0x1a4>
    1156:	53 9b       	sbis	0x0a, 3	; 10
    1158:	04 c0       	rjmp	.+8      	; 0x1162 <main+0x1a4>
    115a:	52 9b       	sbis	0x0a, 2	; 10
    115c:	02 c0       	rjmp	.+4      	; 0x1162 <main+0x1a4>
    115e:	51 99       	sbic	0x0a, 1	; 10
    1160:	ed cf       	rjmp	.-38     	; 0x113c <main+0x17e>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:195
                repeatTimeout = 0;
                repeating = false;
            }
            else {
                // count down repeat while a button is held down
                if (repeatTimeout > 0) {
    1162:	00 97       	sbiw	r24, 0x00	; 0
    1164:	71 f3       	breq	.-36     	; 0x1142 <main+0x184>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:196
                    --repeatTimeout;
    1166:	01 97       	sbiw	r24, 0x01	; 1
    1168:	ec cf       	rjmp	.-40     	; 0x1142 <main+0x184>
    116a:	20 93 7f 38 	sts	0x387F, r18	; 0x80387f <bounceTimeout>
    116e:	30 93 80 38 	sts	0x3880, r19	; 0x803880 <bounceTimeout+0x1>
    1172:	80 93 7d 38 	sts	0x387D, r24	; 0x80387d <repeatTimeout>
    1176:	90 93 7e 38 	sts	0x387E, r25	; 0x80387e <repeatTimeout+0x1>
    117a:	60 93 7c 38 	sts	0x387C, r22	; 0x80387c <repeating>
    117e:	40 92 85 38 	sts	0x3885, r4	; 0x803885 <lastTick>
    1182:	50 92 86 38 	sts	0x3886, r5	; 0x803886 <lastTick+0x1>
    1186:	60 92 87 38 	sts	0x3887, r6	; 0x803887 <lastTick+0x2>
    118a:	70 92 88 38 	sts	0x3888, r7	; 0x803888 <lastTick+0x3>
    118e:	40 93 8e 38 	sts	0x388E, r20	; 0x80388e <tweakTimeout>
    1192:	50 93 8f 38 	sts	0x388F, r21	; 0x80388f <tweakTimeout+0x1>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:203
            }
        }
    }

    // if we're still bouncing or repeating, ignore all presses
    if (bounceTimeout != 0 || repeatTimeout != 0) {
    1196:	23 2b       	or	r18, r19
    1198:	09 f0       	breq	.+2      	; 0x119c <main+0x1de>
    119a:	a5 c0       	rjmp	.+330    	; 0x12e6 <main+0x328>
    119c:	89 2b       	or	r24, r25
    119e:	09 f0       	breq	.+2      	; 0x11a2 <main+0x1e4>
    11a0:	a2 c0       	rjmp	.+324    	; 0x12e6 <main+0x328>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:207
        return deltas;
    }

    if (digitalReadFast(BUTTON_LEFT_PIN) == false) {
    11a2:	50 9b       	sbis	0x0a, 0	; 10
    11a4:	09 c0       	rjmp	.+18     	; 0x11b8 <main+0x1fa>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:210
        deltas.leftRight = -1;
    }
    else if (digitalReadFast(BUTTON_RIGHT_PIN) == false) {
    11a6:	53 9b       	sbis	0x0a, 3	; 10
    11a8:	45 c0       	rjmp	.+138    	; 0x1234 <main+0x276>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:213
        deltas.leftRight = 1;
    }
    else if (digitalReadFast(BUTTON_UP_PIN) == false) {
    11aa:	52 9b       	sbis	0x0a, 2	; 10
    11ac:	46 c0       	rjmp	.+140    	; 0x123a <main+0x27c>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:216
        deltas.upDown = -1;
    }
    else if (digitalReadFast(BUTTON_DOWN_PIN) == false) {
    11ae:	51 99       	sbic	0x0a, 1	; 10
    11b0:	9a c0       	rjmp	.+308    	; 0x12e6 <main+0x328>
main():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:217
        deltas.upDown = 1;
    11b2:	c1 e0       	ldi	r28, 0x01	; 1
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:165

}

navdeltas_t getNavigationDeltas() {

    navdeltas_t deltas = { leftRight: 0,  upDown: 0 };
    11b4:	40 e0       	ldi	r20, 0x00	; 0
    11b6:	02 c0       	rjmp	.+4      	; 0x11bc <main+0x1fe>
    11b8:	c0 e0       	ldi	r28, 0x00	; 0
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:208
    if (bounceTimeout != 0 || repeatTimeout != 0) {
        return deltas;
    }

    if (digitalReadFast(BUTTON_LEFT_PIN) == false) {
        deltas.leftRight = -1;
    11ba:	4f ef       	ldi	r20, 0xFF	; 255
getNavigationDeltas():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:226
        return deltas;
    }

    // This only applies if a button was pressed

    bounceTimeout = DEBOUNCE_TICKS;
    11bc:	82 ee       	ldi	r24, 0xE2	; 226
    11be:	94 e0       	ldi	r25, 0x04	; 4
    11c0:	80 93 7f 38 	sts	0x387F, r24	; 0x80387f <bounceTimeout>
    11c4:	90 93 80 38 	sts	0x3880, r25	; 0x803880 <bounceTimeout+0x1>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:227
    if (repeating) {
    11c8:	66 23       	and	r22, r22
    11ca:	c9 f1       	breq	.+114    	; 0x123e <main+0x280>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:228
        repeatTimeout = REPEAT_TICKS2;
    11cc:	20 92 7d 38 	sts	0x387D, r2	; 0x80387d <repeatTimeout>
    11d0:	30 92 7e 38 	sts	0x387E, r3	; 0x80387e <repeatTimeout+0x1>
updateInterface():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:55

    // LEFT/RIGHT

    navdeltas_t deltas = getNavigationDeltas();

    if (deltas.leftRight != 0) {
    11d4:	44 23       	and	r20, r20
    11d6:	99 f0       	breq	.+38     	; 0x11fe <main+0x240>
updateMenuItemValue():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:342
    }
}

void updateMenuItemValue(int8_t delta) {

    tweakTimeout = TWEAK_TICKS;
    11d8:	00 93 8e 38 	sts	0x388E, r16	; 0x80388e <tweakTimeout>
    11dc:	10 93 8f 38 	sts	0x388F, r17	; 0x80388f <tweakTimeout+0x1>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:344

    switch (currentMenuItem) {
    11e0:	80 91 89 38 	lds	r24, 0x3889	; 0x803889 <currentMenuItem>
    11e4:	90 91 8a 38 	lds	r25, 0x388A	; 0x80388a <currentMenuItem+0x1>
    11e8:	81 30       	cpi	r24, 0x01	; 1
    11ea:	91 05       	cpc	r25, r1
    11ec:	c9 f1       	breq	.+114    	; 0x1260 <main+0x2a2>
    11ee:	80 f1       	brcs	.+96     	; 0x1250 <main+0x292>
    11f0:	84 30       	cpi	r24, 0x04	; 4
    11f2:	91 05       	cpc	r25, r1
    11f4:	09 f4       	brne	.+2      	; 0x11f8 <main+0x23a>
    11f6:	56 c0       	rjmp	.+172    	; 0x12a4 <main+0x2e6>
    11f8:	05 97       	sbiw	r24, 0x05	; 5
    11fa:	09 f4       	brne	.+2      	; 0x11fe <main+0x240>
    11fc:	5e c0       	rjmp	.+188    	; 0x12ba <main+0x2fc>
updateInterface():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:59

    if (deltas.leftRight != 0) {
        updateMenuItemValue(deltas.leftRight);
    }

    if (deltas.upDown != 0) {
    11fe:	cc 23       	and	r28, r28
    1200:	09 f4       	brne	.+2      	; 0x1204 <main+0x246>
    1202:	71 c0       	rjmp	.+226    	; 0x12e6 <main+0x328>
updateMenuItem():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:324
    }
}

void updateMenuItem(int8_t delta) {

    tweakTimeout = TWEAK_TICKS;
    1204:	00 93 8e 38 	sts	0x388E, r16	; 0x80388e <tweakTimeout>
    1208:	10 93 8f 38 	sts	0x388F, r17	; 0x80388f <tweakTimeout+0x1>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:327

    uint8_t currentIndex = 0;
    for (uint8_t i = 0; i < currentMenuItems.length; ++i) {
    120c:	50 91 10 38 	lds	r21, 0x3810	; 0x803810 <currentMenuItems+0xe>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:328
        if (currentMenuItems.items[i] == currentMenuItem) {
    1210:	80 91 89 38 	lds	r24, 0x3889	; 0x803889 <currentMenuItem>
    1214:	90 91 8a 38 	lds	r25, 0x388A	; 0x80388a <currentMenuItem+0x1>
    1218:	e2 e0       	ldi	r30, 0x02	; 2
    121a:	f8 e3       	ldi	r31, 0x38	; 56
main():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:327
void updateMenuItem(int8_t delta) {

    tweakTimeout = TWEAK_TICKS;

    uint8_t currentIndex = 0;
    for (uint8_t i = 0; i < currentMenuItems.length; ++i) {
    121c:	40 e0       	ldi	r20, 0x00	; 0
updateMenuItem():
    121e:	54 17       	cp	r21, r20
    1220:	09 f4       	brne	.+2      	; 0x1224 <main+0x266>
    1222:	51 c0       	rjmp	.+162    	; 0x12c6 <main+0x308>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:328
        if (currentMenuItems.items[i] == currentMenuItem) {
    1224:	21 91       	ld	r18, Z+
    1226:	31 91       	ld	r19, Z+
    1228:	28 17       	cp	r18, r24
    122a:	39 07       	cpc	r19, r25
    122c:	09 f4       	brne	.+2      	; 0x1230 <main+0x272>
    122e:	4c c0       	rjmp	.+152    	; 0x12c8 <main+0x30a>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:327
void updateMenuItem(int8_t delta) {

    tweakTimeout = TWEAK_TICKS;

    uint8_t currentIndex = 0;
    for (uint8_t i = 0; i < currentMenuItems.length; ++i) {
    1230:	4f 5f       	subi	r20, 0xFF	; 255
    1232:	f5 cf       	rjmp	.-22     	; 0x121e <main+0x260>
main():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:165

}

navdeltas_t getNavigationDeltas() {

    navdeltas_t deltas = { leftRight: 0,  upDown: 0 };
    1234:	c0 e0       	ldi	r28, 0x00	; 0
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:211

    if (digitalReadFast(BUTTON_LEFT_PIN) == false) {
        deltas.leftRight = -1;
    }
    else if (digitalReadFast(BUTTON_RIGHT_PIN) == false) {
        deltas.leftRight = 1;
    1236:	41 e0       	ldi	r20, 0x01	; 1
    1238:	c1 cf       	rjmp	.-126    	; 0x11bc <main+0x1fe>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:214
    }
    else if (digitalReadFast(BUTTON_UP_PIN) == false) {
        deltas.upDown = -1;
    123a:	cf ef       	ldi	r28, 0xFF	; 255
    123c:	bb cf       	rjmp	.-138    	; 0x11b4 <main+0x1f6>
getNavigationDeltas():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:231
    bounceTimeout = DEBOUNCE_TICKS;
    if (repeating) {
        repeatTimeout = REPEAT_TICKS2;
    }
    else {
        repeating = true;
    123e:	d0 93 7c 38 	sts	0x387C, r29	; 0x80387c <repeating>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:232
        repeatTimeout = REPEAT_TICKS1;
    1242:	80 e7       	ldi	r24, 0x70	; 112
    1244:	97 e1       	ldi	r25, 0x17	; 23
    1246:	80 93 7d 38 	sts	0x387D, r24	; 0x80387d <repeatTimeout>
    124a:	90 93 7e 38 	sts	0x387E, r25	; 0x80387e <repeatTimeout+0x1>
    124e:	c2 cf       	rjmp	.-124    	; 0x11d4 <main+0x216>
updateMenuItemValue():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:347
    tweakTimeout = TWEAK_TICKS;

    switch (currentMenuItem) {

        case ITEM_OCTAVE: {
            uint8_t newOctave = currentOctave + delta;
    1250:	80 91 37 38 	lds	r24, 0x3837	; 0x803837 <currentOctave>
    1254:	48 0f       	add	r20, r24
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:348
            if (newOctave >= 0 && newOctave <= 7) {
    1256:	48 30       	cpi	r20, 0x08	; 8
    1258:	90 f6       	brcc	.-92     	; 0x11fe <main+0x240>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:349
                currentOctave = newOctave;
    125a:	40 93 37 38 	sts	0x3837, r20	; 0x803837 <currentOctave>
    125e:	cf cf       	rjmp	.-98     	; 0x11fe <main+0x240>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:355
            }
            break;
        }

        case ITEM_SHAPE: {
            uint8_t oscillatorNumber = currentMenu == MENU_OSCILLATOR1 ? 0 : 1;
    1260:	81 e0       	ldi	r24, 0x01	; 1
    1262:	90 e0       	ldi	r25, 0x00	; 0
    1264:	20 91 8b 38 	lds	r18, 0x388B	; 0x80388b <currentMenu>
    1268:	30 91 8c 38 	lds	r19, 0x388C	; 0x80388c <currentMenu+0x1>
    126c:	21 30       	cpi	r18, 0x01	; 1
    126e:	31 05       	cpc	r19, r1
    1270:	11 f4       	brne	.+4      	; 0x1276 <main+0x2b8>
    1272:	90 e0       	ldi	r25, 0x00	; 0
    1274:	80 e0       	ldi	r24, 0x00	; 0
getOscillatorWaveform():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:89
    return (uint8_t) sample;
}

waveform_t getOscillatorWaveform(uint8_t oscillatorNumber) {

    return oscillators[oscillatorNumber].waveform;
    1276:	23 e1       	ldi	r18, 0x13	; 19
    1278:	28 9f       	mul	r18, r24
    127a:	f0 01       	movw	r30, r0
    127c:	29 9f       	mul	r18, r25
    127e:	f0 0d       	add	r31, r0
    1280:	11 24       	eor	r1, r1
    1282:	ef 5e       	subi	r30, 0xEF	; 239
    1284:	f7 4c       	sbci	r31, 0xC7	; 199
updateMenuItemValue():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:357
            waveform_t currentWaveform = getOscillatorWaveform(oscillatorNumber);
            waveform_t newWaveform = currentWaveform + delta;
    1286:	80 81       	ld	r24, Z
    1288:	91 81       	ldd	r25, Z+1	; 0x01
    128a:	84 0f       	add	r24, r20
    128c:	91 1d       	adc	r25, r1
    128e:	47 fd       	sbrc	r20, 7
    1290:	9a 95       	dec	r25
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:358
            if (newWaveform >= WAVE_PULSE && newWaveform <= WAVE_TRIANGLE) {
    1292:	83 30       	cpi	r24, 0x03	; 3
    1294:	91 05       	cpc	r25, r1
    1296:	08 f0       	brcs	.+2      	; 0x129a <main+0x2dc>
    1298:	b2 cf       	rjmp	.-156    	; 0x11fe <main+0x240>
setOscillatorWaveform():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:94
}

void setOscillatorWaveform(uint8_t oscillatorNumber, waveform_t newWaveform) {

    oscillators[oscillatorNumber].waveform = newWaveform;
    129a:	80 83       	st	Z, r24
    129c:	91 83       	std	Z+1, r25	; 0x01
updateMenuItemValue():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:360
                setOscillatorWaveform(oscillatorNumber, newWaveform);
                updateCurrentMenuItems(); // Pulse waves have pulse options, others do not.
    129e:	0e 94 a2 02 	call	0x544	; 0x544 <updateCurrentMenuItems()>
    12a2:	ad cf       	rjmp	.-166    	; 0x11fe <main+0x240>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:371
        // TODO: ITEM_PULSE_SPEED

        case ITEM_DETUNE: {
            // only the second oscillator gets detuned
            int8_t currentDetune = getOscillatorDetune(1);
            int8_t newDetune = currentDetune + delta;
    12a4:	80 91 36 38 	lds	r24, 0x3836	; 0x803836 <oscillators+0x25>
    12a8:	48 0f       	add	r20, r24
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:372
            if (newDetune >= -70 && newDetune <= 70) {
    12aa:	86 e4       	ldi	r24, 0x46	; 70
    12ac:	84 0f       	add	r24, r20
    12ae:	8d 38       	cpi	r24, 0x8D	; 141
    12b0:	08 f0       	brcs	.+2      	; 0x12b4 <main+0x2f6>
    12b2:	a5 cf       	rjmp	.-182    	; 0x11fe <main+0x240>
setOscillatorDetune():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:104
    return oscillators[oscillatorNumber].detune;
}

void setOscillatorDetune(uint8_t oscillatorNumber, int8_t newDetune) {

    oscillators[oscillatorNumber].detune = newDetune;
    12b4:	40 93 36 38 	sts	0x3836, r20	; 0x803836 <oscillators+0x25>
    12b8:	a2 cf       	rjmp	.-188    	; 0x11fe <main+0x240>
updateMenuItemValue():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:382


        case ITEM_SYNC: {
            // this lives in the second oscillator's menu
            bool currentSync = getOscillatorSync();
            setOscillatorSync(!currentSync);
    12ba:	80 91 01 38 	lds	r24, 0x3801	; 0x803801 <syncOscillators>
    12be:	8d 27       	eor	r24, r29
setOscillatorSync():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:114
    return syncOscillators;
}

void setOscillatorSync(bool newSync) {

    syncOscillators = newSync;
    12c0:	80 93 01 38 	sts	0x3801, r24	; 0x803801 <syncOscillators>
    12c4:	9c cf       	rjmp	.-200    	; 0x11fe <main+0x240>
main():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:326

void updateMenuItem(int8_t delta) {

    tweakTimeout = TWEAK_TICKS;

    uint8_t currentIndex = 0;
    12c6:	40 e0       	ldi	r20, 0x00	; 0
updateMenuItem():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:334
            currentIndex = i;
            break;
        }
    }

    uint8_t newIndex = currentIndex + delta;
    12c8:	c4 0f       	add	r28, r20
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:335
    if (newIndex >= 0 && newIndex < currentMenuItems.length) {
    12ca:	c5 17       	cp	r28, r21
    12cc:	60 f4       	brcc	.+24     	; 0x12e6 <main+0x328>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:336
        currentMenuItem = currentMenuItems.items[newIndex];
    12ce:	ec 2f       	mov	r30, r28
    12d0:	f0 e0       	ldi	r31, 0x00	; 0
    12d2:	ee 0f       	add	r30, r30
    12d4:	ff 1f       	adc	r31, r31
    12d6:	ee 5f       	subi	r30, 0xFE	; 254
    12d8:	f7 4c       	sbci	r31, 0xC7	; 199
    12da:	80 81       	ld	r24, Z
    12dc:	91 81       	ldd	r25, Z+1	; 0x01
    12de:	80 93 89 38 	sts	0x3889, r24	; 0x803889 <currentMenuItem>
    12e2:	90 93 8a 38 	sts	0x388A, r25	; 0x80388a <currentMenuItem+0x1>
updateInterface():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:69

    //int8_t key = getPressedKey();
    int8_t key = 0; // TODO
    rawKey = 1000; // TODO

    if (digitalReadFast(BUTTON_SELECT_PIN) == false) { // TODO: optimise
    12e6:	11 99       	sbic	0x02, 1	; 2
    12e8:	33 c0       	rjmp	.+102    	; 0x1350 <main+0x392>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:70
        if (currentKey != -1) {
    12ea:	80 91 38 38 	lds	r24, 0x3838	; 0x803838 <currentKey>
    12ee:	8f 3f       	cpi	r24, 0xFF	; 255
    12f0:	a9 f0       	breq	.+42     	; 0x131c <main+0x35e>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:71
            currentKey = -1;
    12f2:	7f ef       	ldi	r23, 0xFF	; 255
    12f4:	70 93 38 38 	sts	0x3838, r23	; 0x803838 <currentKey>
clearNote():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:32
// EXPORTS

void clearNote() {

    // for now this is one to one with jump == -1, but once we have things like envelopes that assumption won't hold
    isPlaying = false;
    12f8:	10 92 8d 38 	sts	0x388D, r1	; 0x80388d <isPlaying>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:34

    oscillators[0].jump = -1;
    12fc:	c0 92 13 38 	sts	0x3813, r12	; 0x803813 <oscillators+0x2>
    1300:	d0 92 14 38 	sts	0x3814, r13	; 0x803814 <oscillators+0x3>
    1304:	e0 92 15 38 	sts	0x3815, r14	; 0x803815 <oscillators+0x4>
    1308:	f0 92 16 38 	sts	0x3816, r15	; 0x803816 <oscillators+0x5>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:35
    oscillators[1].jump = -1;
    130c:	c0 92 26 38 	sts	0x3826, r12	; 0x803826 <oscillators+0x15>
    1310:	d0 92 27 38 	sts	0x3827, r13	; 0x803827 <oscillators+0x16>
    1314:	e0 92 28 38 	sts	0x3828, r14	; 0x803828 <oscillators+0x17>
    1318:	f0 92 29 38 	sts	0x3829, r15	; 0x803829 <oscillators+0x18>
updateInterface():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:76
            clearNote();
        }

        // the mode button is held down so if a key is pressed then the user is selecting a mode
        tweakTimeout = TWEAK_TICKS; // turn on the screen
    131c:	00 93 8e 38 	sts	0x388E, r16	; 0x80388e <tweakTimeout>
    1320:	10 93 8f 38 	sts	0x388F, r17	; 0x80388f <tweakTimeout+0x1>
setCurrentMenu():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:303
    }
}

void setCurrentMenu(menu_t newMenu) {

    if (newMenu == currentMenu) {
    1324:	80 91 8b 38 	lds	r24, 0x388B	; 0x80388b <currentMenu>
    1328:	90 91 8c 38 	lds	r25, 0x388C	; 0x80388c <currentMenu+0x1>
    132c:	89 2b       	or	r24, r25
    132e:	09 f4       	brne	.+2      	; 0x1332 <main+0x374>
    1330:	b9 ce       	rjmp	.-654    	; 0x10a4 <main+0xe6>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:311

    switch (newMenu) {
        case MENU_OCTAVE:
        case MENU_OSCILLATOR1:
        case MENU_OSCILLATOR2: {
            currentMenu = newMenu;
    1332:	10 92 8b 38 	sts	0x388B, r1	; 0x80388b <currentMenu>
    1336:	10 92 8c 38 	sts	0x388C, r1	; 0x80388c <currentMenu+0x1>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:312
            updateCurrentMenuItems();
    133a:	0e 94 a2 02 	call	0x544	; 0x544 <updateCurrentMenuItems()>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:313
            currentMenuItem = currentMenuItems.items[0];
    133e:	80 91 02 38 	lds	r24, 0x3802	; 0x803802 <currentMenuItems>
    1342:	90 91 03 38 	lds	r25, 0x3803	; 0x803803 <currentMenuItems+0x1>
    1346:	80 93 89 38 	sts	0x3889, r24	; 0x803889 <currentMenuItem>
    134a:	90 93 8a 38 	sts	0x388A, r25	; 0x80388a <currentMenuItem+0x1>
    134e:	aa ce       	rjmp	.-684    	; 0x10a4 <main+0xe6>
updateInterface():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/interface.cpp:104
        // Prefer to keep the previous note if it looks like something was pressed because the most likely explanation is that two currentKeys are held down and it is _just_ barely putting us out of range of either of them.
        if (key == -1 && rawKey > 740) {
            key = currentKey;
        }

        currentKey = key;
    1350:	10 92 38 38 	sts	0x3838, r1	; 0x803838 <currentKey>
setNote():
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:40
}

void setNote(uint8_t octave, int8_t key) {

    uint8_t noteOffset = 3 + (octave * 12) + key;
    1354:	20 91 37 38 	lds	r18, 0x3837	; 0x803837 <currentOctave>
    1358:	8c e0       	ldi	r24, 0x0C	; 12
    135a:	28 9f       	mul	r18, r24
    135c:	20 2d       	mov	r18, r0
    135e:	11 24       	eor	r1, r1
    1360:	2d 5f       	subi	r18, 0xFD	; 253
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:41
    oscillators[0].jump = notes[noteOffset];
    1362:	30 e0       	ldi	r19, 0x00	; 0
    1364:	f9 01       	movw	r30, r18
    1366:	ee 0f       	add	r30, r30
    1368:	ff 1f       	adc	r31, r31
    136a:	ee 0f       	add	r30, r30
    136c:	ff 1f       	adc	r31, r31
    136e:	ec 56       	subi	r30, 0x6C	; 108
    1370:	fb 46       	sbci	r31, 0x6B	; 107
    1372:	80 81       	ld	r24, Z
    1374:	91 81       	ldd	r25, Z+1	; 0x01
    1376:	a2 81       	ldd	r26, Z+2	; 0x02
    1378:	b3 81       	ldd	r27, Z+3	; 0x03
    137a:	80 93 13 38 	sts	0x3813, r24	; 0x803813 <oscillators+0x2>
    137e:	90 93 14 38 	sts	0x3814, r25	; 0x803814 <oscillators+0x3>
    1382:	a0 93 15 38 	sts	0x3815, r26	; 0x803815 <oscillators+0x4>
    1386:	b0 93 16 38 	sts	0x3816, r27	; 0x803816 <oscillators+0x5>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:42
    oscillators[1].jump = notes[noteOffset + oscillators[1].detune/10]; // TODO: interpolate for the fractional part
    138a:	80 91 36 38 	lds	r24, 0x3836	; 0x803836 <oscillators+0x25>
    138e:	6a e0       	ldi	r22, 0x0A	; 10
    1390:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <__divmodqi4>
    1394:	f9 01       	movw	r30, r18
    1396:	e8 0f       	add	r30, r24
    1398:	f1 1d       	adc	r31, r1
    139a:	87 fd       	sbrc	r24, 7
    139c:	fa 95       	dec	r31
    139e:	ee 0f       	add	r30, r30
    13a0:	ff 1f       	adc	r31, r31
    13a2:	ee 0f       	add	r30, r30
    13a4:	ff 1f       	adc	r31, r31
    13a6:	ec 56       	subi	r30, 0x6C	; 108
    13a8:	fb 46       	sbci	r31, 0x6B	; 107
    13aa:	80 81       	ld	r24, Z
    13ac:	91 81       	ldd	r25, Z+1	; 0x01
    13ae:	a2 81       	ldd	r26, Z+2	; 0x02
    13b0:	b3 81       	ldd	r27, Z+3	; 0x03
    13b2:	80 93 26 38 	sts	0x3826, r24	; 0x803826 <oscillators+0x15>
    13b6:	90 93 27 38 	sts	0x3827, r25	; 0x803827 <oscillators+0x16>
    13ba:	a0 93 28 38 	sts	0x3828, r26	; 0x803828 <oscillators+0x17>
    13be:	b0 93 29 38 	sts	0x3829, r27	; 0x803829 <oscillators+0x18>
/var/folders/gb/dm3rvp2j3bd4ksbv78mfcn0w0000gn/T/arduino-sketch-996468E4C743FD3AC570F51B6840BC2B/sketch/engine.cpp:44

    isPlaying = true;
    13c2:	d0 93 8d 38 	sts	0x388D, r29	; 0x80388d <isPlaying>
    13c6:	6e ce       	rjmp	.-804    	; 0x10a4 <main+0xe6>

000013c8 <__divmodqi4>:
__divmodqi4():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1366
    13c8:	87 fb       	bst	r24, 7
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1367
    13ca:	08 2e       	mov	r0, r24
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1368
    13cc:	06 26       	eor	r0, r22
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1369
    13ce:	87 fd       	sbrc	r24, 7
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1370
    13d0:	81 95       	neg	r24
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1371
    13d2:	67 fd       	sbrc	r22, 7
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1372
    13d4:	61 95       	neg	r22
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1373
    13d6:	0e 94 27 0a 	call	0x144e	; 0x144e <__udivmodqi4>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1374
    13da:	0e f4       	brtc	.+2      	; 0x13de <__divmodqi4_1>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1375
    13dc:	91 95       	neg	r25

000013de <__divmodqi4_1>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1377
    13de:	07 fc       	sbrc	r0, 7
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1378
    13e0:	81 95       	neg	r24

000013e2 <__divmodqi4_exit>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1380
    13e2:	08 95       	ret

000013e4 <__udivmodsi4>:
__udivmodsi4():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1638
    13e4:	a1 e2       	ldi	r26, 0x21	; 33
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1639
    13e6:	1a 2e       	mov	r1, r26
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1640
    13e8:	aa 1b       	sub	r26, r26
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1641
    13ea:	bb 1b       	sub	r27, r27
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1642
    13ec:	fd 01       	movw	r30, r26
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1644
    13ee:	0d c0       	rjmp	.+26     	; 0x140a <__udivmodsi4_ep>

000013f0 <__udivmodsi4_loop>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1646
    13f0:	aa 1f       	adc	r26, r26
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1647
    13f2:	bb 1f       	adc	r27, r27
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1648
    13f4:	ee 1f       	adc	r30, r30
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1649
    13f6:	ff 1f       	adc	r31, r31
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1650
    13f8:	a2 17       	cp	r26, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1651
    13fa:	b3 07       	cpc	r27, r19
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1652
    13fc:	e4 07       	cpc	r30, r20
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1653
    13fe:	f5 07       	cpc	r31, r21
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1654
    1400:	20 f0       	brcs	.+8      	; 0x140a <__udivmodsi4_ep>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1655
    1402:	a2 1b       	sub	r26, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1656
    1404:	b3 0b       	sbc	r27, r19
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1657
    1406:	e4 0b       	sbc	r30, r20
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1658
    1408:	f5 0b       	sbc	r31, r21

0000140a <__udivmodsi4_ep>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1660
    140a:	66 1f       	adc	r22, r22
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1661
    140c:	77 1f       	adc	r23, r23
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1662
    140e:	88 1f       	adc	r24, r24
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1663
    1410:	99 1f       	adc	r25, r25
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1664
    1412:	1a 94       	dec	r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1665
    1414:	69 f7       	brne	.-38     	; 0x13f0 <__udivmodsi4_loop>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1667
    1416:	60 95       	com	r22
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1668
    1418:	70 95       	com	r23
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1669
    141a:	80 95       	com	r24
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1670
    141c:	90 95       	com	r25
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1672
    141e:	9b 01       	movw	r18, r22
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1674
    1420:	ac 01       	movw	r20, r24
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1676
    1422:	bd 01       	movw	r22, r26
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1678
    1424:	cf 01       	movw	r24, r30
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1680
    1426:	08 95       	ret

00001428 <__muluhisi3>:
__muluhisi3():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:626
    1428:	0e 94 39 0a 	call	0x1472	; 0x1472 <__umulhisi3>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:627
    142c:	a5 9f       	mul	r26, r21
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:628
    142e:	90 0d       	add	r25, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:629
    1430:	b4 9f       	mul	r27, r20
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:630
    1432:	90 0d       	add	r25, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:631
    1434:	a4 9f       	mul	r26, r20
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:632
    1436:	80 0d       	add	r24, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:633
    1438:	91 1d       	adc	r25, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:634
    143a:	11 24       	eor	r1, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:635
    143c:	08 95       	ret

0000143e <__mulshisi3>:
__mulshisi3():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:603
    143e:	b7 ff       	sbrs	r27, 7
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:605
    1440:	0c 94 14 0a 	jmp	0x1428	; 0x1428 <__muluhisi3>

00001444 <__mulohisi3>:
__mulohisi3():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:613
    1444:	0e 94 14 0a 	call	0x1428	; 0x1428 <__muluhisi3>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:615
    1448:	82 1b       	sub	r24, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:616
    144a:	93 0b       	sbc	r25, r19
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:617
    144c:	08 95       	ret

0000144e <__udivmodqi4>:
__udivmodqi4():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1346
    144e:	99 1b       	sub	r25, r25
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1347
    1450:	79 e0       	ldi	r23, 0x09	; 9
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1348
    1452:	04 c0       	rjmp	.+8      	; 0x145c <__udivmodqi4_ep>

00001454 <__udivmodqi4_loop>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1350
    1454:	99 1f       	adc	r25, r25
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1351
    1456:	96 17       	cp	r25, r22
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1352
    1458:	08 f0       	brcs	.+2      	; 0x145c <__udivmodqi4_ep>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1353
    145a:	96 1b       	sub	r25, r22

0000145c <__udivmodqi4_ep>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1355
    145c:	88 1f       	adc	r24, r24
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1356
    145e:	7a 95       	dec	r23
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1357
    1460:	c9 f7       	brne	.-14     	; 0x1454 <__udivmodqi4_loop>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1358
    1462:	80 95       	com	r24
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1360
    1464:	08 95       	ret

00001466 <__tablejump2__>:
__tablejump2__():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
    1466:	ee 0f       	add	r30, r30
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
    1468:	ff 1f       	adc	r31, r31
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2328
    146a:	05 90       	lpm	r0, Z+
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2329
    146c:	f4 91       	lpm	r31, Z
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2330
    146e:	e0 2d       	mov	r30, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2331
    1470:	09 94       	ijmp

00001472 <__umulhisi3>:
__umulhisi3():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:564
    1472:	a2 9f       	mul	r26, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:565
    1474:	b0 01       	movw	r22, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:566
    1476:	b3 9f       	mul	r27, r19
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:567
    1478:	c0 01       	movw	r24, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:568
    147a:	a3 9f       	mul	r26, r19
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:573
    147c:	70 0d       	add	r23, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:574
    147e:	81 1d       	adc	r24, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:575
    1480:	11 24       	eor	r1, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:576
    1482:	91 1d       	adc	r25, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:580
    1484:	b2 9f       	mul	r27, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:581
    1486:	70 0d       	add	r23, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:582
    1488:	81 1d       	adc	r24, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:583
    148a:	11 24       	eor	r1, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:584
    148c:	91 1d       	adc	r25, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:585
    148e:	08 95       	ret

00001490 <_exit>:
exit():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
    1490:	f8 94       	cli

00001492 <__stop_program>:
__stop_program():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
    1492:	ff cf       	rjmp	.-2      	; 0x1492 <__stop_program>
